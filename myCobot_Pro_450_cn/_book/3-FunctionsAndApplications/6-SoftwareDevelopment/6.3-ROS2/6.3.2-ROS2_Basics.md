# 1 ROS2 项目结构

## 1.1 Colcon 工作区

Colocn 工作区是创建、修改和编译软件包的目录。Colcon 的工作区可以直观地描述为一个仓库，其中包含各种 ROS 项目，便于系统的组织、管理和调用。

- **Create workspace**:

```bash
mkdir -p ~/colcon_ws/src # 创建文件夹
cd ~/colcon_ws/ # 输入文件夹
colcon build # 在工作区中构建代码。
```

**注意：** colcon 支持选项 `-symlink-install`。这允许通过更改源空间中的文件（如 Python 文件或其他未编译的资源）来更改已安装的文件，从而加快迭代速度。避免每次修改 Python 脚本时都需要重新编译。

```bash
colcon build --symlink-install
```

ROS 工作区是一个具有特定结构的目录。通常会有一个 `src` 子目录。在该子目录中，存放着 ROS 软件包的源代码。通常情况下，该目录一开始是空的。

colcon 会进行源代码外编译。默认情况下，它将创建以下目录作为 `src` 目录的同级目录：

```bash
src/: 用于 ROS2 的 colcon 软件包（源代码包）

build/: 存放中间文件的位置。例如，为每个软件包创建一个子文件夹，在其中调用 CMake。

install/: 每个软件包的安装位置。默认情况下，每个软件包都会安装到一个单独的子目录中。

log/: 包含每个 colcon 调用的各种日志信息。
```

ROS2 工作区的目录结构如下：

```bash
WorkSpace --- 定制的工作空间
     |--- build: 存放中间文件的目录。在此目录下，将为每个功能包创建一个单独的子目录。
     |--- install: 安装目录中的每个功能包都将创建一个单独的子目录。
     |--- log: 日志目录，用于存储日志文件。
     |--- src: 用于存储功能包源代码的目录。
         |-- C++ 功能包
             |-- package.xml: 软件包信息，如：软件包名称、版本、作者、依赖关系。
             |-- CMakeLists.txt: 配置编译规则，如源文件、依赖关系和目标文件。
             |-- src: C++ 源文件目录。
             |-- include: 头文件目录。
             |-- msg: 消息接口文件目录。
             |-- srv: 服务接口文件目录。
             |-- action: 行动界面文件目录。
         |-- Python 功能包
             |-- package.xml: 软件包信息，如：软件包名称、版本、作者、依赖关系。
             |-- setup.py: 类似于 C++ 功能包的 CMakeLists.txt。
             |-- setup.cfg: 功能包基本配置文件。
             |-- resource: 资源目录。
             |-- test: 存储与测试相关的文件。
             |-- 与函数包同名的目录：Python 源文件目录。
```

## 1.2 ROS2 包

软件包不仅是 Linux 上的软件包，也是 colcon 编译的基本单元。我们使用 "colcon build "编译的对象就是每个 ROS2 软件包。

**创建自己的包：**

- 使用 Python 创建软件包的命令语法是

```bash
ros2 pkg create --build-type ament_python <package_name>
```

- 例如：

```bash
ros2 pkg create --build-type ament_python --node-name my_node my_package
```

# 2 基本工具命令

本章将介绍 ROS2 的常用命令工具。

## 2.1 Topics

ROS 2 将复杂的系统分解成许多模块化节点。主题是 ROS 图形的一个重要元素，是节点交换信息的总线。 主题是节点之间移动数据的主要方式之一，因此也是系统不同部分之间移动数据的主要方式之一。

具体参考: [官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html)

- **主题帮助**

```bash
ros2 topics -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **节点关系图**

```bash
rqt_graph
```

- **了解与主题相关的命令**

```bash
ros2 topics -h
```

- **主题列表**

```bash
ros2 topic list
ros2 topic list -t # Display the corresponding message type
```

- **查看主题内容**

```bash
ros2 topic echo <topic_name>
ros2 topic echo /turtle1/cmd_vel
```

- **显示与主题相关的信息，键入**

```bash
ros2 topic info <topic_name>
# 输出 /turtle1/cmd_vel 主题相关信息
ros2 topic info /turtle1/cmd_vel
```

- **显示接口相关信息**

```bash
ros2 interface show <msg_type>
# 输出几何_msgs/msg/Twist 接口相关信息
ros2 interface show geometry_msgs/msg/Twist
```

- **发布命令**

```bash
ros2 topic pub <topic_name> <msg_type> '<args>'
# 发出速度命令
ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
# 以一定频率发出速度指令
ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
```

- **查看发布主题的频率**

```bash
ros2 topic hz <topic_name>
# 输出 /turtle1/cmd_vel 发布频率
ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
```

## 2.2 Nodes

ROS 中的每个节点都应负责一个单一的模块目的（例如，一个节点负责控制车轮电机，一个节点负责控制激光测距仪等）。每个节点都可以通过主题、服务、操作或参数向其他节点发送和接收数据。
一个完整的机器人系统由许多协同工作的节点组成。在 ROS 2 中，单个可执行文件（C++ 程序、Python 程序等）可包含一个或多个节点。

具体参考: [官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes.html)

- **nodes 帮助**

```bash
ros2 nodes -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **查看节点列表**

```bash
ros2 node list
```

- **查看节点关系图 m**

```bash
rqt_graph
```

- **Remapping**

```bash
ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle
ros2 node list
```

- **查看节点信息**

```bash
ros2 node info <node_name>
ros2 node info /my_turtle
```

## 2.3 Servics

服务是 ROS 图中节点的另一种通信方式。与主题的 "发布者-订阅者 "模式相比，服务基于 "调用-响应 "模式。主题允许节点订阅数据流并获得持续更新，而服务只有在客户端特别调用时才会提供数据。

具体参考资料： [官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services.html)

- **服务帮助**

```bash
ros2 service -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **查看服务列表**

```bash
ros2 service list
# Display service list and message type
ros2 service list -t
```

- **查看服务接收的信息类型**

```bash
ros2 service type <service_name>
ros2 service type /clear
```

- **查找使用特定信息类型的服务**

```bash
ros2 service find <type_name>
ros2 service find std_srvs/srv/Empty
```

- **查看服务信息类型定义**

```bash
ros2 interface show <type_name>.srv
ros2 interface show std_srvs/srv/Empty.srv
```

- **调用服务命令清除行走轨道**

```bash
ros2 service call <service_name> <service_type>
ros2 service call /clear std_srvs/srv/Empty
```

- **生成一只新乌龟**

```bash
ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'turtle2'}"
```

## 2.4 Parameters

参数是节点的配置值。可以把参数看作节点的设置。节点可以将参数存储为整数、浮点数、布尔值、字符串和列表。在 ROS 2 中，每个节点都维护自己的参数。有关参数的更多背景信息，请参阅概念文档。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters.html)

- **参数帮助**

```bash
ros2 param -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **查看服务列表**

```bash
ros2 param list
```

- **获取参数值**

```bash
ros2 param get <node_name> <parameter_name>
ros2 param get /turtlesim background_g
```

- **设置参数值**

```bash
ros2 param set <node_name> <parameter_name> <value>
ros2 param set /turtlesim background_r 150
```

- **导出参数值**

```bash
ros2 param dump <node_name>
ros2 param dump /turtlesim
```

- **独立导入参数**

```bash
ros2 param load <node_name> <parameter_file>
ros2 param load /turtlesim ./turtlesim.yaml
```

- **同时启动节点和导入参数**

```bash
ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>
ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml
```

## 2.5 Actions

行动是 ROS 2 中的通信类型之一，适用于长时间运行的任务。行动由三部分组成：目标、反馈和结果。

操作建立在主题和服务的基础上。它们的功能与服务类似，只是操作可以抢占（可以在执行时取消）。与只返回单一响应的服务不同，它们还能提供稳定的反馈。

行动使用客户端-服务器模式，类似于发布者-订阅者模式（在主题教程中有所描述）。行动客户端 "节点向 "行动服务器 "节点发送目标，后者确认目标并返回反馈流和结果。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html)

- **action 帮助**

```bash
ros2 action -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

按 G|B|V|C|D|E|R|T，实现旋转，按 F 取消。

- **查看节点操作的服务器和客户端**

```bash
ros2 node info /turtlesim
```

- **查看行动列表**

```bash
ros2 action list
ros2 action list -t # show action type
```

- **查看行动信息**

```bash
ros2 action info <action>
ros2 action info /turtle1/rotate_absolute
```

- **查看行动信息内容**

```bash
ros2 interface show turtlesim/action/RotateAbsolute
```

- **发送行动目标信息**

```bash
ros2 action send_goal <action_name> <action_type>
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"
# With feedback information
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 0}" --feedback
```

## 2.6 RQt

RQt 是一个图形用户界面框架，它以插件的形式实现了各种工具和界面。人们可以在 RQt 中以停靠窗口的形式运行所有现有的图形用户界面工具！这些工具仍能以传统的独立方式运行，但 RQt 使其更易于在单一屏幕布局中管理所有不同的窗口。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Concepts/About-RQt.html)

您可以通过以下方式轻松运行任何 RQt 工具/插件：

```bash
rqt
```

- **rqt 帮助**

```bash
rqt -h
```

- **启动海龟模拟和键盘控制**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- 动作浏览器：/ Plugins -> Actions ->Action Type Browser

- 参数重新配置: / Plugins -> configuration ->Parameter Reconfigure

- 节点图: /Node Graph

- 控制转向: /Plugins -> Robot Tools -> Robot Steering

- 服务调用: /Plugins -> Services -> Service Caller

- 服务类型浏览器: Plugins -> Services -> Service Type Browser

- 消息发布: Plugins -> Topics -> Message Publisher

- 消息类型浏览器: Plugins -> Topics -> Message Type Browser

- 话题列表: Plugins -> Topics -> Topic Monitor

- 绘制曲线图: Plugins -> Visualization -> Plot

* **查看日志： rqt_console**

```bash
ros2 run rqt_console rqt_console
ros2 run turtlesim turtlesim_node
ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}"
```

## 2.7 TF2

tf2 是一个变换库，用户可以利用它跟踪多个坐标框架的时间变化。tf2 将坐标框架之间的关系保存在一个以时间为缓冲的树状结构中，用户可以在任意时间点对任意两个坐标框架之间的点、矢量等进行变换。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Intermediate/Tf2/Introduction-To-Tf2.html)

让我们先安装演示软件包及其依赖项。

```bash
sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations
```

- **跟随**

- 启动 2 只小乌龟，第一只小乌龟自动跟上第二只小乌龟

```bash
ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py
```

- 通过键盘控制第一只小乌龟的移动

```bash
ros2 run turtlesim turtle_teleop_key
```

- **查看 TF 树**

```bash
ros2 run tf2_tools view_frames.py
evince frames.pdf
```

- **查看两个坐标系之间的关系**

```bash
ros2 run tf2_ros tf2_echo [reference_frame] [target_frame]
ros2 run tf2_ros tf2_echo turtle2 turtle1
```

- **在 rviz 上查看 TF 关系**

```bash
ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz
```

## 2.8 URDF

URDF 是统一机器人描述格式，用于在 ROS 中指定机器人的几何形状和组织结构。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Intermediate/URDF/Adding-Physical-and-Collision-Properties-to-a-URDF-Model.html)

- **部分代码示例**

```bash
<?xml version="1.0"?>
<robot  xmlns:xacro="http://www.ros.org/wiki/xacro" name="firefighter" >
	
<xacro:property name="width" value=".2" />


  <link name="base">
    <visual>
      <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J1.dae"/>
      </geometry>
      <origin xyz = "0.0 -0.11 0 " rpy = " 0 0 0"/>
    </visual>
    <collision>
      <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J1.dae"/>
        </geometry>
        <origin xyz = "0.0 -0.11 0 " rpy = " 0 0 0"/>
    </collision>
  </link>

  <link name="link1">
    <visual>
      <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J2.dae"/>
      </geometry>
      <origin xyz = "0.0405 0 0.0475 " rpy = " -1.5708 0 -1.5708 "/>
    </visual>
    <collision>
     <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J2.dae"/>
      </geometry>
      <origin xyz = "0.0405 0 0.0475 " rpy = " -1.5708 0 -1.5708 "/>
    </collision>
  </link>

  <link name="link2">
    <visual>
      <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J3.dae"/>
      </geometry>
    <origin xyz = "0.0598 0.005 -0.203 " rpy = " 0 0 1.5708 "/>
    </visual>
    <collision>
      <geometry>
       <mesh filename="package://mycobot_description/urdf/mycobot_pro_450/PRO450_J3.dae"/>
      </geometry>
      <origin xyz = "0.0598  0.005 -0.203 " rpy = " 0 0 1.5708"/>
    </collision>
  </link>

  <joint name="joint1" type="revolute">
    <axis xyz="0 0 1"/>
    <limit effort = "1000.0" lower = "-2.8797" upper = "2.8797" velocity = "0"/>
    <parent link="base"/>
    <child link="link1"/>
    <origin xyz= "-0.0045 0 0.155" rpy = "0 0 0"/>  
  </joint>


  <joint name="joint2" type="revolute">
    <axis xyz="1 0 0"/>
    <limit effort = "1000.0" lower = "-2.0943" upper = "2.0943" velocity = "0"/>
    <parent link="link1"/>
    <child link="link2"/>
    <origin xyz= "0.05 0 0.048" rpy = "0 0 0"/>  
  </joint>


</robot>

```

可以看出，urdf 文件并不复杂，主要由 "link "和 "joint "两部分组成，这两部分不断重复。

- **link 部分**

link 元素描述了一个具有惯性、视觉特征和碰撞属性的刚体, 名字用于描述 link 本身的名称，内容如下：


- `<inertial>` (可选的)
  - 连杆的惯性特性
  * `<origin>` (可选，未指定时默认为身份)
    - 定义惯性参考系相对于连杆坐标系的参考坐标。该坐标必须在连杆重心处定义，其坐标轴不得与惯性主轴平行。
    - xyz (可选，默认为零向量)
      表示在 x、y、z x、y、zx、y、z 方向上的偏移量，单位为米。
    - rpy(可选：defaults to identity if not specified)
      表示坐标轴沿 RPY 方向的旋转角度，单位为弧度。
  - `<mass>`
    连杆的质量特性
  - `<inertia>`
    3×3 转动惯量矩阵，由六个独立量组成：ixx、ixx、ixz、iyy、iyz、izz。
- `<visual>` (可选的)

  - 连杆的视觉属性。它用于指定连杆显示的形状（矩形、圆柱形等）。同一连杆中可以有多个视觉元素，连杆的形状由两个元素构成。一般来说，模型比较复杂，可以通过 soildwork 绘制生成 stl 调用，简单的形状如添加末端效应器可以直接编写。同时，可以根据理论模型与实际模型的差距调整几何图形的位置。
  - `<namel>` (可选的)
    连杆几何形状的名称。
  - `<origin>` (可选，未指定时默认为身份)

    - 相对于连杆坐标系的几何坐标系。
    - xyz (可选：默认为零向量)
      表示在 x、y、z x、y、zx、y、z 方向上的偏移量，单位为米。
    - rpy (可选：defaults to identity if not specified)
      表示坐标轴沿 RPY 方向的旋转角度，单位为弧度。

  - `<geometry>` （必需）
    - 可视化的形状，可以是以下形状之一：
    - `<box>`
      一个包含长、宽、高等元素的矩形。原点位于中心。
    - `<cylinder>`
      圆柱体，元素包括半径和长度。原点中心。
    - `<sphere>`
      球体，包含半径的元素。原点位于中心。
    - `<mesh>`
      由文件确定的网格还提供了一个比例尺来定义其边界。建议使用 Collada .dae 文件，也支持 .stl 文件，但必须是本地文件。
  - `<material>` (可选)
    - 可视化组件的材料。它可以在链接标记之外定义，但必须在机器人标记之内。在链接标记外定义时，链接名称必须加引号。
    - `<color>`(可选)
      颜色，由红/绿/蓝/α 组成，范围 [0,1]。
    - `<texture>`(可选)
      材料属性，由文件定义。

* `<collision>` (可选)
  - 连杆的碰撞属性。碰撞属性不同于连杆的视觉属性，通常使用简单的碰撞模型来简化计算。同一连杆可以有多个碰撞属性标签，连杆的碰撞属性表示由其定义的一组几何图形组成。
  - `<name>` (可选)
    指定连杆几何形状的名称
  - `<origin>` (可选，defaults to identity if not specified)
    - 碰撞组件的参考坐标系是相对于链接坐标系的参考坐标系而言的。
    - xyz (可选, 默认零向量)
      表示在 x、y、z x、y、zx、y、z 方向上的偏移量，单位为米。
    - rpy (可选, defaults to identity if not specified)
      表示坐标轴沿 RPY 方向的旋转角度，单位为弧度。
  - `<geometry>`
    与上述几何元素描述相同

详细的元素和每个元素的作用可登录 [官方文档](http://wiki.ros.org/urdf/XML/link) 查看

- **joint 部分**

关节(JOINT)部分描述了关节的运动学和动力学特性，并规定了关节的安全限制。名字是指定关节的唯一名称

**类型：**

指定接头类型，类型可以是以下之一：

- revolute - 沿轴线旋转的铰链关节，其范围由上下限指定。
- 棱柱形 Continuous - 连续铰接接头，可绕轴旋转，没有上下限。
- 固定 Prismatic - 沿轴滑动的滑动接头，其滑动范围由上下限规定。所有自由度都被锁定。这种关节不需要轴、校准、动力学、限值或安全控制器。
- 浮动 Floating - 该关节允许所有 6 个自由度的运动。
- 平面 Plane - 该关节允许在垂直于轴线的平面内运动。

**关节要素：**

- `<origin>` (可选，defaults to identity if not specified)
  在从父链接到子链接的转换中，接头位于子链接的原点。修改该参数可以调整连杆的位置。可用于调整实际模型与理论模型之间的误差，但不建议大幅修改，因为该参数会影响连杆 stl 的位置，容易影响碰撞检测效果。

  - xyz (可选: 默认为零向量)
    代表 x、y、z 轴方向的偏移量，单位为米。
  - rpy (可选: 默认为零向量)
    表示绕固定轴的旋转角度：滚动绕 x 轴，俯仰绕 y 轴，偏航绕 z 轴，用弧度表示。

- `<parent>` (必需)

  - 父链接的名称是必填属性。
  - link  
    父链接的名称是机器人结构树中链接的名称。

- `<child>` (必需)

  - 子链接的名称是必填属性。
  - link  
    子链接的名称是机器人结构树中链接的名称。

- `<axis>`(可选: 默认为 (1,0,0))

  - 关节轴位于关节坐标系中。这是旋转轴（旋 转关节）、棱柱关节的运动轴和平面关节的标准平面。该轴在关节坐标系中指定。修改该参数可以调整关节绕其旋转的轴线。它通常用于调整旋转方向。如果模型旋转方向与实际旋转方向相反，只需乘以-1 即可。固定关节和浮动关节不需要这个元素。
  - xyz(必需)  
    代表轴向量的 x , y , z x,y,zx,y,z 分量，为标准化的向量。

- `<calibration>` (可选)

  - 关节的参考点，用于修正关节的绝对位置。
  - rising (可选)
    当关节向前移动时，参考点会触发一个上升沿。
  - falling (可选)
    当关节向前移动时，参考点触发下降沿。

- `<dynamics>`(可选)

  - 该元素用于指定接头的物理属性。其值用于描述接头的建模性能，尤其是在模拟过程中。

`<limit>` (当关节是旋转或平移关节时必需)

- 该元素是关节运动学约束。
- lower (可选, 默认为 0)
  指定关节运动范围下限的属性（旋转关节的单位是弧度，棱柱关节的单位是米）。连续关节忽略该属性。
- upper (可选, 默认为 0)
  指定关节运动范围上限的属性（旋转关节的单位是弧度，棱柱关节的单位是米）。连续关节忽略该属性。
- effort (必需)
  该属性指定了接头运行时的最大力。
- velocity (必需)
  该属性指定了联合运行时的最大速度。

`<mimic>`(可选)

- 该标签用于指定一个已定义的 joint，以模仿现有 joint。该 joint 的值可通过以下公式计算：
  `value = multiplier * other_joint_value + offset`
- joint(必需)
  要模仿的关节名称。
- multiplier(可选)
  指定上述公式中的乘数系数。
- offset(可选)
  指定上述公式中的偏移项。默认值为 0

`<safety_controller>` (可选)

- 该元素是安全控制限制。该元素下的数据将被读入 move_group，但实际上是无效的。Move_group 会跳过此限制，直接读取限制下的参数内容。同时，设置该元素可能会导致规划失败。
- soft_lower_limit (可选, 默认为 0)
  此属性指定联合安全控制边界的下限，即联合安全控制的起始限制点。该值必须大于上述限制的下限值。
- soft_upper_limit (可选, 默认为 0)
  该属性指定联合安全控制边界的上限，即联合安全控制的起始限制点。该值必须小于上述限制的上限值。
- k_position(可选, 默认为 0)
  该属性用于描述位置和速度之间的关系。
- k_velocity(必需)
  这一特性用于描述力和速度之间的关系。

详细的元素和每个元素的作用可以到 [http://wiki.ros.org/urdf/XML/joint](http://wiki.ros.org/urdf/XML/joint)查看。

- **安装依赖库**

```bash
sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher
sudo apt install ros-foxy-xacro
```

- **下载源代码**

```bash
cd ~/dev_ws
git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial
```

- **编译源代码**

```bash
colcon build --packages-select urdf_tutorial
```

- **运行示例**

```bash
ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf
```

## 2.9 Launch

ROS 2 中的启动系统负责帮助用户描述其系统的配置，然后按描述执行。系统配置包括运行哪些程序、在哪里运行、传递哪些参数，以及 ROS 特有的约定，通过为每个组件提供不同的配置，可以方便地在整个系统中重复使用组件。此外，它还负责监控已启动进程的状态，并对这些进程的状态变化做出报告和/或反应。

用 Python、XML 或 YAML 编写的启动文件可以启动和停止不同的节点，并触发和执行各种事件。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Intermediate/Launch/Creating-Launch-Files.html)

**设置**

创建一个新目录来存储启动文件:

```bash
mkdir launch
```

**编写启动文件**

让我们使用 turtlesim 软件包及其可执行文件制作一个 ROS 2 启动文件。如上所述

将完整代码复制并粘贴到 launch/turtlesim_mimic_launch.py 文件中：

```bash
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            namespace='turtlesim1',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            namespace='turtlesim2',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            executable='mimic',
            name='mimic',
            remappings=[
                ('/input/pose', '/turtlesim1/turtle1/pose'),
                ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
            ]
        )
    ])
```

**运行 ros2 启动文件**

要运行上文创建的启动文件，请进入之前创建的目录并运行以下命令：

语法格式为

```bash
ros2 launch <package_name> <launch_file_name>
```

```bash
cd launch
ros2 launch turtlesim_mimic_launch.py
```

- **启动帮助**

```bash
ros2 launch -h
```

- **运行节点**

```bash
ros2 launch turtlesim multisim.launch.py
```

- **检查启动文件的参数**

```bash
ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s
ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments
ros2 launch turtlebot3_bringup robot.launch.launch.py -s
```

- **运行带参数的启动文件**

```bash
ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr
```

- **运行节点并调试**

```bash
ros2 launch turtlesim turtlesim_node.launch.py -d
```

- **只有输出节点说明**

```bash
ros2 launch turtlesim turtlesim_node.launch.py -p
```

- **运行部件**

```bash
ros2 launch composition composition_demo.launch.py
```

## 2.10 Run

run 用于运行单个节点、组件程序

- **运行帮助**

```bash
ros2 run -h
```

- **运行节点**

```bash
ros2 run turtlesim turtlesim_node
```

- **带参数运行节点**

```bash
ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2
```

- **运行组件容器**

```bash
ros2 run rclcpp_components component_container
```

- **运行部件**

```bash
ros2 run composition manual_composition
```

## 2.11 Package

软件包可以看作是 ROS 2 代码的容器。如果你想安装你的代码或与他人分享，那么你就需要将其整理成一个软件包。有了软件包，你就可以发布你的 ROS 2 作品，并允许他人轻松构建和使用。

ROS 2 中的软件包创建使用 ament 作为构建系统，使用 colcon 作为构建工具。您可以使用官方支持的 CMake 或 Python 创建软件包，当然也存在其他构建类型。

具体参考资料：[官方教程](https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html)

**创建工作区**

为每个新工作区创建一个新目录。名称并不重要，但最好能说明工作区的用途。我们选择 ros2_ws 作为 "开发工作区 "的目录名：

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src
```

- **pkg 帮助**

```bash
ros2 pkg -h
```

- **功能包列表**

```bash
ros2 pkg executable turtlesim
```

- **输出功能包执行程序**

```bash
ros2 pkg executable turtlesim
```

- **创建 Python 软件包**

运行软件包创建命令前，请确保您已进入 src 文件夹。

```bash
cd ~/ros2_ws/src
```

在 ROS 2 中创建新软件包的命令语法是

```bash
ros2 pkg create --build-type ament_python <package_name>
# 你将使用可选参数 --node-name 在软件包中创建一个简单的 Hello World 类型的可执行文件。
ros2 pkg create --build-type ament_python --node-name my_node my_package
```

- **构建软件包**

将软件包放在工作区中尤为重要，因为通过在工作区根目录下运行 colcon build，可以一次性构建多个软件包。否则，您将不得不单独构建每个软件包。

```bash
# 返回工作区的根目录：
cd ~/ros2_ws
# 现在，您可以构建软件包了：
colcon build
```

- **获取设置文件**

要使用新软件包和可执行文件，首先要打开一个新终端，并将 ROS 2 的主安装程序作为源代码。

然后，在 ros2_ws 目录下运行以下命令，获取工作区的源代码：

```bash
source install/setup.bash
```

现在工作区已添加到路径中，您就可以使用新软件包的可执行文件了。

- **Use the package**

要运行创建软件包时使用 --node-name 参数创建的可执行文件，请输入命令：

```bash
ros2 run my_package my_node
```

---

[← 上一页](./6.3.1-EnvironmentSetup.md) | [下一页 →](./6.3.3-RVIZ2_Introduction.md)
