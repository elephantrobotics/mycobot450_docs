{"./":{"url":"./","title":"Introduction","keywords":"","body":"myCobot Pro 450 全谐波协作机械臂入门首选 核心文档 本文档包含从产品简介、详细的技术参数到用户须知和产品开发指导的全面信息。文档将深入介绍myCobot Pro 450机械臂的基础功能，并提供软件开发指南，展示成功的应用案例，帮助您了解如何将myCobot Pro 450有效整合进各种应用中。此外，我们还提供了丰富的支持与服务信息，确保您在遇到任何技术挑战时能够获得必要的帮助。 文档说明 根据您的需求以及myCobot Pro 450应用程序开发的专业水平，您可以选择从头到尾遵循该顺序进行阅读，或将其用作独立参考。您可以随时使用左侧的侧边栏导航跳转到本文档的任何部分，全文共分为以下五大板块： 产品信息 产品信息板块将为您提供机械臂的基本概述，包括主要功能、产品参数和电气特性等详细的技术规格，帮助您快速了解产品的基本特性和使用环境。此外，这一部分将详细介绍产品的应用实例和支持的扩展开发，为您提供必要的开发指南和资源。文末将给出相关购买链接和渠道，方便您进行购买。 基础设置 本章节是使用本产品的每一位用户必须仔细阅读的重要部分。它涵盖了关于产品使用、运输、储存及维护的关键须知，旨在确保用户在操作产品时的安全性和效率。此外，本章节也详细说明了因未遵循这些指南而可能导致的产品故障或损害的责任划分。 功能与应用 功能与应用板块详细介绍了机械臂的基础功能和软件使用方法，包括myBlockly使用说明和系统与固件更新。软件开发指南提供了基于不同开发环境的指导，如Python和ROS2，支持技术开发者进行应用扩展。通过展示成功的应用案例和提供配套资源，为您提供实践参考和必要的支持材料，以便更深入地了解和使用产品。 支持与服务 支持与服务板块将为您提供全面的故障排除指南和购买后的服务信息，如保修和服务条款，帮助您在遇到问题时能够快速解决，并确保您了解购买后的权利和义务。此外，'关于我们'部分加强了用户对myCobot 系列产品设计及制造商的了解，旨在建立信任和品牌忠诚。 致谢 我们非常感谢您花时间阅读myCobot Pro 450 用户手册。我们希望本文档能够帮助您更好地了解并有效使用这款机器人，从而激发您的创造力。如果您有任何疑问或需要进一步帮助，请随时联系我们的客户支持团队。我们期待看到您使用 myCobot Pro 450完成创新项目，并欢迎您加入我们快速发展的开发者社区。 文档目录 Introduction 产品信息 1 产品介绍 2 产品特性 基础设施 3 用户须知 3.1 安全须知 3.2 运输和储存 3.3 维护和保养 3.4 常见问题解决 3.4.1 软件 3.4.2 硬件 3.4.3 其他 4 首次安装 4.1 产品标准清单 4.2 产品开箱指南 4.3 开机检测指南 功能与应用 5 基础功能 5.1 myBlockly 5.1.1 首次使用 mblockly 5.1.2 下载和卸载 5.1.3 接口描述 5.1.4 常见问题解答 5.2 机器人控制端口 5.3 系统使用 5.4 固件更新 6 软件开发指南 6.1 基于python 开发使用 6.1.1 环境搭建 6.1.2 api说明 6.1.3 关节控制 6.1.4 坐标控制 6.1.5 IO控制 6.1.6 夹爪控制 6.1.7 演示代码与视频 6.2 基于ROS2 开发使用 6.2.1 环境搭建 6.2.2 ROS2 基础知识 6.2.3 Rviz2介绍以及使用 6.2.4 Moveit2介绍以及使用 6.3 基于C++ 开发使用 6.3.1 环境搭建 6.3.2 编译运行 6.3.3 关节控制 6.3.4 坐标控制 6.3.5 IO控制 6.3.6 夹爪控制 6.3.7 api说明 6.3.8 使用案例 6.4 基于通信协议包开发 7 成功案例 7.1 机器人复合案例 7.2 3D视觉无序分拣 7.3 Lerobot ACT模仿学习 7.4 DeepSeek 语音控制 8 配套资源 8.1 产品资料 8.2 产品图纸 8.3 软件资料及源码 8.4 系统资料 8.5 宣传资料 支持与服务 9 关于我们 10 周边配件 10.1 力控夹爪 10.2 气动夹爪 10.3 自适应夹爪 10.4 手机支架 10.5 3D相机 10.6 独头吸泵 10.7 模块化吸盘 10.8 摄像头法兰 10.9 笔夹 致谢 11 致谢 下一章 → "},"1-ProductInformation/1-ProductIntroduction/1-ProductIntroduction.html":{"url":"1-ProductInformation/1-ProductIntroduction/1-ProductIntroduction.html","title":"1 产品介绍","keywords":"","body":"产品简介 1. 产品概述 myCobot Pro 450 全谐波协作机械臂入门首选 1.1 产品简介 myCobot Pro 450 是一款面向教育教学、科学实验、商业展示及轻工业自动化场景的小型化全谐波6轴协作机械臂。其核心功能丰富多样，具备精准的操作能力，工作半径可达 450 毫米，有效负载为 1 公斤，重复定位精度高达 ±0.1 毫米，能够出色完成各类轻负载且对精度要求高的任务。 在控制方面，它依托内置工业级核心控制板和自研控制系统，可便捷连接电脑、平板、手机等终端设备。预装的拖拽式编程软件与快速调试接口，让零基础用户也能轻松上手操作。同时，工具端的集成化接口设计消除了连接夹爪时的线缆困扰，底座新增的 CAN、RS485 接口为二次开发和功能拓展提供了广阔空间。其核心价值在于为不同领域的用户提供了一款高性能、易操作且扩展性强的协作机械臂解决方案，助力提升工作效率与创新能力。 1.2 设计理念 设计 myCobot Pro 450 的初衷，是为了满足日益增长的多样化应用需求。在教育领域，期望帮助学生更直观地接触和学习机器人技术，培养实践操作能力和创新思维；在科研场景中，为科研人员提供稳定、精准的实验操作工具，加速科研进程；在商业展示方面，打造具有吸引力的互动体验装置，提升展示效果。 1.3 设计目标 设计目标 描述 应用场景及特点 满足多样化高精度操作需求 450mm 工作半径覆盖标准台面，1kg 负载支持多末端执行器，±0.1mm 重复定位精度控偏差。 - 教育科研场景：可用于实验数据采集，其高精度能保证数据的准确性和可靠性；- 轻工业自动化场景：可进行精细物料处理，如电子元件的安装、分拣等工作，提升生产效率与产品质量 降低使用门槛与技术壁垒 多终端连接，预装拖拽编程软件，4 种工业级连接及多标准协议，零基础易上手。 - 教育教学场景：学生可轻松通过终端设备连接并操作机械臂，借助编程软件学习机器人编程知识，提升实践能力；- 商业场景：企业人员无需复杂的技术培训，就能利用该机械臂进行方案预研与验证，降低技术使用成本。 促进创新应用与拓展 接入多模态及具身智能大模型，配视觉与 语音控制，提供 4 套开箱方案，接口支持二次开发。 - 科研场景：研究人员能基于大模型和具身智能能力，开展机器人智能决策、自主运动策略等前沿课题研究；- 商业展示场景：利用多模态交互和独特应用方案，打造新颖的互动展示体验，吸引客户关注，提升品牌形象。 1.4 产品特点 产品特点 特点描述 超长待机 实验室验证寿命 > 10,000小时 (注：实际工况可能影响)，持久稳定，教学科研更省心。 商用级安全关节 集成谐波减速器 + 伺服电机 + 关节刹车 + 控制器，断电瞬间自锁，安全可靠，人机协作更安心。 一体精工，坚固可靠 全金属一体化高温压铸机身，结构强度统一，内置控制器，告别外置电箱与复杂线缆，简洁高效。 万“物”互联 支持 4 种工业级连接 (WLAN/EtherNet/RS485/CAN)，协议丰富 (Socket-TCP/Modbus/CANOpen)，轻松融入现有系统，工业4.0接入无忧。 精准高效，轻量之选 工作半径： 450mm, 负载： 1kg, 精度： ±0.1mm, 自重： 零门槛操控 myCobot Pro 跨平台控制中心 - 浏览器直连 (输入IP即可)，无需安装！集成：Blockly图形化编程 & 拖动示教：小白秒变编程高手。快捷移动控制 & 状态监控。支持 Modbus/VNC/Socket 等多连接配置。一站式固件升级与管理。 开源生态，无限可能 提供完整 URDF 模型，开放关节电机底层接口 (位置/速度/加速度/电流等状态可查)，助力运动学/动力学仿真建模 (ROS2, Isaac Sim, MuJoCo)。开放90+ 标准控制接口库 (Python & C++)，覆盖状态查询、关节/笛卡尔空间运动控制，开发者友好，高效赋能二次开发。 大模型“灵魂”注入 支持接入多模态大模型 (如 DeepSeek、ChatGPT)，实现语音指令 + 视觉识别的智能抓取，交互更直观。支持接入具身智能大模型 (如 Lerobot)，赋能机器人自主运动策略学习与部署，探索智能体前沿。 炫酷应用套件 提供 3 套开箱即用方案 - 3D视觉无序分拣、高精度写字绘画、移动复合机器人，快速搭建教学/实验/展示场景。 2. 产品应用 2.1 用户群体 教育工作者与学员 适用于高等院校、职业院校的机器人工程、人工智能、自动化控制、机电一体化等专业的课程教学、实验实训与技能竞赛，为师生提供从理论到实践的理想平台。 科研人员与开发者 面向科研院所、企业研发部门及广大机器人爱好者，提供稳定的硬件平台和深度的软件开放接口，助力算法验证、原型开发与前沿技术探索。 商业与工业用户 适用于商业展厅的产品互动展示、轻工业环境中的小批量精密生产、样品分选、质量检测等任务，提供高效、可靠的自动化解决方案。 2.2 应用场景 用户群体 核心应用场景（开箱即用） 扩展应用场景 (无限可能) 教育领域的教师和学生 - 机器人基础教学：机械结构、运动学、轨迹规划原理实验。- 拖动示教编程：手工工艺模仿、动作录制与复现。- 图形化编程入门：使用Blockly进行逻辑思维与编程基础训练。 - 高级算法开发：基于Python/C++/ROS 2进行机器视觉、路径规划、力控等算法研究。- 人工智能集成：开发语音控制、智能视觉识别抓取等AI综合应用项目。 创客和技术开发者 - 快速原型验证 (PoC)：验证自动化流程或抓取方案的可行性。- 高精度仿真：提供精准URDF模型，无缝对接Isaac Sim, MuJoCo等仿真环境。 - 前沿领域探索：作为实体平台，用于具身智能、强化学习、人机协作等前沿课题研究。- 复合系统开发：与AGV/AMR移动底盘集成，构建移动操作(Mobile Manipulation)机器人。 商业演示和轻工业 - 自动化商业展示：实现7x24小时自动化产品展示、与观众进行趣味交互。- 精密作业：高精度写字画画、电路板点位检测、样品分选。- 3D视觉分拣：结合3D相机实现杂乱环境下的无序工件抓取与分拣。 - 产线自动化集成：通过Modbus/TCP/IP等协议与PLC通信，集成入小型产线执行上下料、精密装配等任务。- 实验室自动化：替代人工执行重复性实验操作，如样品移液、培养皿搬运。 3. 支持的扩展开发 mycobot 系列机械臂在教育和科研领域中极具价值，特别是在 Python 和 ROS（Robot Operating System)这两个广泛使用的开发环境中。这些环境提供了强大的支持，使得 mycobot 系列产品能够广泛应用于机器学习、人工智能研究、复杂运动控制以及视觉处理任务中。同时搭配自适应夹爪、摄像头法兰、吸泵等数十种配件，可以尽情发挥myCobot的创意想法。 Python 机器人支持Python，具备完善的Python API库。 可通过Python控制机器人的关节角度、坐标、夹持器等。 ROS 支持 ROS2 版本，提供 RVIZ2 仿真环境支持。允许用户实时显示机械臂和采集机械臂的状态信息，使得myCobot Pro 450适合 ROS 初学者和教育用途。 硬件接口 包括 IO、USB 等，方便连接各种传感器和执行器。 软件库 提供丰富的开源库和 API 来简化开发过程。 系统兼容性 兼容 Windows、Linux、MacOS，适应多种开发环境。 C++ 使用c++语言，您可以通过我们公司开发的c++动态库，进行自由开发（坐标控制、角度控制、io控制、夹爪控制等），控制我们公司已经研发出来的部分机器人。 myBlockly 既是图形化编程软件又是可视化工具。 用户可以拖拽模块创建程序，这个过程非常类似于搭积木，方便快捷易上手。 4. 购买地址 如果您有兴趣购买该设备，请点击下面的链接：淘宝：https://shop504055678.taobao.comShopify：https://shop.elephantrobotics.com/速卖通：https://elephantrobotics.aliexpress.com/store/1101941423 ← 上一章 | 下一章 → "},"1-ProductInformation/2-ProductFeature/2-ProductFeature.html":{"url":"1-ProductInformation/2-ProductFeature/2-ProductFeature.html","title":"2 产品特性","keywords":"","body":"机器人参数说明 第一章中，我们探讨了产品的卖点及其设计理念，为您提供了对产品高层次理解的全景视角。现在，让我们进入第二章——机器人参数说明。这一章节将是您理解产品技术细节的关键。详细了解这些技术参数，不仅可以帮助您充分认识到我们产品的先进性和实用性，而且还能够确保您能够更有效地利用这些技术来满足您的具体需求。 1. 机器人规格参数 指标 参数 名称 全谐波协作机械臂 型号 myCobot Pro 450 自由度 6 有效负载 1 Kg 工作半径 450mm 重复定位精度 ±0.1mm 重量 电源输入 24V，9.2A 工作温度 0-45℃ 通信 TCP/IP-SocketMODBUSEthernet IP 2. 控制核心参数 2.1 主控制器规格表 2.2 辅助控制器规格表 3. 结构尺寸参数 ！本章以毫米为距离单位，以度为角度单位。 3.1 产品尺寸和工作空间 3.2 关节运动范围 关节 范围 J1 -360 ~ +360 J2 -135 ~ +135 J3 -135 ~ +135 J4 -150 ~ +150 J5 -360 ~ +360 J6 -360 ~ +360 3.3 孔位安装 机器人底座安装法兰，底座同时兼容乐高科技件安装方式和M4螺丝安装方式。 机器人末端安装法兰，机械臂末端同时兼容乐高科技件孔与螺丝螺纹孔。 4. 电气特性参数 5. 笛卡尔坐标参数 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/":{"url":"2-BasicSettings/3-UserNotes/","title":"3 用户须知","keywords":"","body":"用户须知 本节对本产品的每个用户都至关重要，必须仔细阅读。它包括有关产品使用、运输、储存和维护的基本信息，以确保运行期间的安全和效率。此外，它还概述了因不遵守这些准则而导致产品故障或损坏的责任。用户须知》分为几个小节，每个小节针对不同的主题提供详细的指导： 章节摘要 3.1-安全须知包括责任、安全警告标志、一般安全规则、个人安全和应急措施。 3.2-运输和储存 说明包装、运输和长期储存要求以及责任。 3.3-维护和保养提供日常维护指导，以延长产品使用寿命。 3.4-常见问题解决提供快速解决常见问题的导航指南。 通过全面阅读本节内容，用户可以更好地了解如何安全有效地使用产品，最大限度地提高性能和使用寿命。 如果您已经阅读了本章的所有内容，请继续阅读下一章。 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.1-SafetyInstruction.html":{"url":"2-BasicSettings/3-UserNotes/3.1-SafetyInstruction.html","title":"3.1 安全须知","keywords":"","body":"安全须知 1. 简介 本章详细介绍了有关对大象机器人执行安装、维护和维修工作的人员的常规安全信息。请在搬运、安装和使用前，先充分阅读和理解本章节的内容与注意事项。 2. 危险识别 协作机器人的安全性建立在正确配置和使用机器人的前提上。并且，即使遵守所有的安全指示，操作者所造成的伤害或损伤依然有可能发生。因此，了解机器人使用的安全隐患是非常重要的，有利于防患于未然。 以下表 1-1~3 是使用机器人的情境下可能存在的常见安全隐患 ∶ 表 1-1 危险级安全隐患 1 机器人搬运过程中的错误操作导致的人身伤害或者机器人损伤。 2 未按要求固定机器人，例如螺钉缺少或螺钉未上紧、底座锁付能力不足以稳定支撑机器人进行高速运动等造成机器人倾倒，导致人身伤害或者机器人损伤。 3 未进行机器人的正确安全功能配置，或者少安装了安全防护工具等，造成机器人安全功能未能发挥作用，从而引起危险。 表 1-2 警告级安全隐患 1 调试程序时请勿在机器人运动范围内逗留，不合适的安全配置可能无法避免可能造成人身伤害的碰撞。 2 机器人与其他设备连接可能引发新的危险，需要重新进行全面的风险评估。 3 因工作环境中的其他设备或者机器人末端执行器等尖锐表面造成刮伤、刺伤。 4 机器人是精密机械，踩踏可能造成机器人损伤。 5 夹持不到位或关闭机器人电源、气源前（未确定末端执行器是否牢固夹持物因为失去动力而掉下）未将夹持的物体取下，可能会引起危险，例如末端执行器损坏、人被砸伤等。 6 机器人存在意外移动的风险，在任何情况下，切勿站在机器人任何轴的下方！ 7 机器人是精密机械，搬运时不能平稳放置可能会引起振动，可能会引起机器人内部部件的损伤。 8 机器人与普通机械设备相比自由度更多、运动范围更大，不满足运动范围可能会引起意外的碰撞。 表 1-3 有可能导致触电的安全隐患 1 使用非原装电缆可能会引发未知危险。 2 用电设备接触液体可能导致漏电危险。 3 电气连接错误时可能存在触电隐患。 4 请务必在关闭控制器与相关装置电源并拔出电源插头之后进行更换作业。如果在通电的状态下进行作业，则可能会导致触电或故障。 3. 安全注意事项 使用机械臂时应遵循如下安全规则： 机械臂属于带电设备，非专业人士不得随意更改线路，否则容易给设备或者人身带来伤害。 操作机械臂时，应当严格遵守当地的法规和规范，手册中所描述的安全注意事项及描述的“危险”、 “警告”和“注意”事项仅作为当地安全规范的补充。 请在规定环境范围内使用机械臂，超出机械臂规格及负载条件会缩短产品的使用寿命甚至损坏设备。 负责安装、操作、维护 myCobot 机械臂的人员必须先经过严格培训，了解各种安全注意事项，掌握 正确的操作和维护方法之后，才能操作和维护机器人。 请勿长时间在潮湿环境下使用本产品。本产品为精密电子元器件，长时间潮湿环境工作会损坏设备。 请勿在高温环境下使用本设备。本设备外表面是由光敏树脂为原料制造而成，较高的温度会损坏设备的外壳，导致设备故障。 高腐蚀性清洁不适用于机械臂的清洁，阳极氧化的部件不适用于浸没清洁。 请勿在未安装底座时使用本产品以避免损伤本设备或意外发生，本产品应在固定且周围无障碍物的环境下使用。 请勿使用其他电源适配器供电。如因使用不符合标准的适配器导致设备损坏将不在售后服务内。 请勿拆解，拆开，拧开机械臂的螺丝或外壳等。如若拆开，则无法提供保修服务。 未经专业培训人员不得擅自维修故障产品，不得擅自拆卸机械臂，若产品出现故障，请及时联系 myCobot 技术支持工程师。 若该产品报废，请遵守相关法律正确处理工业废料，保护环境。 儿童使用过程中必须有人在旁边监控，运行完成时及时关闭设备。 机器人在运动过程中，请勿将手伸入机械臂运动范围，当心碰伤。 严禁更改或者去除和修改机械臂以及相关设备的铭牌、说明、图标和标记。 搬运、安装过程中请务必小心，应按包装箱上的提示注意轻放、按箭头方向正确放置机器人，否则容易损坏机器。 请勿擅自烧录其他产品驱动、或使用非官方推荐方式烧录固件。如因用户个人烧录其他固件导致设备损坏将不在售后服务内。 如果您对本手册的内容有任何疑问或建议，请登录大象机器人官方网站提交相关信息： https://www.elephantrobotics.com 请勿将机械臂用于以下用途： 医疗与生命攸关的应用中。 可能会引起爆炸的环境中。 未经过风险评估直接使用。 安全功能等级不够的使用。 不符合的机器人性能参数的使用。 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.2-TransportandStorage.html":{"url":"2-BasicSettings/3-UserNotes/3.2-TransportandStorage.html","title":"3.2 运输和储存","keywords":"","body":"运输和储存 装箱打包   在机器人产品进行装箱打包时，请确保使用专为其设计的包装材料和箱体，这些材料能够提供足够的缓冲和支撑，防止运输过程中的撞击和震动。务必检查所有零部件是否已正确固定，避免松动导致损坏。对于易碎或敏感部件，应额外使用防震保护材料进行加固。最后，确保包装箱外标有清晰的搬运和警告标签，指示正确的搬运方式和存放方向。 物流运输   在运输过程中，应使用原始包装运输机器人产品。在运输过程中，应确保机器人产品在包装箱内作为一个整体是稳定的，并通过适当的措施加以保护。在运输和长期储存过程中，环境温度应保持在-20 至+55°C 的范围内，湿度 ≤95%且无凝露。   由于机器人是精密机械，从包装中取出机器人产品时，应小心处理。在运输过程中，如果不能稳定放置，可能会引起振动并损坏机器人的内部部件。 设备储藏   运输完成后，原包装应妥善存放在干燥的地方，环境温度应保持在-20 至+55°C 的范围内，湿度 ≤95%且无凝露，以备将来重新包装和运输需要。不要将其他物品堆放到机械臂的原包装箱上，防止包装箱变形和机械臂损坏。 | ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.3-MaintenanceandCare.html":{"url":"2-BasicSettings/3-UserNotes/3.3-MaintenanceandCare.html","title":"3.3 维护和保养","keywords":"","body":"维护和保养 作为一家机器人制造商，我们重视确保客户能够正确、安全地维护和升级他们的机器人设备。为此，我们提供以下详细的维护和保养指南，包括常见维护项目及维修或升级硬件的部分，请您认真阅读: 1. 常见维护项目及推荐周期 维护项目 描述 推荐周期 视觉检查 检查机器人有无明显的损坏、异物堆积或磨损。 日常 结构清洁 使用干净、干燥的布料清洁机器人结构部件。避免水分和侵蚀性清洁剂。 日常 紧固件检查 检查并紧固所有螺栓和连接件。 日常 润滑 对关节和移动部件进行润滑，使用制造商推荐的润滑油。 每 3 个月 电缆和接线检查 检查电缆和接线，确保无损坏或磨损。 每月 电气连接检查 确保所有电气连接牢固，无腐蚀或损坏。 每月 软件更新 检查并更新控制软件和应用程序。 每次有更新时 软件数据备份 定期备份关键软件配置和数据。 每季度 固件更新 定期检查并更新固件，以获取最新的功能和安全补丁。 每次有更新时 传感器和器件检查 检查传感器和其他关键器件，确保正常工作。 每月 紧急停止功能测试 定期测试紧急停止功能，确保其可靠性。 每月 环境条件监控 监控工作环境的温度、湿度、灰尘等，确保符合机器人的操作规格。 持续监控 安全配置复查 定期检查和确认机器人的安全配置，如限速和工作范围设定。 每月 预防性维护计划执行 按制造商的维护计划执行定期检查和维护。 按制造商指南 2. 独立更改机器人硬件的指南 我们理解客户可能会有自行升级或维修机器人硬件的需求。在进行任何升级操作之前，请务必详细阅读产品的相关参数，并与我们的官方人员确认是否被允许进行此类操作。未经官方允许的操作可能导致产品故障，且不在保修范围内。 物料要求 官方制造或推荐的物料：所有维修和升级所需的配件和组件必须是由我们官方制造或明确推荐的。这包括但不限于电子组件、传感器、电机、连接件和任何其他可更换部件。 物料获取：客户可通过我们的官方渠道购买所需的维修和升级物料。这确保了配件的质量和兼容性。 维修或升级流程 客户自行维修：客户应负责完成维修工作。我们将提供详细的维修指导和手册，以指导客户完成维修步骤。 遵循官方指导：维修操作应严格遵循我们提供的官方指导。任何偏离官方指导的操作都可能导致设备损坏。 责任和保修政策 责任划分：制造商：提供维修和升级的官方指导、官方制造或推荐的物料，并处理由制造缺陷导致的问题。 客户：负责按照官方指导完成维修，使用官方配件。 保修政策： 保修有效：只有当维修操作完全遵循我们的指导，且使用官方配件时，保修才有效。 保修无效：若客户未按官方指导操作，或使用非官方配件进行维修或升级，导致的任何损坏都将不在保修范围内。 注意事项 安全第一：在进行任何维修或升级操作前，请确保遵循所有安全指南，包括断电和使用适当的防护装备。 技术支持：如在维修过程中遇到问题，建议停止操作并联系我们的技术支持团队寻求帮助。 我们强烈建议客户严格遵循这些指南，以确保机器人设备的安全、有效运行。不当的维修操作可能导致设备损坏并影响保修状态。如需进一步的指导或支持，请及时联系我们的专业技术团队。 ← 上一章| 下一章 → "},"2-BasicSettings/3-UserNotes/3.4-FAQs.html":{"url":"2-BasicSettings/3-UserNotes/3.4-FAQs.html","title":"3.4 常见问题解决","keywords":"","body":"常见问题 本部分列出了一些常见问题，涵盖硬件、软件这几个方面。 1 软件问题 2 硬件问题 3 其他 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.4.1-software.html":{"url":"2-BasicSettings/3-UserNotes/3.4.1-software.html","title":"3.4.1 软件","keywords":"","body":"软件问题 1. mystudio相关 Q：关于mystudio下载固件的细节 一般情况下，出厂已经内置固件，除非在机器异常情况，否则无需重新刷固件 下载固件的过程中需要连接网络 选择对应机型的固件，不要选错其他机型 2. Python相关 Q：运行提示缺少库文件Q:遇到报错信息：ModuleNotFoundError: No module named “pymycobot”，如何处理？ A1：没有安装pymycobot，对应的解决方法是重新安装pymycobot，指令是pip3 install pymycobot --upgrade --user A2: 在安装python的过程中没有勾选下图的“Add Pythonxx to PATH”，需要卸载python后重新安装python，并将此选项勾选。 A3: 建议使用3.9版本的pyhton，pyhton12会出现不兼容的情况。 Q：send_coords(coords, speed, mode)中的mode有没有通俗一点的解释？ A：线性1代表机械臂末端以直线的方式抵达目标位置，如果因为限位、结构等原因无法走直线，那指令就不会完全执行； 线性0表示末端以任意姿态抵达目标位置，由于没有直线的限制，不容易出现指令不执行的现象。 Q：set_fresh_mode(mode) 的插补和刷新模式有什么区别？ A: 插补0是指起始点和终止点之间规划了很多密集的点位，从而达到控制中间段轨迹的效果。 如何达到程序并行的效果：非插补1就是没有中间段的规划，控制不了轨迹，但是运动会相对平滑。 Q：在仅改变Z轴的情况下，轨迹不是直上直下的，但是最后落点是只改了Z轴，这个正常吗，如何确保中间轨迹也是直线？ 开插补走直线就能确保轨迹了set_fresh_mode(0) # 开插补 send_coords(coords, speed, mode=1) # 走直线 注意一定要开插补之后，在send_coords设置的智能规划路线才有用。 插补是指起始点和终止点之间规划了很多密集的点位，从而达到控制中间段轨迹的效果。 非插补就是没有中间段的规划，控制不了轨迹。 Q:识别到的目标位置，末端无法到达，怎么判断这个坐标是否可以到达然后处理？ A：solve inv kinematics(target coords, current_angles)用这个接口看是否有解就可以了。 solve_inv_kinematics(target_coords, current_angles) 功能 : 将坐标转为角度。 参数： target_coords: list 所有坐标的浮点列表。 current_angles: list 所有角度的浮点列表，机械臂当前角度 返回值: list 所有角度的浮点列表。 3. ROS相关 Q：有没有配置好环境的虚拟机镜像？ A：我们有提供一个配置好ROS2环境且内置ROS源码的虚拟机环境，用户可以通过下面这个链接下载，并将虚拟机文件导入VirtualBox，省去自己配置环境的麻烦，当测试ROS案例时建议使用我们已经配置好的虚拟机环境进行验证，避免由于环境配置的原因导致的一些案例运行报错 请参考虚拟机文件导入虚拟机软件的操作步骤视频：https://drive.google.com/file/d/1KeYk_CUgDE46rVn7zbd0EhraIbgt3qZt/view?usp=sharing ROS2虚拟机文件下载 虚拟机软件VirtualBox下载 Q：导入ROS2虚拟机文件的时候报错怎么处理？ A: 这是因为虚拟机软件Oracle VM VirtualBox版本过低导致的，需更新虚拟机软件版本。 Q：如何重新下载ROS源码包？ A：使用指令拉取： git clone https://github.com/elephantrobotics/mycobot_ros2.git 或着手动下载，下载方法进入到ROS源码包地址按照下图进行操作，源码包地址：https://github.com/elephantrobotics/mycobot_ros2 Q: 运行ROS moveit案例发现报错ImprotError：No module named yaml咋办？ A：在这个脚本开头第一行，把Python解释器改为python3 Q：运行虚拟机找不到串口怎么处理？ A:使用USB线将M5机械臂与PC连接，打开虚拟机设置→USB设备→添加USB设备→选择串口号QinHeng xxxxx，这个就是机器的串口设备。 如果没有这个设备号，可以通过重新拔插设备获取对应的USB设备号，拔插有串口变化的即对应的机器串口设备号 Q：终端切换到~/catkin_ws/src中使用git安装并更新mycobot_ros时，出现目标路径\"mycobot_ros2\"已经存在，原因是什么？ A：说明~/catkin_ws/src中已经存在一个mycobot_ros2程序包，需要提前将其删掉，再重新执行git操作即可。 Q：rosrun运行时，终端报错显示counld not open port /dev/ttyUSB0：Permission: '/dev/ttyUSB0'，是为什么？ A：串口权限不够，终端输入sudo chmod 777 /dev/ttyUSB0赋予权限。 Q：rosrun运行时，终端提示Unable to register with master node [http://localhost:11311]: master may not be running yet. Will keep trying的原因是？ A：运行ros程序前，需开启ros节点，终端输入roscore。 Q：rosrun运行时，终端报错显示counld not open port /dev/ttyUSB0：No such file or directory: '/dev/ttyUSB1'，是为什么？ A：串口有误。需确认当前机械臂的实际串口。可通过ls /dev/tty*查看。 Q：刚克隆下来的mycobot_ros2程序包，然后直接运行rosrun程序，出现package 'mycobot_pro_450' not found的错误或者找不到该文件之类的错误？ A：刚克隆下来的mycobot_ros2需要构建代码进行ros环境编译。终端输入 cd ~/catkin_ws/ catkin_make source devel/setup.bash Q：编译完成后，新开终端运行launch指令时，为什么会出现下面的错误？ A1：系统没有添加ros环境变量，所以每次开启新终端都要source： cd ~/catkin_ws/ source devel/setup.bash A2：系统添加ros环境变量，每次开启新终端后无需执行source： # noetic为Ubuntu20.04系统 echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc A3：可能是指令中的文件名与实际中mycobot_ros2包里面的文件名不一致，请仔细检查指令是否有误。 5 C++相关 Q：找不到各种dll文件怎么处理？ A1：如果myCobotCpp.dll缺失，将之前放到lib目录下的myCobotCpp.dl放到mycobotcppexample.exe所在目录下. A2: 如果报缺少QT5Core.dll，打开qt command (菜单栏搜索QT) ，选择msvc2017 64-bit，执行windeployqt--release myCobotCppExample.exe所在目录(如: windeployqt --release D:lvs2019myCobotCpploutlbuildlx64-Releaselbin) 此处执行命令后如果报找不到vs安装路径，请检查vs环境变量的设置. 以上步骤执行后，如果报缺少qt5serialport.dll文件，将gt安装目录处的此文件(路径如: D:lgt5.12.1015.12.10msvc2017 64bin)，拷贝到myCobotCppExample.exe所在目录 Q：生成myCobotCppExample.exe可执行文件，这个有可能是什么问题？ 选择下图中的启动 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.4.2-hardware.html":{"url":"2-BasicSettings/3-UserNotes/3.4.2-hardware.html","title":"3.4.2 硬件","keywords":"","body":"硬件问题 Q：机械臂上电锁不住如何解决？ 检查是否有接上原装电源适配器，或者适配器是否接触良好，可以尝试重新拔插电源适配器 检查关节在断电状态，能否正常转动，会不会出现阻力过大或者过小的情况，初步判断是否内部结构物理断裂，无物理断裂则接着往下检查. Q：按下急停后，释放急停锁不住了，怎么让机械臂再次锁住？ 需要给机器重新上电，例如以myblockly给机器上电 Q: 关节抖动、关节角度偏差过大或关节无力下坠如何优化？ 参考机器人参数介绍章节，检查实际负载是否在机械臂有效负载范围内，负载过大会导致关节抖动，可适当减轻实际关节的负载 将运动模式更改成刷新模式，这样会机械臂的运行轨迹会相对平滑，具体的API，请参考 set_fresh_mode(1) 查看以下链接内容调整pid：https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing 查看gitbook第5章节，对机械臂进行零位校准，也可参考下面链接的校准步骤：https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing 使用时间较长的机器(3个月以上)可能会出现关节老化产生关节间隙的情况，可按照以下视频，手动掰动关节，查看是否存在关节虚位：https://drive.google.com/file/d/1tXDUALmfw1z0u6lM9uH5hOHivjbRoWxW/view?usp=sharing 如果存在关节老化虚位问题，这种抖动则属于机器自然老化无法避免。 Q: 什么是关节零位点？ 以下图为例，关节与关节外壳边缘之前会设计有一个拱形槽，这个就是关节零位点 一般校准后零点姿态如下： Q：有没有零位校准的方法？ 请参考gitbook第5章节或者下面这个链接： https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q: myCobot的关节的限位？ A: 一轴和五轴有限位，一轴顺时针约165°左右，逆时针165°左右。五轴可时针、逆时针可转动约165° 注意：转动机械臂时应小角度、轻轻地转动，到达限位后就不可用力继续转动。 Q：不同版本的机械臂支持什么通信接口？ A：基于微处理器的机械臂支持socket通信TCP；基于微控制器的机械臂可以USB转串口通信。 ← 上一章 | 下一章 → "},"2-BasicSettings/3-UserNotes/3.4.3-other.html":{"url":"2-BasicSettings/3-UserNotes/3.4.3-other.html","title":"3.4.3 其他","keywords":"","body":"其他 Q：机器异常时如何重置成出厂设置？ 恢复成出厂设置主要在于镜像、pid及零位的重置。以下为重置方案： 关于重置镜像：重置镜像时将清空原系统中的所有内容，如有重要文件，请注意提前保存，重置镜像的方法参考gitbook系统使用章节 关于重置pid：一般情况下当机器出现关节严重抖动，关节动作速度异常，关节蜷缩在一起的情况下可重置pid，重置方法参考：https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing 关于重置零位：一般情况下当机器出现零位不正确，关节限位异常可重新零位校准，重置方法参考：https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q：urdf文件下载路径在哪里？ A：请参考以下路径，所有mycobot机型的urdf都在此路径中：https://github.com/elephantrobotics/mycobot_ros/tree/noetic/mycobot_description/urdf Q：通过串口或socket通讯，经过机器人的控制器控制电机，指令传输延时多大？有通讯时序图吗？实时性如何？ 这边没有串口或socket通讯的延时测试数据，据我们这边开发使用反馈来看，实时性还是挺高的，不会出现很滞后的情况 Q：mycobot pro 450 机械臂基座标系是怎么样的？ Q：450的关节是串口总线的控制方式吗？ A:是的 Q: 关于坐标的理解有更多的解释吗？ A：控制坐标运动的API是send_coords([x,y,z,rx,ry,rz], speed) x、y、z 坐标： 控制了机械臂末端执行器在空间中的位置。改变这些坐标值将使机械臂移动到不同的空间位置，从而实现在三维空间中的定位。 rx、ry、rz 姿态角度： 控制了机械臂末端执行器的姿态或朝向。这些值通常以欧拉角的形式给出，描述了机械臂末端执行器相对于基坐标系的旋转，欧拉角顺序是zyx。改变这些值将使机械臂的末端执行器旋转到不同的角度或方向。 例如： 当你调整 +X 时，这表示在当前机械臂末端执行器的位置沿着当前末端执行器的 X 轴正方向移动一定的距离。这个动作会导致机械臂整体向某个方向移动。而当你调整 RX 时，这表示在当前机械臂末端执行器的姿态绕当前末端执行器的 X 轴旋转一定的角度。这个动作会导致机械臂整体发生旋转，末端执行器的方向会发生改变。 综合来看，+X 和 RX 的调整都会直接影响机械臂的运动状态，+X 控制位置的移动，而 RX 控制姿态的变化。 如果你更直观的看到变化，我们建议你使用myblockly的串口控制工具，单次调整一个参数，观察其在坐标系中的变化，请注意在观察rx、ry、rz 的时候如果想更加直观，请注意调整J1关节为0的时候调整x，ry，在关节为90时，调整y和rx 你可以参考下文的坐标系图示： Q: 关于DH参数的Offset 有更多的解释吗？Offset 是绕z旋转吗? A:DH参数描述了机械臂中相邻连杆之间的几何和运动关系。 在DH参数表中，Offset参数表示前一个连杆绕其z轴旋转对下一个连杆位置的影响，即连接两个连杆时的偏移量。对于机械臂中的Offset参数，一般表示上一个连杆绕自己的z轴旋转对下一个连杆位置的影响，而不是绕下一个连杆的z轴旋转。因此Offset不是绕z旋转，而是表示连接两个连杆时的位移。 Q: 450机械臂供电的电压区间范围是多少?瞬间电流有多大? A: 24V ，9.2A Q：请问如果对各轴舵机进行角度控制和反馈获取，最短的通讯周期可以做到多少？ A：这个需要根据速度决定间隔时间，最低响应时间是50ms Q：mycobot系列机器有碰撞检测吗？ A：带算法碰撞自干涉，已经集成到设置关节角度及坐标的API里了 Q:vnc拖拽卡顿怎么处理？ A: 如果是由于在vnc中拖动任何窗口造成的卡顿断连，可以按照下面的图片做一些配置，选项需要与下面的图片一致。成功设置后，将解决由于拖动窗口导致VNC断开的问题。 Q：更换450的第2个关节，发现4颗螺丝滑丝了怎么拆出来？ 关于关节的替换问题，那4个螺丝可以不必拆卸，请拆卸中间那颗大螺丝，然后将J2关节主体固定回去，然后用力将整个连轴件一并抽取出来即可，具体操作我为你录制了一个视频，你可以参考 Q:关节扭矩信息提供吗？ A:我们的机器都只提供整体关节的整体信息，不提供舵机、电机执行单元的内部扭矩、电压电流等参数信息，公开的是机械臂整体参数，如重复定位精度，电源电压等等 Q:下图中的查看看两坐标之间的关系怎么理解？ A: 指的是如果你想查看名为 \"turtle1\" 的坐标系相对于名为 \"turtle2\" 的坐标系的变换关系，可以使用这个指令，通俗一点来说就是当你运行这个命令时，它会告诉你一个物体（\"turtle1\"）相对于另一个物体（\"turtle2\"）的位置和方向信息。就像在地图上你可以知道一个城市相对于另一个城市的位置一样 Q:ROS2的环境被不小心改动，我可以直接删掉ROS，自己重新安装吗？ A:关于ROS重新安装这个问题，我们不建议用户自己重新安装，因为ROS环境的搭建会相对复杂，容易出错，如果需要重置ROS环镜，我们建议用户重新刷写系统镜像，具体方法请参考 基于ROS开发使用 Q：主机如何将文件传输到虚拟机中 A:按下图设置共享文件夹，可以将PC中的文件传输到虚拟机中 Q:同一个位置，机械臂到位以后，重复定位偏差过大怎么解决？ 新旧机器都可以通过调pid，尽可能减少偏差， 附：https://docs.qq.com/doc/DU0VhT2JNVUdNUEJS，https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing 但是旧版机器因为机械臂的2、4关节存在齿轮间隙，容易在重力的作用下产生关节偏差，最终影响末端精度，这四组关节值中2、4关节的受力不一致，所以精度也不太一样。目前建议通过程序进行调整，当机器到达点位后，可以在此点位再读一次点位，检查如果存在偏差，在此基础上再单关节调整具体偏差值，以达到到达指定点位的效果。 Q:API和串口指令直接控制关节有什么区别？ API 提供了简化、抽象化的接口，使开发更高效和容易，适合快速开发和集成。 串口指令 提供了直接、底层的控制，适合需要精细调整或开发自定义功能的场景，但通常开发和调试更复杂。 总得来说： 使用串口指令直接控制机械臂更加灵活，但也更加复杂，需要对通信协议有深入的了解；而使用API控制更加简单方便，但可能会受限于API提供的功能和性能。 Q:windows运行git指令报错 A:这是没有安装git导致的，需要先安装了git，再使用git指令 Q：MDI和JOG的区别是什么？ A: MDI（Manual Data Input）称为设定值直接给定运行方式。即上位控制器直接设 置目标位置、速度、加减速度后，轴自动移动到目标位置的定位方式。MDI 也是 实际应用中最常使用的一种定位功能。 JOG朝某一方向连续移动。 Q:各个机型pymycobot的最新支持版本是什么？ Q: DH表 如何区分标准和改进 sdh，std，标准 mdh，modify，改进 我们提供的是标准DH表，客户如果需要可以自己去转化，只是两种不同的描述方式。 Q:报错缺少opencv_camera,如何处理？ A:报错是显示缺少可执行权限，可能需要添加权限 改为用mycobot_280的，不需要用pi本身的了，因为m5那边占用有文件了，两边不能同时占有，否则会造成后面的编译失败。 Q:数据传输速度怎么看？ A：使用以下代码： import time from pymycobot.mycobot import MyCobot mc = MyCobot(\"COM8\",115200, debug = True) while 1: mc.get_angles() write表示下发的获取指令，read是返回的消息，左侧是时间。这里显示518write +611read，表示约100ms完成了一次get_angles的读取，频率是10hz。 Q:机械臂某一关节无法运动，如何处理？ A:可以通过python脚本，循环读角度，然后手动的去转动该关节，看角度有没有变化。 如果有返回值排查以下几点，蒋信息返回给技术支持人员。 1、get_servo_status查看J2舵机有没有欠压/过压等硬件问题 2、手动转动J2看有没有明显阻力，对比其它关节；单独给J2上使能focus_servo(2) 3、脚本，查看参数有没有问题。 Q：末端零位异常 A:长时间使用自适应夹爪夹取物品后会出现夹爪和末端零位异常的现象，需要将夹爪静止。 Q：什么的是正向运动学和逆向运动学？ A：正向运动学（Forward Kinematics）是指已知机器人各个关节的角度（或位移），求解机器人末端执行器（如机械臂的手爪）在笛卡尔空间中的位置和姿态。get_coords()的API中实现了，但是具体的算法不公开。 逆运动学（Inverse Kinematics）与正向运动学相反，它是指已知机器人末端执行器在笛卡尔空间中的位置和姿态，求解机器人各个关节的角度（或位移）write_coords()、send_coords() ← 上一章 | 下一章 → "},"2-BasicSettings/4-FirstInstallAndUse/":{"url":"2-BasicSettings/4-FirstInstallAndUse/","title":"4 首次安装","keywords":"","body":"首次安装和使用 感谢您选择我们的产品 在开始之前，我们衷心感谢您选择我们的产品。我们致力于为您提供卓越的用户体验。 首次使用和问题处理 本章将详细介绍产品收到后的初步使用方法，并提供解决问题的相关信息，确保您在使用过程中无后顾之忧。 跳转到各部分 4.1 产品标准清单 4.2 产品开箱指南 4.3 开机检测指南 ← 上一章 | 下一章 → "},"2-BasicSettings/4-FirstInstallAndUse/4.1-ProductStandardList.html":{"url":"2-BasicSettings/4-FirstInstallAndUse/4.1-ProductStandardList.html","title":"4.1 产品标准清单","keywords":"","body":"产品标准清单 1. 产品列表图片 感谢您选择大象机器人myCobot pro 450 机械臂，本章节内容旨在帮助您轻松上手大象机器人产品，享受产品带来的每一个精彩瞬间。 2. 产品标准清单对照表 序列号 产品 1 myCobot机械臂（型号myCobot pro 450） 2 myCobot机械臂-产品画册 3 myCobot机械臂-配套电源 4 USB-Type C 5 跳线 6 M4*35，杯头内六角，全螺纹，不锈钢螺丝 7 内六角扳手 注： 包装箱到位后，请确认机器人包装完好无损。如有损坏，请及时联系物流公司和您所在地区的供应商。开箱后，请根据物品清单检查箱内的实际物品。 ← 上一章 | 下一章 → "},"2-BasicSettings/4-FirstInstallAndUse/4.2-ProductUnboxingGuide.html":{"url":"2-BasicSettings/4-FirstInstallAndUse/4.2-ProductUnboxingGuide.html","title":"4.2 产品开箱指南","keywords":"","body":"产品开箱指南 1. 产品开箱图文引导 为什么需要按照步骤拆卸产品 在本节中，我们强烈建议按照指定步骤拆卸产品。这不仅有助于确保产品在运输过程中不受损害，还能将意外故障的风险降至最低。请仔细阅读以下图解指南，以确保您的产品在开箱过程中的安全。 1 检查包装箱是否损坏。如有损坏或配件缺失，请及时联系物流公司和您所在地区的供应商。 2 打开包装盒，取出产品宣传册、海绵包装盖、myCobot 机器人手臂、配套电源、平板底座和附件包。 3 确保每一步都完成后再进行下一步，以防止不必要的损坏或遗漏。 注: 取出产品后，请仔细检查每件物品的外观。请对照物品清单检查包装箱中的实际物品。 2. 产品开箱视频引导 ← 上一章 | 下一章 → "},"2-BasicSettings/4-FirstInstallAndUse/4.3-PowerOnDetectionGuide.html":{"url":"2-BasicSettings/4-FirstInstallAndUse/4.3-PowerOnDetectionGuide.html","title":"4.3 开机检测指南","keywords":"","body":"开机检测指南 1. 首次使用自查-机器关节功能验 注意: 在机械臂启动时，请注意不要让机械臂处于蜷缩或者关节之间触碰的姿态，建议启动时,机械臂姿态应如下图1所示，图2、图3均为错误启动姿态： 图1 (正确姿态) 图2（错误姿态） 图3（错误姿态） 2. 结构安装和固定 在 机械臂 的运动过程中，如果不将 myCobot 的底面与桌面或其他底面相连，仍然会造成 myCobot 的 摇晃或倾覆。 安装机械臂 安装M6X16螺丝将底板固定在台面上 安装完成的效果图 将机械臂底座放置到固定好的底板上 拆卸机械臂底座上的罩壳固定螺丝 打开机械臂底座的罩壳，并使用M6X16的螺丝将机械臂底座和底板固定 安装完成后，将机械臂底座的罩壳扣上 --> 安装机械臂底座的罩壳固定螺丝 安装机械臂底座的罩壳固定螺丝 注意：myCobot 底座的螺丝孔位连接 需要将机器人固定在牢固机座上才可以正常使用。机座重量要求：固定式机座，或移动式机座。 请确定固定底座上有对应螺纹孔位，再进行安装。 正式进行安装前，请确认： 待安装环境符合以上《工作环境与条件》表格的要求。 安装位置不小于机器人工作范围，且留有足够大的安装、使用、维护、维修的空间。 将机座放置到合适位置。 安装相关工具已准备好，如螺丝、扳手等。 确认以上内容后，请将机器人搬运至机座安装台面上，调整机器人位置，将机器人基座固定孔位与机座安装台面上的孔位对准。对准孔位后，将螺丝对准孔位，拧紧即可。 注意：在机座安装台面上调整机器人位置时，请尽量避免在机座安装台面上直接推拉机器人，以免产生划痕。人工移动机器人时请尽量避免对机器人本体脆弱部分施加外力，以免造成机器人不必要的损伤。 3. 关节控制方法步骤 1. 进行硬件连接 2. 进行软件环境安装与配置 3. 选择正确的通讯方式 4. USB通讯示例 4.1 机械臂关节运动myblockly源码 当你看到机械臂的关节1在0-90度循环运动3次效果，说明机械臂关节1响应正常，可尝试更改关节ID测试其他关节及循序渐进学习使用gitbook的其他案例或者利用机械臂做各种有趣的事情！ 指的一提的是，如果你目前对myblockly的代码块开发方式并不熟悉，还有一个相对快捷的关节验证方式是：使用myblockly快速移动工具进行简单的关节运动控制，具体用法请参考：myblockly快速移动工具使用 4.2 机械臂关节运动关节python源码 #运动效果为机械臂围绕零位姿态，1-6关节逐一运动±20度 import time from pymycobot.mycobot import MyCobot if __name__ == \"__main__\": cobot = MyCobot('com22',115200)#根据机型选择对应的端口号及波特率 cobot.set_fresh_mode(1) cobot.send_angles([0, 0, 0, 0, 0, 0], 20) time.sleep(2) print(\"start\") for i in range(1,7): cobot.send_angle(i, (-30), 20) time.sleep(2) cobot.send_angle(i, (30), 20) time.sleep(2) cobot.send_angle(i, (0), 20) time.sleep(2) 当你看到机械臂围绕零位姿态，1-6关节逐一运动±20度的运动效果，说明关节1-6响应正常，可循序渐进学习使用gitbook的其他案例或者利用机械臂做各种有趣的事情！ 如果执行案例没有看到相对应的效果，那么请参考下文的常见问题解决方案，另外请注意在联系技术支持人员前确保你已经检查了以下2点： 机械臂是否能在上电之后正常锁住？如果不能锁住，请参考FQA硬件相关问题：“Q：机械臂上电锁不住如何解决？”进行排查 运行代码是否有任何报错信息？ 请尽可能详细描述下使用细节，如果方便的话请提供一个操作视频，这将会有助于快速分析定位问题，提前感谢！ ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/":{"url":"3-FunctionsAndApplications/5-BasicApplication/","title":"5 基础功能","keywords":"","body":"基础功能 本章主要解释产品的基本功能用法和基本软件的使用。本章至关重要，应仔细阅读。在实际应用机器人之前，请确保正确理解所述操作。 5.1 myBlockly myBlockly 是一款完全可视化的模块化编程软件，是一种图形化编程语言。myBlockly 界面简洁，编程功能全面。它的可视化编程方法适合初次接触机器人产品的用户。 5.2 机器人控制端口 5.3 系统使用在使用系统之前，你需要掌握基本的 Linux 知识，如文件管理和命令行操作。在网络配置方面，要了解访问系统的远程连接方法（如 SSH）。闪存镜像时，选择正确的文件和工具，正确设置参数，确保系统正常运行。 5.4 固件更新 为了确保您的 mycobot pro 450 机器臂始终处于最佳状态，我们不断改进和更新固件。固件更新是确保设备功能、性能和安全性的关键步骤之一。通过及时更新固件，我们可以修复已知问题、改进功能、提高性能，并确保 mycobot pro 450 机器臂 的稳定性和安全性。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/","title":"5.1 myBlockly","keywords":"","body":"什么是 myBlockly？ myBlockly 是一款完全可视化的模块化编程软件，是一种图形化编程语言。 myBlockly 在功能/设计上类似于麻省理工学院的儿童编程语言 Scratch。 使用 myBlockly 时，用户可以通过拖动模块来构建代码逻辑。这个过程就像搭积木一样。 从用户的角度来看，myBlockly 是一个简单易用的可视化代码生成工具。从开发人员的角度来看，myBlockly 是一个文本框，其中包含用户输入的代码。 在文本框中生成代码的过程，就是用户在 myBlockly 中拖动代码的过程。 myBlockly 支持的操作系统如下： Windows macOS Linux arm64 跳转到各部分： 5.1.1 首次使用 mblockly 5.1.2 下载和卸载 5.1.3 接口描述 5.1.4 常见问题解答 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.1-myBlocklyFirstUse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.1-myBlocklyFirstUse.html","title":"5.1.1 首次使用 mblockly","keywords":"","body":"使用 myBlockly 前的准备工作 在下载 myBlockly 之前，您需要配置 Python 环境。详情请参考以下操作方法。 环境配置。使用 myBlockly 之前，请确保已在计算机上配置好 Python 环境。 Raspberry Jetson Nano 版本自带 Ubuntu（V-20.04）系统和内置 Python 开发环境，因此无需构建和管理。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.2-install_uninstall.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.2-install_uninstall.html","title":"5.1.2 下载和卸载","keywords":"","body":"下载并安装 myBlockly 下载 下载链接 官方网站地址 您需要根据操作系统下载不同的安装包。 不同的后缀代表不同的系统，请下载相应的版本： *.AppImage : Linux 系统 *.dmg : Mac 系统 *.exe : Window 系统 安装 为 Linux 安装 myblockly 从官方网站下载 Linux 版本的 myblockly，你会得到如下所示的安装包 选择 myblockly-arm64-latest.AppImage，右键单击打开它，单击 Properties 打开它 点击进入 Permissions 在 Permissions 页面，选中 Allow executing file as program，然后单击 Close 按钮关闭弹出窗口 关闭弹出窗口后，双击安装包 myblockly-arm64-latest.AppImage，打开 myblockly 用于 Windows 安装 双击打开名为 myblockly-arm64-latest.exe 的文件 点击 Run 点击 Install 后，等待 myblockly 安装完成 安装完成后，点击 Finish 按钮打开并运行 myblockly 为 MacOS 安装 myblockly 从官方网站下载 Mac 版 myblockly，获得如下所示的安装包。双击打开。 注意：对于 MacOS，安装前请确保系统 \"首选项->安全与隐私->常规\" 和 允许来自应用商店和公认开发者的应用程序 已启用。 卸载 对于 Linux，卸载 myblockly 直接删除安装包即可 安装包的默认名称是 myblockly-arm64-latest.AppImage 卸载 Mac 版 myblockly 只需将 myblockly 移至应用中的垃圾桶即可 在 Windows 中卸载 myblockly 进入 myblockly 的文件目录，点击运行 Uninstall myblockly.exe 点击 Uninstall myblockly 已卸载，单击 Finish 退出 更新 如果您想更新 myblockly，请访问 官方网站 下载最新版本。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.3-interface_description.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.3-interface_description.html","title":"5.1.3 接口描述","keywords":"","body":"myBlockly 界面的显示和基本功能的使用 编号 图解说明 1 工具箱栏：点击特定类别，选择不同的构建模块 2 工作区：您可以将工具箱中的构件拖到工作区中使用 3 运行按钮：在工作区中运行代码 4 点击后将弹出以下菜单： - 保存：保存当前工作区 - 加载：加载已保存的工作区 - 设置：进入设置页面，您可以在此设置语言和主题。 5 点击后，控制面板将弹出。在面板中，您可以通过点击关节控制或坐标控制栏中的 \"+/-\"来快速控制机械臂的运动。6 点击后，您可以查看工作区中生成的 python 代码。7 将工作区居中。8 放大工作区。9 缩小工作区。 6 点击查看工作区生成的 python 代码 7 将工作区居中 8 放大工作区 9 缩小工作区域 10 垃圾桶：将工作区中的积木拖到此处可删除积木；同时点击垃圾桶可查看并恢复已删除的积木 程序运行 拖动想要的方法模块，编辑自己的程序（如上图所示），每个模块结构相结合在一起（有ki的声音），再点击“运行”就可以将代码上传到机械臂当中运行了。 注意：操作机械臂运动的程序是需要时间来完成的，所以在一个动作之后需要接上一个睡眠模块，给机械臂运动的时间再进行下一个运动。（自己因情况决定所需的时间，机械臂默认设定跑myBlockly最低的睡眠时间不低于0.5s）否则会导致机械臂无法达到理想的运动。 点击左上角“Python”选项可以查阅对应的Python代码，如下图所示。 程序保存和加载 MyBlockly 的程序以 *.json 格式保存。点击界面右上角的蓝色方框。当出现 \"保存 \"选项时，点击它保存程序。 同时点击蓝色方框并点击 \"加载 \"选项，导入已保存的程序。 基本功能演示完成后，您可以在以下页面查看其他信息 here ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.4-Q&A.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-5.1-myBlockly/5.1.4-Q&A.html","title":"5.1.4 常见问题解答","keywords":"","body":"Q&A 本章列出了使用 myBlockly 控制机械臂的常见问题，以供参考。 Q1：运行 myBlockly 时，出现错误信息 ModuleNotFoundError: No module named 'pymycobot' A: 这是因为在设置 Python 环境时没有安装 pymycobot 库。要安装 pymycobot 库，需要打开终端（Win 键 + R 键），输入 pip install pymycobot --upgrade --user点击回车键，即可看到 \"成功安装 pymycobot\"。 Q2：由于未添加 sleep 方法模块，机械臂没有响应 A: 操作机械臂的程序需要一定时间才能完成，因此在完成一个动作后，需要连接一个 sleep 模块，让机械臂在进行下一个动作前有足够的时间（所需时间取决于具体情况和机器，机械臂的默认设置是运行 myBlockly 时休眠时间最短不少于 0.5 秒），否则机械臂将无法实现理想的动作。 Q3：右上角的 Run 按钮无法点击，呈灰绿色。 A: 新版 myBlockly 增加了检测机械臂串行通信的功能。如果机械臂当前已与电脑连接，则需要进行检查： (1) 是否有后台程序占用机械臂的串行端口； (2) 右侧红色箭头下的工具栏是否关闭。如果打开，则需要手动关闭。 Q4：为什么运行程序后会出现大量错误？ A: 运行程序前，您需要确认一些信息： (1) 请确认机器人串行端口号和波特率正确无误。 如何检查串行端口号 在 Windows 系统中，找到设备管理器并检查端口。 如果端口（COM 和 LPT）显示 USB-Enhanced-SERIAL CH9102，则说明是 CP34X 芯片。如果端口（COM 和 LPT）显示 Silicon Labs CP210x USB 至 UART 桥接器，则表示该芯片为 CP210X。这两个名称对应的端口就是机械臂的串行端口。 打开 Linux 系统的终端，输入 ls/dev/tty* 并按 Enter。显示的就是机械臂的序列号。其中 AMA0 或 USB0 等就是机械臂的序列号。 在 Mac 系统上打开终端，输入 cd/dev/ 并按 Enter，然后运行 ls -al tty 查找，如 /dev/tty.usbserial-10。 (2) 请确认波特率是否正确。 (3) 请确认蓝色框中的型号、串行端口号和波特率与右侧小工具栏中的一致，并与机械臂相匹配。 Q5: 错误 MyCobot.int() 需要 2 个位置参数，但给出了 3 个。 A: 这个错误会出现在旧版本的 myBlockly 中，因为 myBlockly 和 pymycobot 的版本不兼容。只需更新 myBlockly 和 pymycobot 驱动程序库的版本即可。 Q6: 程序运行结果显示，子进程以代码 1 退出。 A: 这不是错误。所有程序运行后都会返回二进制数 1。这意味着所有程序都已成功运行。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-RobotControlPort.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-RobotControlPort.html","title":"5.2 机器人控制端口","keywords":"","body":" ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-SystemUsageInstructions.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-SystemUsageInstructions.html","title":"5.3 系统使用","keywords":"","body":"系统使用手册 1. 机器人系统介绍 系统 Ubuntu 是个人桌面操作系统中使用最广泛的 linux 操作系统。对于初学者来说，熟悉 linux 环境或一些嵌入式硬件操作系统是一个不错的选择。 功能介绍 myStudio：固件刻录软件，用于更新和刻录新固件。 myBlockly：图形化编程软件，可直接通过拖动构件形成运行代码，控制机械臂 ROS2 Shell：直接进入编译后的 ROS2 环境，可以直接输入相应指令，运行相应的 ROS2 代码 Github-ElephantRobotics：大象机器人官方开放源代码库 Home-ElephantRobotics：大象机器人网站 UserManual - CN/EN：机器人使用手册，包含有关机器人控制的所有内容 WiFi_ON/OFF：WiFi 开关，点击可打开/关闭 WiFi 功能 HotSpot_ON/OFF：热点开关，单击打开/关闭热点功能，热点名称为ElephantRobotics_AP_XXXX Language Support：系统语言设置，点击进入系统语言设置界面 2. 系统密码说明 账户密码、VNC 密码、SSH 密码、root 账户密码 密码：Elephant 如何更改密码 更改账户密码 使用快捷键 ctrl + alt + T 打开终端 输入 passwd 输入新密码两次 更改 vnc 密码 使用快捷键 ctrl + alt + T 打开终端 输入 vncpasswd 输入两次新密码 更改 ssh 密码 对于 SSH 远程连接，需要输入管理员账户的密码。无需单独更改密码 更改 root 帐户密码 使用快捷键 ctrl + alt + T 打开终端 输入 sudo passwd 输入两次新密码 3. VNC VNC 简介 是一种远程控制软件，一般用于远程解决计算机问题或软件调试 VNC Port 当机器人手臂和电脑连接到同一个 WiFi 时，机器人手臂的 IP 地址为端口 连接 VNC 有两种无线连接模式。第一种模式需要外接显示器才能对系统进行某些操作。具体步骤如下： 点击 \"Disconnect\"，断开默认的热点连接。 点击 \"Enable Wi-Fi \"，将显示当前可用的 WiFi 点击需要连接的 WiFi，输入密码 连接成功后，点击 \"Connection Information\" 查看机器人的 IP 地址 如示例所示，\"192.168.10.64\" 是机器人当前的 IP 地址 将电脑和机器人连接到同一个 WiFi 上，打开 VNC 查看器，输入 IP 地址（例如：输入 192.168.10.64），输入密码 Elephant，默认不指定用户名。下面是一个成功连接的示例： 第二种方法不需要连接显示器，直接将 Ubuntu 系统热点与 PC 机连接进行远程控制，但这种连接方式不具备上网冲浪的功能，只能远程控制机械臂系统。具体步骤如下： 连接热点ElephantRobotics_AP_XXXX，输入密码 Elephant 打开 VNC 查看器，输入 IP 地址 10.42.0.1 ，然后输入密码 Elephant，默认不指定用户名。下面是一个成功连接的示例： 如何提高连接流畅性 远程连接的流畅性取决于所连接 WiFi 的流畅性。建议连接稳定的 WiFi 进行远程控制 4. SSH SSH 简介 SSH 是一种网络协议，用于计算机之间的加密登录。如果用户使用 SSH 从本地计算机登录到另一台远程计算机，我们可以认为这次登录是安全的，即使中间被拦截，密码也不会泄露。 SSH 端口 默认端口号为 22 SSH 连接 按照 5.1.2 VNC 中的说明确认机器人的 IP 地址 单击 win + R 并输入 `cmd 输入后，单击 \"确定 \"打开外壳界面 输入 ssh er@IP address，然后按 Enter（IP 地址主要由机械臂显示，图中仅为示例）。 输入密码 Elephant 如上图所示，机械臂已通过 ssh 成功连接 如何提高连接流畅性 远程连接的流畅性取决于所连接 WiFi 的流畅性。建议连接稳定的 WiFi 进行远程控制。 5. 网络配置 默认 AP 使用情况 打开机器人电源，默认情况下，系统会连接到自带的热点，热点名称为ElephantRobotics_AP_XXXX，当前 IP 地址为10.42.0.1，该热点不具备网上冲浪功能，且传输速率和信息量有限，因此最终成像会有一定的失真和色差，通信传输也会有延迟，属于正常现象。 连接至无线局域网 点击 \"Disconnect\" 关闭默认热点 点击 \"Enable Wi-Fi \"，等待显示当前可用的 WiFi 单击要连接的 WiFi 并输入 WiFi 密码 连接成功后，点击 \"Connection Information\" 查看 IP 地址 如示例所示，\"192.168.10.64\" 是机器人当前的 IP 地址 有线网络连接 打开机器人电源，机器人默认连接到系统配置的热点： ElephantRobotics_AP_XXXX 单击 \"Disconnect\"，断开与默认热点的连接 将网线连接到机器人的网络端口 将网线连接到机器人的网络端口 如何设置默认 IP 地址 使用快捷键ctrl + alt + T打开终端，输入sudo vim /etc/netplan/01-network-manager-all.yaml，修改 01-network-manager-all.yaml 文件如下： 修改后，输入sudo netplan apply 使配置生效 如何自动分配 IP 地址 如果要将固定 IP 地址改为自动分配 IP 地址，请按如下步骤修改 /etc/netplan/01-network-manager-all.yaml 文件： 修改后，输入sudo netplan apply 使配置生效 6. 语言配置 如何更改语言 点击 语言支持，将所需语言拖到顶部，然后重新启动系统 如何下载语言点击Language Support，选择语言，点击下载，输入密码Elephant 7. 系统分辨率开关 点击屏幕右上角的图标，选择System Settings，进入控制面板 选择 Display 切换所选分辨率并单击 Apply 进行检查，然后单击 Keep this Configuration 保存配置 8. python Python 入门 内置安装Python3.8，无需自行安装 已安装的库： 包装 版本 pymycobot 3.1.5 pyserial 3.5 numpy 1.23.5 opencv-contrib-python 4.7.0.72 rospkg 1.4.0 rospkg-modules 1.4.0 尝试编程 如果你是 python 编程语言的新手，可以按照以下视频进行编程 您可以在以下输入字段中试用此代码： print (\"Hello World!\") 运行演示 可查看具体的案例代码 Python，只需复制案例中的代码并使用即可 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/5-BasicApplication/5.4-FirmwareUpdateInfo.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.4-FirmwareUpdateInfo.html","title":"5.4 固件更新","keywords":"","body":"安装驱动 用户可根据自己所使用的操作系统，点击下方按钮下载相应的 CP210X 或 CP34X 驱动程序压缩包，在解压压缩包后，选择对应操作系统位数的安装包进行安装。 目前存在两种驱动芯片版本， CP210X （适用于CP2104版本）/CP34X （适用于CH9102版本）驱动程序压缩包。若您不确定您的设备所使用的USB芯片，可同时安装两种驱动。（ CH9102_VCP_SER_MacOS 在安装过程中，可能出现报错，但实际上已经完成安装，忽略即可。） 对于 Mac OS，在安装之前确保系统 \"偏好设置->安全性和隐私->通用\" ，并允许从 App Store 和被认可的开发者。 下载底部 M5Stack-basic 串口驱动程序 CP210X Windows10 MacOS Linux CP34X Windows10 MacOS 下载末端 Atom 串口驱动程序 Windows10 请根据此图来完成驱动程序的安装 更新设备固件 用户可通过 myStudio进行设备固件的更新，在开发前，用户请确认自己所使用的设备固件是否为最新版的固件，以便于用户在后续开发中更好的使用该设备。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/","title":"6 软件开发指南","keywords":"","body":"第六章 软件开发指南 1 使用环境 mycobot Pro 450 是基于 PC 开发和使用的。由于机械臂内没有内置系统，因此在使用过程中需要机械臂和 PC 相结合。使用前请先准备好 PC。 2 开发环境 为了满足机器人在不同场景下的多样化应用需求，我们对机器人进行了多种编程语言的适配。到目前为止，我们已经适配了以下主流编程语言，我们认为您可以使用以下任何一种语言进行开发。请务必严格按照说明进行操作。任何遗漏的步骤都可能导致相应语言无法成功运行。祝您顺利使用机器人。 6.1 Python 我们的机器人支持 Python，Python API 库的开发也日趋完善。机器人的关节角度、坐标、抓手和其他方面都可以通过 Python 进行控制。 6.2 ROS2 ROS 2（Robot Operating System 2）是一个灵活的软件框架，专为机器人软件开发而设计。我们的机器人可以通过它提供的硬件抽象、设备驱动、库函数、可视化工具、消息传递以及包管理等一系列服务和功能，使得应用程序的开发变得更为高效和模块化。 6.3 C++ C++是C语言的继承，既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计。使用c++语言，您可以通过我们公司开发的c++动态库，进行自由开发（坐标控制、角度控制、io控制、夹爪控制等），控制我们公司已经研发出来的部分机器人。 6.4 Communication 如果您对信息论、编码和机器人通信功能有一定的了解，那么您就应该明白，所有的通信都源于数据传输。为了方便用户操作机器人，我们开放了基于串口通信的通信协议。您可以使用串口助手或将其封装到您熟悉的任何编程语言中来控制机器人。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/","title":"6.1 基于python 开发使用","keywords":"","body":"Python 是什么？ 我司产品对于python的支持较为友好，对于pythonAPI库的开发也日益完善，通过python能对机器人的关节角度，坐标，夹爪等多方面进行操控，选择性较多，如果你想通过Python编程来控制我们的机械臂，那么您可学习该章节。 Python 由荷兰数学和计算机科学研究学会的 Guido van Rossum 于1990 年代初设计，作为一门叫做 ABC 语言的替代品。 Python 提供了高效的高级数据结构，还能简单有效地面向对象编程。 Python 语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言， 随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。 Python 解释器易于扩展，可以使用 C 或 C++（或者其他可以通过C调用的语言）扩展新的功能和数据类型。 Python 也可用于可定制化软件中的扩展程序语言。Python 丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。 python开发使用引导 您可以根据以下指引来使用python对我们的机械臂进行开发 1.环境搭建 2.api说明 3.关节控制 4.坐标控制 5.IO控制 6.夹爪控制 7.演示代码与视频 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/1_download.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/1_download.html","title":"6.1.1 环境搭建","keywords":"","body":"环境搭建 pymycobot 是一个和 myCobot 进行串口通讯的 Python 包，支持 Python3.5 及之后版本。 在使用 pymycobot控制机械臂之前需要搭建Python环境，下面就对Python的下载安装做出详细说明。 Python下载和安装 适用设备： myCobot Pro 450 目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的3.10.7版本为例进行说明。 安装Python 注意：安装之前，请先确认您的电脑是64位还是32位。右键点击我的电脑，选择属性。如下图显示是64位的操作系统，所以选择64位的Python安装包。 Python官方下载地址： https://www.python.org/downloads/ 点击Downloads选项，开始下载Python，点击Add Python 3.10 to PATH,点击Install Now，开始安装Python 出现“Setup was successful”提示，说明安装完成 运行Python 安装成功后，打开命令提示符窗口（Win+R，输入cmd回车），敲入python后，会出现两种情况。 情况一： 出现图片中的提示表示Python安装成功。 出现提示符>>> 就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。 情况二： 假如输入错误（比如输入pythonn），则会出现错误提示： 注意：出现错误的信息一般都是没有配置环境变量导致的，可以参考下文 配置环境变量修改环境变量。 配置环境变量 由于Windows会根据一个Path的环境变量设定的路径去查找python.exe，如果没找到，就会报错。因此，如果安装时漏掉了勾选Add Python 3.10 to PATH，则需要手动把python.exe所在的路径添加到Path中，或者重新安装一遍Python，记得勾选上Add Python 3.10 to PATH选项即可。 以下是手动添加python.exe所在的路径步骤。 右键我的电脑–>选择属性–>选择高级系统设置–>选择右下角的环境变量： 环境变量主要有包括用户变量和系统变量，需要设置的环境变量就在这两个变量中。如下图所示： 用户变量是将自己的下载的程序可以在cmd命令中使用。把程序的绝对路径写到用户变量中即可使用，如下图所示： 以上步骤完成后，打开命令提示符窗口（Win+R，再输入cmd，回车），敲入Python，出现下图中的提示表示成功： PyCharm安装和使用 PyCharm是一款功能强大的Python编辑器，具有跨平台性。首先介绍PyCharm在Windows系统中的安装步骤。 下载地址： https://www.jetbrains.com/pycharm/download/#section=windows 下载安装 进入该网站后，我们会看到如下界面： 根据界面介绍下载文件，Professional表示专业版，Community是社区版，推荐安装社区版，因为是免费使用的。 下载好之后开始安装，点击Next： 按照个人喜好选择相应选项，然后点击Next： 出现下图界面继续点击Next： 点击Finish结束安装： 创建项目 PyCharm安装完成之后进入该软件，创建第一个程序。 单击桌面上的PyCharm图标，进入到PyCharm中，如下图所示，点击New Project： 点击之后找到Interpreter，开始对解释器进行设置，点击Add Interpreter： 点击New，找到python.exe存储位置，勾选Inherit global site-package选项： 设置Location。Location是存储PyCharm项目的地方，可根据需要自行选择。 新建PyCharm文件。右击箭头指向的文档图标，点击New，点击Python File，新建成功。 命名Python File： 文件创建成功后便进入如下的界面，便可以编写自己的程序了 使用之前 固件烧录。固件是指设备内部保存的设备“驱动程序”。操作系统只有通过固件才能按照标准的设备驱动实现特定机器的运行动作。不同版本的机械臂需要烧录不同的固件（可以参考 MyStudio章节）。 pymycobot安装。打开一个控制台终端(快捷键Win+R,输入cmd进入终端)，输入以下命令： pip install pymycobot --upgrade --user 出现了以下字样则证明pymycobot包安装成功 源码安装。打开一个控制台终端(快捷键Win+R,输入cmd进入终端)，输入以下命令即可安装： git clone https://github.com/elephantrobotics/pymycobot.git #其中填写你的安装地址，不填默认在当前路径 cd /pymycobot #进入到下载包的pymycobot文件夹 #根据你的python版本运行下面其一命令 # Install python3 setup.py install Python简单使用 上述准备工作完成之后，开始通过Python代码实现对机械臂的操控。这里以MyCobot Pro 450版本为例进行演示。 首先，打开您安装好的PyCharm，新建一个Python文件，输入以下代码，导入我们的库： from pymycobot import Pro450Client 注意： 如果输入from pymycobot.mycobotpro450 import MyCobotPro450，字体下方没有出现红色波浪线证明已经安装成功可以使用了，如果出现红色波浪线可以参考如何安装API库 ，如何调用API库。 如果不想通过上述命令安装API库，可以通过以下github下载项目到本地。 首先，进入项目地址：https://github.com/elephantrobotics/pymycobot 。然后点击网页右边Code按钮，再点击Download ZIP下载到本地，将压缩包pymycobot文件项目中的 pymycobot文件夹放入你python依赖库目录中，就可以直接导入使用。 简单演示 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/2_API.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/2_API.html","title":"6.1.2 api说明","keywords":"","body":"Pro 450 Python API [toc] API 使用介绍 API（Application Programming Interface），又称应用程序编程接口函数，是预先定义好的函数。使用以下函数接口时，请在一开始就导入我们的API库，导入方式为输入如下代码，否则将无法成功运行： 注意： 使用前需确保MyCobot Pro 450已开启服务端 # Example from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) print(mc.get_angles()) 1. 系统状态 get_system_version() 功能： 读取机器主控版本 返回值： 主控版本号 get_modified_version() 功能：读取修正版本号，仅内部使用 返回值： 修正版本号 get_robot_type() 功能： 检测机器型号 返回值： 定义规则：实际机器型号。例如，MyCobot Pro 450 型号为 4503 get_atom_version() 功能： 读取末端版本号 返回值： 版本号(float) get_tool_modify_version() 功能： 读取末端更正版本号 返回值： 更正版本号 2. 机器人整体运行状态 is_init_calibration() 功能： 检查机器是否已设置零位 返回值: bool: 如果机器人已初始化校准零位，则为 True，否则为 False get_fresh_mode() 功能: 查询运动模式 返回值: 0: 插补模式 1: 刷新模式 set_fresh_mode() 功能: 设置刷新模式 参数: 1: 总是首先执行最新的命令。 0: 以队列的形式按顺序执行指令。 3. 机器人异常检测 get_robot_status() 功能： 机器人错误安全状态 返回值: 0 - 正常。其他 - 机器人触发碰撞检测 servo_restore(joint_id) 功能：清除关节异常 参数： joint_id: int. 关节 id 1 - 6，254-所有关节恢复。 get_comm_error_counts(joint_id) 功能：读取通信异常次数 参数： joint_id: int. 关节 id 1 - 6 4.MDI Mode and Operation get_angles() 功能： 获取所有关节的度数 返回值：list所有度数的浮点列表 send_angle(id, degree, speed) 功能： 向机械臂发送一个关节度数 参数： id：关节 id（genre.Angle），范围 int 1-6 degree：度数值（float） | 关节 Id | 范围 | | ---- | ---- | | 1 | -165 ~ 165 | | 2 | -120 ~ 120 | | 3 | -158 ~ 158 | | 4 | -165 ~ 165 | | 5 | -165 ~ 165 | | 6 | -175 ~ 175 | speed：机械臂运动速度及范围 1~100 send_angles(angles, speed) 功能： 将所有角度发送到机械臂的所有关节 参数： angles：度数列表（List[float]），长度 6 speed：（int）1 ~ 100 get_coords() 功能： 从基于基准的坐标系获取机械臂坐标 返回值： 坐标浮点列表：[x, y, z, rx, ry, rz] send_coord(id, coord, speed) 功能： 向机械臂发送一个坐标 参数： id：向机械臂发送一个坐标，1-6 对应 [x, y, z, rx, ry, rz] coord：坐标值（float） | 坐标 ID | 范围 | | ---- | ---- | | x | -466 ~ 466 | | y | -466 ~ 466 | | z | -230 ~ 614 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | speed：（int）1-100 send_coords(coords, speed) 功能：：发送整体坐标和姿态，将机械臂头部从原点移动到您指定的点 参数： coords: 坐标列表，值[x,y,z,rx,ry,rz]，长度6 speed (int)：1 ~ 100 stop(deceleration=False) 功能： 停止机器人运动 参数: deceleration: ： 是否减速并停止。默认为 False。 返回值: 1 - 已停止 0 - 未停止 -1 - 错误 is_moving() 功能： 检测机器人是否在运动 返回值: 1 正在运动 0 停止运动 -1 错误 5. 软件关节限位 get_joint_min_angle(joint_id) 功能: 获取指定关节的最小运动角度 参数: joint_id : 输入关节ID（范围1-6） 返回值：float 角度值 get_joint_max_angle(joint_id) 功能: 获取指定关节的最大运动角度 参数: joint_id : 输入关节ID（范围1-6） 返回值：float 角度值 参数(id, angle) 功能: 设置最小关节角度限制 参数: id : 输入关节ID（范围1-6） angle: 参考send_angle()接口中对应关节的限制信息，不得小于最小值 set_joint_max(id, angle) 功能： 设置最大关节角度限制 参数： id ：输入关节ID（范围1-6） angle：参考send_angle()接口中对应关节的限制信息，不得大于最大值 6. 关节电机辅助控制 get_servo_encoders() 功能：读取全关节编码器值 返回值： 长度为6的列表 is_servo_enable(servo_id) 功能： Detecting joint connection status 参数: servo id 1-7 返回值: 1: Connection successful 0: not connected -1: error is_all_servo_enable() 功能： Detect the status of all joint connections 返回值: 1: Connection successful 0: not connected -1: error --> set_servo_calibration(servo_id) 功能： 校准关节执行器的当前位置为角度零点 参数: servo_id: 1 - 6 set_break（joint_id, value） 功能： 设置关节刹车 参数： joint_id: int. 关节 id 1 - 6 value: int. 0 - 掉使能, 1 - 使能 返回值: 0 : 失败; 1 : 成功 set_motor_enabled(joint_id, state 功能： 设置机器人力矩状态。（释放关节接口） 参数： joint_id: int. 关节 id 1 - 6, 254-所有关节 state: int. 0 - 掉使能, 1 - 使能 7. 运行辅助信息 get_zero_pos() 功能: 读取零位编码器值 返回值: list6个关节的零编码器的值 get_servo_speeds() 功能：获取所有关节的运动速度 返回值： 一个列表 get_servo_currents() 功能：获取关节电流 返回值：一个列表, 0 ~ 5000 mA get_servo_status() 功能：获取所有关节的运动状态 返回值： 值为 0 表示没有错误 8. 末端 IO 控制 set_digital_output(pin_no, pin_signal) 功能: 设置末端IO状态 参数 pin_no (int): 引脚号，范围 1 ~ 2 pin_signal (int): 0 / 1, 0 - 低电平，1 - 高电平 返回值: 1: 完成 get_digital_input(pin_no) 功能: 获取末端IO状态 参数: pin_no (int)，范围 1 ~ 2 返回值: int 0 / 1, 0 - 低电平，1 - 高电平 9. 底部 IO 控制 set_base_io_output(pin_no, pin_signal) 功能：设置底部IO输出状态 参数： pin_no (int) 引脚号，范围 1 ~ 12 pin_signal (int): 0 - 低电平. 1 - 高电平 get_base_io_output(pin_no) 功能： 获取底部IO输入状态 参数: pin_no (int) 引脚号，范围 1 ~ 12 返回值: 0 - 低电平. 1 - 高电平 10. 设置末端485通信 tool_serial_read_data(data_len) 功能： 读取固定长度数据，读取前先读取缓冲区长度，读取完成后数据会被清除 参数： data_len (int): 需要读取的字节数，范围1~45 返回值: 0：未设置 1：设置完成 tool_serial_write_data() 功能： 末端485发送数据，数据长度范围为1~45字节 返回值: 0-正常 1-机器人触发碰撞检测 set_over_time(timeout=1000) 功能： 设置超时时间(默认1s,超时时间内未读取数据缓冲区会清除) 参数： timeout (int): 超时时间，单位ms，范围0~65535 flash_tool_firmware() 功能： 烧录末端固件 11. Pro 力控夹爪 get_pro_gripper_firmware_version( gripper_id=14) 功能：读取Pro力控夹爪固件主次版本号 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: (float) 版本号, x.x get_pro_gripper_firmware_modified_version(gripper_id=14) 功能：读取Pro力控夹爪固件修正版本号 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 修正版本号 set_pro_gripper_id(target_id, gripper_id=14) 功能：设置力控夹爪ID。 参数： target_id (int): 范围1 ~ 254。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_id(gripper_id=14) 功能：读取力控夹爪ID。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 范围1 ~ 254。 set_pro_gripper_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_angle(gripper_id=14) 功能：读取力控夹爪角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_open(gripper_id=14) 功能：打开力控夹爪。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_close(gripper_id=14) 功能：关闭力控夹爪。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_calibration(gripper_id=14) 功能：设置力控夹爪零位。（首次使用需要先设置零位） 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_status(gripper_id=14) 功能：读取力控夹爪夹持状态。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: 0 - 正在运动。 1 - 停止运动，未检测到夹到物体。 2 - 停止运动，检测到夹到物体。 3 - 检测到夹到物体之后，物体掉落。 set_pro_gripper_enabled(state, gripper_id=14) 功能：设置力控夹爪使能状态。 参数： state (bool) ：0 或者1， 0 - 掉使能 1 - 上使能 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_torque(torque_value, gripper_id=14) 功能：设置力控夹爪扭矩。 参数： torque_value (int) ：扭矩值，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_torque(gripper_id=14) 功能：读取力控夹爪扭矩。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: (int) 0 ~ 100 set_pro_gripper_speed(speed, gripper_id=14) 功能：设置力控夹爪速度。 参数： speed (int): 夹爪运动速度，取值范围 1 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_speed(gripper_id=14) 功能：读取力控夹爪速度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：夹爪默认运动速度，范围 1 ~ 100。 set_pro_gripper_abs_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪绝对角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_io_open_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪IO张开角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_io_open_angle(gripper_id=14) 功能：读取力控夹爪IO张开角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_io_close_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪IO闭合角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_io_close_angle(gripper_id=14) 功能：读取力控夹爪IO闭合角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_mini_pressure(pressure_value, gripper_id=14) 功能：设置力控夹爪最小启动力 参数： pressure_value (int): 启动力值，范围 0 ~ 254。 gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_mini_pressure(gripper_id=14) 功能：读取力控夹爪最小启动力 参数： gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 启动力值，范围 0 ~ 254。 set_pro_gripper_protection_current(current_value, gripper_id=14) 功能：设置力控夹爪夹持电流 参数： current_value (int): 夹持电流值，范围 100 ~ 300。 gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_protection_current(gripper_id=14) 功能：读取力控夹爪夹持电流 参数： gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 夹持电流值，范围 100 ~ 300。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/3_angle.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/3_angle.html","title":"6.1.3 关节控制","keywords":"","body":"关节控制 对于串联式多关节机器人，关节空间的控制是针对机器人各个关节的变量进行的控制，目标是让机器人各个关节按照一定速度达到目标位置。 注意： 在设置角度时，不同系列的机械臂限位有所不同，具体可查看对应型号的参数介绍。 单关节控制 send_angle(id, degree, speed) 功能： 发送指定的单个关节运动至指定的角度 参数说明： id: 代表机械臂的关节，用数字1-6来表示。 degree: 表示关节的角度 speed：表示机械臂运动的速度，范围0~100 返回值： 1 set_encoder(joint_id, encoder, sp) 功能： 发送指定的单个关节运动至指定的电位值 参数说明： joint_id: 代表机械臂的关节，用数字1-6来表示。 encoder:表示机械臂的电位值，取值范围是 0 ~ 4096 sp: 表示机械臂运动的速度，范围1~100 返回值： 1 多关节控制 get_angles() 功能： 获取所有关节角度 返回值： list一个浮点值的列表代，表所有关节的角度 send_angles(degrees, speed) 功能： 发送所有角度给机械臂所有关节 参数说明： degrees: (List[float])包含所有关节的角度 , 表示方法为：[20,20,20,20,20,20] speed: 表示机械臂运动的速度，取值范围是1-100 返回值： 1 set_encoders(encoders, sp) 功能： 发送电位值给机械臂所有关节 参数说明： encoder:表示机械臂的电位值，取值范围是 0 ~ 4096，表示方法为：[2048,2048,2048,2048,2048,2048] sp: 表示机械臂运动的速度，取值范围是1-100 返回值： 1 sync_send_angles(degrees, speed, timeout=15) 功能： 同步发送角度，到达目标点返回 参数说明： degrees: 每个关节的角度值列表 List[float] speed: ( int)机械臂运动的速度，取值范围是1-100 timeout：时间默认15s 返回值： 1 get_radians() 功能： 获取所有关节的弧度 返回值： list包含所有关节弧度值的列表 send_radians(radians, speed) 功能： 发送弧度值给机械臂所有关节 参数说明： radians：list表示机械臂的弧度值列表，取值范围是 -5~5 返回值： 1 案例使用 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/4_coord.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/4_coord.html","title":"6.1.4 坐标控制","keywords":"","body":"坐标控制 主要用于实现智能规划路线让机械臂从一个位置到另一个指定位置。分为[x,y,z,rx,ry,rz]，其中[x,y,z]表示的是机械臂头部在空间中的位置（该坐标系为直角坐标系），[rx,ry,rz]表示的是机械臂头部在该点的姿态（该坐标系为欧拉坐标）。算法的实现以及欧拉坐标的表示需要一定的学术知识，这里不对其过多的讲解，我们只要懂得直角坐标系就可以很好的使用这个函数了。 注意： 在设置坐标时，不同系列的机械臂关节构造有所不同，同一组坐标，不同系列的机械臂会展示不同的姿态。 myCobot 单参数坐标 send_coord(id,coord,speed) 功能： 发送单个坐标值给机械臂进行移动 参数说明： id：代表机械臂的坐标，表示方法1-6：如X轴可以填写1，Y填写2，以此类推 coord：输入您想要到达的坐标值 speed：表示机械臂运动的速度，范围是1-100 返回值： 1 多参数坐标 get_coords() 功能： 获取当前坐标和姿态 返回值： list包含坐标和姿态的列表，长度为 6，依次为 [x, y, z, rx, ry, rz] send_coords(coords, speed, mode) 功能： 发送整体坐标和姿态,让机械臂头部从原来点移动到您指定点。 参数说明： coords: [x,y,z,rx,ry,rz]的坐标值，长度为6 speed: 表示机械臂运动的速度，范围是1-100 mode: ( int): 取值限定 0 和 1。 0 表示机械臂头部移动的路径为非线性，即随机规划路线，只要机械臂头部以保持规定的姿态移动到指定点即可。 1 表示机械臂头部移动的路径为线性的，即智能规划路线让机械臂头部以直线的方式移动到指定点。 返回值： 1 set_tool_reference(coords) 功能： 设置工具坐标系。 参数说明： coords: 六轴：[x,y,z,rx,ry,rz]的坐标值，长度为6, x,y,z的范围为-280 ~ 280，rx,ry,yz的范围为-314 ~ 314 返回值： 1 get_tool_reference() 功能： 获取工具坐标系。 返回值： 返回一个长度为6的坐标列表 get_world_reference() 功能： 获取世界坐标系。 返回值： 返回一个长度为6的坐标列表 set_world_reference(coords) 功能： 设置世界坐标系。 参数说明： coords: 六轴：[x,y,z,rx,ry,rz]的坐标值，长度为6, x,y,z的范围为-280 ~ 280，rx,ry,yz的范围为-314 ~ 314 返回值： 1 set_reference_frame(rftype) 功能： 设置基坐标系。 参数说明： rftype: 0 - 基坐标系(默认)，1 - 世界坐标系 返回值： 1 get_reference_frame() 功能： 获取基坐标系。 返回值： 0 - 基坐标系，1 - 世界坐标系，-1 - 通信失败 set_end_type(end) 功能： 设置末端坐标系。 参数说明： end: 0 - 法兰(默认)，1 - 工具 返回值： 1 get_end_type() 功能： 获取末端坐标系。 返回值： 0 - 法兰(默认)，1 - 工具，-1 - 通信失败 案例使用 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/5_IO.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/5_IO.html","title":"6.1.5 IO控制","keywords":"","body":"IO控制 IO即数据的输入与输出，在我们的机械臂的Basic和Atom上有多个pin脚，通过以下函数接口可以对其设置其输入输出模式。 myCobot： 末端 IO 控制 set_digital_output(pin_no, pin_signal) 功能: 设置末端IO状态 参数 pin_no (int): 引脚号，范围 1 ~ 2 pin_signal (int): 0 / 1, 0 - 低电平，1 - 高电平 返回值: 1: 完成 get_digital_input(pin_no) 功能: 获取末端IO状态 参数: pin_no (int)，范围 1 ~ 2 返回值: int 0 / 1, 0 - 低电平，1 - 高电平 底部 IO 控制 set_base_io_output(pin_no, pin_signal) 功能：设置底部IO输出状态 参数： pin_no (int) 引脚号，范围 1 ~ 12 pin_signal (int): 0 - 低电平. 1 - 高电平 get_base_io_output(pin_no) 功能： 获取底部IO输入状态 参数: pin_no (int) 引脚号，范围 1 ~ 12 返回值: 0 - 低电平. 1 - 高电平 案例使用 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/6_gripper.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/6_gripper.html","title":"6.1.6 夹爪控制","keywords":"","body":"夹爪控制 使用Python控制夹爪之前，需要先在机械臂上安装连接好夹爪。不同夹爪适配不同的机械臂（具体适配信息请参考产品配件。 注意： MyCobot 280自适应夹爪将夹爪插在Atom上面的引脚上，具体看下图： 夹爪控制 get_pro_gripper_firmware_version( gripper_id=14) 功能：读取Pro力控夹爪固件主次版本号 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: (float) 版本号, x.x get_pro_gripper_firmware_modified_version(gripper_id=14) 功能：读取Pro力控夹爪固件修正版本号 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 修正版本号 set_pro_gripper_id(target_id, gripper_id=14) 功能：设置力控夹爪ID。 参数： target_id (int): 范围1 ~ 254。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_id(gripper_id=14) 功能：读取力控夹爪ID。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 范围1 ~ 254。 set_pro_gripper_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_angle(gripper_id=14) 功能：读取力控夹爪角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_open(gripper_id=14) 功能：打开力控夹爪。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_close(gripper_id=14) 功能：关闭力控夹爪。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_calibration(gripper_id=14) 功能：设置力控夹爪零位。（首次使用需要先设置零位） 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_status(gripper_id=14) 功能：读取力控夹爪夹持状态。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: 0 - 正在运动。 1 - 停止运动，未检测到夹到物体。 2 - 停止运动，检测到夹到物体。 3 - 检测到夹到物体之后，物体掉落。 set_pro_gripper_enabled(state, gripper_id=14) 功能：设置力控夹爪使能状态。 参数： state (bool) ：0 或者1， 0 - 掉使能 1 - 上使能 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_torque(torque_value, gripper_id=14) 功能：设置力控夹爪扭矩。 参数： torque_value (int) ：扭矩值，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_torque(gripper_id=14) 功能：读取力控夹爪扭矩。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值: (int) 0 ~ 100 set_pro_gripper_speed(speed, gripper_id=14) 功能：设置力控夹爪速度。 参数： speed (int): 夹爪运动速度，取值范围 1 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_speed(gripper_id=14) 功能：读取力控夹爪速度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：夹爪默认运动速度，范围 1 ~ 100。 set_pro_gripper_abs_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪绝对角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 set_pro_gripper_io_open_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪IO张开角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_io_open_angle(gripper_id=14) 功能：读取力控夹爪IO张开角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_io_close_angle(gripper_angle, gripper_id=14) 功能：设置力控夹爪IO闭合角度。 参数： gripper_angle (int): 夹爪角度，取值范围 0 ~ 100。 gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_io_close_angle(gripper_id=14) 功能：读取力控夹爪IO闭合角度。 参数： gripper_id (int): 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：int 0 ~ 100 set_pro_gripper_mini_pressure(pressure_value, gripper_id=14) 功能：设置力控夹爪最小启动力 参数： pressure_value (int): 启动力值，范围 0 ~ 254。 gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_mini_pressure(gripper_id=14) 功能：读取力控夹爪最小启动力 参数： gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 启动力值，范围 0 ~ 254。 set_pro_gripper_protection_current(current_value, gripper_id=14) 功能：设置力控夹爪夹持电流 参数： current_value (int): 夹持电流值，范围 100 ~ 300。 gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值： 0 - 失败 1 - 成功 get_pro_gripper_protection_current(gripper_id=14) 功能：读取力控夹爪夹持电流 参数： gripper_id (int) 夹爪ID，默认14，取值范围 1 ~ 254。 返回值：(int) 夹持电流值，范围 100 ~ 300。 案例 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/7_example.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.1-python/7_example.html","title":"6.1.7 演示代码与视频","keywords":"","body":"演示代码与视频 以下为各种使用的案例以及运行结果视频,您可以复制代码进行使用或者修改（以下案例使用的机械臂型号为MyCobot Pro 450,不同系列的机械臂参数有所不同,注意修改）。 注意： 各款设备的对应的波特率不尽相同,使用时请查阅资料了解其波特率,串口编号可通过计算器设备管理器或串口助手进行查看。 1 控制RGB灯板 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/","title":"6.2 基于ROS2 开发使用","keywords":"","body":"ROS2 介绍 ROS2的前身是ROS，ROS就是机器人操作系统（Robot Operating System）。 但ROS本身并不是一个操作系统，而是一个软件库和工具集。 Ros的出现解决了机器人各个部件的通信问题。 后来，越来越多的机器人算法被集成到ROS中。 ROS2继承了ROS，比ROS更强大更好用。 ROS2的设计目标和特点 ROS2肩负着改变智能机器人时代的历史使命。 在设计之初，就考虑到满足各种机器人应用的需求。 多机器人系统： 未来机器人不再是独立的个体，机器人之间也需要交流和协作。 ROS2为多机器人系统的应用提供了标准的方法和通信机制。 跨平台： 机器人应用场景不同，使用的控制平台也会有很大差异。 为了让所有的机器人都能运行ROS2，ROS2可以跨平台运行在Linux、Windows、MacOS、RTOS上。 实时： 机器人运动控制和许多行为策略都要求机器人是实时的。 例如，机器人必须在 100 毫秒内可靠地检测到前方的行人，或在 1 毫秒内完成运动学和动力学计算。 ROS2 是像这样实时提供基本要求的。 产品化： 大量的机器人已经进入我们的生活，未来还会越来越多，ROS2不仅可以用于机器人研发阶段，还可以直接安装在 产品并进入消费市场。 这也对ROS2的稳定性和鲁棒性提出了巨大的挑战。 项目管理： 机器人开发是一项复杂的系统工程。 设计、开发、调试、测试、部署全过程的项目管理工具和机制也将在ROS2中得到体现，方便我们开发机器人。 发行版本 ROS2和Ubuntu对应的发行版本和维护周期。 ROS2 版本 发布日期 维护期限 Ubuntu 版本 Dashing 2019.5 2021.5 Ubuntu 18.04 (Bionic Beaver) Eloquent 2019.11 2020.11 Ubuntu 18.04 (Bionic Beaver) Foxy 2020.6 2023.5 Ubuntu 20.04(Focal Fossa) Galactic 2021.5 2022.11 Ubuntu 20.04(Focal Fossa) Humble 2022.5 2027.5 Ubuntu 22.04(Jammy Jellyfish) ROS和ROS2的比较 ROS2重新设计了系统架构。 两代ROS的架构变化如下： OS Layer： OS层。在ROS2中，它可以构建在linux或其他系统上，甚至是没有操作系统的裸机。 Middleware Layer： 中间件层。ROS1的通信系统基于TCPROS/UDPROS，而ROS2的通信系统基于DDS。 DDS是分布式实时系统中数据发布/订阅的标准解决方案。 Application Layer： 应用层。ROS1依赖于ROS Master，而在ROS2中，节点之间使用了一种名为“Discovery”的发现机制来帮助彼此建立连接。 ROS设计了一套完整的通信机制（主题、服务、参数、动作）来简化机器人开发。 通过这种机制，可以连接机器人的各个部件。 这种机制设计了一个叫做Ros Master的节点，所有其他组件的通信都必须经过master节点。 一旦主节点挂掉，就会导致整个机器人系统的通信崩溃！ 所以不能利用Ros的不稳定性来做一些自动驾驶等高风险的机器人。 此外，还有以下缺点： 基于TCP的通信实时性差，系统开销大 对 python3 支持不友好 消息机制不兼容 无加密机制，安全性低 ROS2首先移除ROS中存在的master节点。 去掉主节点后，各个节点可以通过DDS节点相互发现，各个节点是平等的，可以实现一对一、一对多、多对多的通信。 使用DDS进行通信后，可靠性和稳定性得到了增强。 与只支持Linux系统的ROS相比，ROS2还支持windows、mac甚至RTOS平台。 ROS2开发指引 ROS2安装指导 ROS2基础使用 rivz使用指导 Moveit2使用指导 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.1-InstallationOfROS2.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.1-InstallationOfROS2.html","title":"6.2.1 环境搭建","keywords":"","body":"环境安装 注意：安装虚拟机系统时，请安装Ubuntu 20.04版本的系统。若使用moveIt2的功能，需要安装 Ubuntu 22.04版本的系统。 在Linux中安装不同版本的ubuntu系统，可参考以下 ROS1环境搭建 。 在Linux中安装不同版本的ubuntu系统 虚拟机安装 前往官方网站下载虚拟机Virtual Box 或者前往官方网站下载虚拟机 VM ware VirtualBox 安装包：Windows hosts VirtualBox 拓展包：VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack 当然，如果您已经拥有您的虚拟机，您可以跳过该步骤。 我们选择下载Virtual box，因为它是免费的。 新建虚拟机 创建虚拟机 在控制中选择新建 输入虚拟机名称和虚拟机存放的位置，选择虚拟机类型为Linux，选择ubuntu64位版本，进行下一步。 按照自己的需求配置内存大小，进行下一步。 选择现在创建虚拟硬盘，进行创建。 虚拟硬盘类型选择VDI类型，进行下一步。 分配虚拟硬盘大小，由于需要安装ubuntu系统，而且还会在该系统中进行操作，建议大小不要低于20G。 导入ubuntu系统 下载ubuntu系统。 请根据自己的需要选择ubuntu版本进行安装 注意： ROS2需要下载20.04版本。若使用moveIt2的功能，需要安装 Ubuntu 22.04版本的系统。 16.04版本 18.04版本 20.04版本 22.04版本 三种版本的安装方法和过程都是相同的，这里以18.04版本作为例子进行安装 下载完成后有如图文件： 导入ubuntu到虚拟机中 在Virtual box中找到之前安装的虚拟机，进入设置，并在存储中给控制器分配光盘： 然后打开虚拟机进行ubuntu安装，并点击启动。 ubuntu安装 等待系统启动，进入欢迎界面，选中“中文（简体）”，并点击“安装 Ubuntu”按钮； 点击“继续”按钮； 选中“清除整个磁盘并安装 Ubuntu”选项，点击“现在安装”按钮； 在弹出的对话框中点击“继续”按钮； 设置地理位置，点击“继续”按钮； 设置用户名和密码，点击“继续”按钮； 进入系统安装界面，请耐心等待； 待安装完成，在弹出的对话框中，点击“现在重启”按钮，完成安装。 ROS2 环境搭建 ROS2 安装 基本的开发环境搭建需要安装机器人操作系统 ROS2以及 git 版本管理器，以下分别介绍其安装方法及流程。 myCobot Pro 450的设备可参考以下介绍的安装方式及流程。 版本选择 ROS2 跟 ubuntu 有一一对应的关系，不同版本的 ubuntu 对应不同版本的 ROS2，参考网站见下：http://docs.ros.org/en/foxy/Releases.html 这里给出对应Ubuntu支持的 ROS2 版本: ROS2版本 发布日期 维护截止日期 Ubuntu版本 Foxy 2020 年 6 月 5 日 2023 年 5 月 Ubuntu 20.04(Focal Fossa) Galactic 2021 年 5 月 23 日 2022 年 11 月 Ubuntu 20.04(Focal Fossa) Humble 2022 年 5 月 23 日 2027 年 5 月 Ubuntu 22.04(Jammy Jellyfish) 请根据自己安装的Ubuntu版本进行对应ROS2版本的安装，moveIt2仅支持humble版本 如果版本不同，下载将会失败.在这里我们选择的系统为 Ubuntu 20.04 (推荐), 对应 ROS2 版本为 ROS2 Foxy NOTE: 目前我们不提供 windows 安装 ROS2 的任何参考, 若有需要请参考 http://docs.ros.org/en/foxy/Installation/Alternatives/Windows-Development-Setup.html 开始安装 1 添加源 Ubuntu 本身的软件源列表中没有 ROS2 的软件源，所以需要先将 ROS2 软件源配置到软件列表仓库中，才能下载 ROS2 。打开一个控制台终端(快捷键Ctrl+Alt+T),输入如下指令： 官方源： echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 若下载速度缓慢，推荐就近选择一个镜像源替换上面的命令。例如，huawei cloud为： echo \"deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 2 设置秘钥 配置公网秘钥,这一步是为了让系统确认我们的路径是安全的的，这样下载文件才没有问题，不然下载后会被立刻删掉： sudo apt install curl gnupg2 -y curl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add - 3 安装 在加入了新的软件源后，需要更新软件源列表，打开一个控制台终端(快捷键Ctrl+Alt+T),输入如下指令： sudo apt-get update 执行安装 ROS2，打开一个控制台终端(快捷键Ctrl+Alt+T),请按照自己的Ubuntu版本选择输入以下指令： # Ubuntu 20.04 foxy版本 sudo apt install ros-foxy-desktop # Ubuntu 20.04 galactic版本 sudo apt install ros-galactic-desktop # Ubuntu 22.04 humble版本 sudo apt install ros-humble-desktop 安装过程耗时比较长，需要耐心等待 安装完成后刷新环境变量： source /opt/ros/foxy/setup.bash 设置ros2环境 为了避免每次关掉终端窗口后都需要重新生效 ROS2 功能路径，我们可以把路径配置到环境变量中，这样在每次打开新的终端时便可自动生效 ROS2 功能路径，在终端依次执行以下命令，打开一个控制台终端(快捷键Ctrl+Alt+T)执行以下命令： # Ubuntu 20.04 foxy版本 # 将 ros 环境加入到当前控制台的环境变量 echo \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc # Ubuntu 20.04 galactic版本 echo \"source /opt/ros/galactic/setup.bash\" >> ~/.bashrc # Ubuntu 22.04 humble版本 echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc source ~/.bashrc 安装 ROS2 额外依赖项 在终端输入以下命令安装ROS2额外依赖项，打开一个控制台终端(快捷键Ctrl+Alt+T)： sudo apt install python3-argcomplete -y sudo apt install ros-foxy-xacro sudo apt-get install python3-colcon-common-extensions # Ubuntu 20.04 foxy版本 sudo apt install ros-foxy-joint-state-publisher-gui # Ubuntu 20.04 galactic版本 sudo apt install ros-galactic-joint-state-publisher-gui # Ubuntu 22.04 humble版本 sudo apt install ros-humble-joint-state-publisher-gui sudo apt install ros-humble-xacro 验证安装 为了验证 ROS2 是否安装成功，打开一个控制台终端(快捷键Ctrl+Alt+T)，在终端执行以下命令： ros2 当显示如下界面，则表示 ROS2 安装成功 MoveIt2 安装 注意： 这里仅提供 ubuntu 22.04系统的安装方式 MoveIt2 是 ros2 中一系列移动操作的功能包的组成，主要包含运动规划，碰撞检测，运动学，3D 感知，操作控制等功能。 更新软件源列表 打开一个控制台终端(快捷键Ctrl+Alt+T)，在终端窗口输入以下命令，以更新软件源列表： sudo apt update 安装 MoveIt2 sudo apt-get install ros-humble-moveit sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-joint-trajectory-controller ros-humble-joint-state-broadcaster git 安装 更新软件源列表 打开一个控制台终端(快捷键Ctrl+Alt+T)，在终端窗口输入以下命令，以更新软件源列表： sudo apt-get update 安装 git 打开一个控制台终端(快捷键Ctrl+Alt+T)，在终端窗口输入以下命令，执行 git 的安装： sudo apt-get install git 验证安装 读取 git 版本，打开一个控制台终端(快捷键Ctrl+Alt+T)，在终端窗口输入以下命令： git --version 在终端中可以显示 git 版本号，如下，即为安装成功。 mycobot_ros2 安装 mycobot_ros2 是 ElephantRobotics 推出的，适配旗下桌面型六轴机械臂 mycobot系列 的ROS2 包。 项目地址：http://github.com/elephantrobotics/mycobot_ros2 前提 在安装包之前，请保证拥有 ros2 工作空间。 这里我们给出创建工作空间的样例命令，打开一个控制台终端(快捷键Ctrl+Alt+T)，在命令行输入以下命令： mkdir -p ~/colcon_ws/src # 创建文件夹 添加工作空间的环境 官方默认的 ROS2 工作空间是 colcon_ws。 echo \"source ~/colcon_ws/install/setup.bash\" >> ~/.bashrc source ~/.bashrc 安装 NOTE： 本包依赖于ROS2和MoveIt2，使用前确保以成功安装ROS2和MoveIt2。 本包与真实机械臂的交互依赖于PythonApi - pymycobot Api项目地为：https://github.com/elephantrobotics/pymycobot 快速安装：pip install pymycobot --upgrade 执行pip install pymycobot --upgrade命令时，若出现如下图错误提示： 根据提示输入以下命令安装pip sudo apt install python-pip 如果你的Ubuntu系统是20.04版本，请执行命令sudo apt install python3-pip安装pip pip安装完成后，终端再次执行 pip install pymycobot --upgrade 安装方式依赖于Git，请确保电脑中已安装Git。 官方默认的 ROS2 工作区是 colcon_ws。 cd colcon_ws/src # 进入工作区的src文件夹中 # 克隆github上的代码 git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd .. # 返回工作区 colcon build --symlink-install # 构建工作区中的代码，--symlink-install：避免每次调整 python 脚本时都需要重新编译 source install/setup.bash # 添加环境变量 为了减少编译时间，可以单独编译某个功能包，其中 package_name 是具体的功能包名称，请根据实际进行修改。 cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash 导入系统镜像使用ROS2/MoveIt2: 注意： 为了降低环境搭建难度，我们将给出 Linux系统镜像（Ubuntu 22.04）、Virtual Box安装包以及其扩展包。 接下来将教导大家如安装Virtual Box以及导入Linux系统镜像（默认密码为123）。 已内置环境： ROS2 humble + MoveIt2 + Git + pymycobot + mycobot_ros2 安装虚拟机 前往官方网站下载虚拟机Virtual Box 或者前往官方网站下载虚拟机 VM ware VirtualBox 安装包：Windows hosts VirtualBox 拓展包：VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack 当然，如果您已经拥有您的虚拟机，您可以跳过该步骤。 我们选择下载Virtual box，因为它是免费的。 下载Linux系统镜像 点击下载：Linux ubuntu22.04 导入Linux系统镜像 注意: 导入方式可参考ubuntu 20.04系统的导入方式 在Virtual Box界面中点击 管理 -> 导入虚拟电脑 -> 选择虚拟镜像 -> 选择安装路径并进行导入，如下安装即可。 等待镜像导入即可，如下图即为安装成功。 然后启动系统即可，默认密码为 123 至此ROS2环境搭建完成，ROS2的使用请参考 Rviz2介绍及使用 章节。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.2-BasicTutorial.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.2-BasicTutorial.html","title":"6.2.2 ROS2 基础知识","keywords":"","body":"基本工具 在本章中，您将了解ROS2的常用命令工具。 Topics ROS 2 将复杂的系统分解为许多模块化节点。 Topics是 ROS 图的重要元素，充当节点交换消息的总线。 Topics是数据在节点之间移动的主要方式之一，因此在系统的不同部分之间移动。 具体参考: 官方教程 topics 帮助 ros2 topics -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 节点关系图 rqt_graph 了解topics相关命令 ros2 topics -h 话题列表 ros2 topic list ros2 topic list -t # 显示相应的消息类型 查看话题内容 ros2 topic echo ros2 topic echo /turtle1/cmd_vel 显示话题相关信息，类型 ros2 topic info # 输出 /turtle1/cmd_vel 话题接口相关信息 ros2 topic info /turtle1/cmd_vel 显示接口相关信息 ros2 interface show # 输出 geometry_msgs/msg/Twist接口相关信息 ros2 interface show geometry_msgs/msg/Twist 发布命令 ros2 topic pub '' # 发布速度命令 ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" # 按一定频率发布速度命令 ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 查看话题发布的频率 ros2 topic hz #输出/turtle1/cmd_vel发布频率 ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" Nodes ROS 中的每个节点都应该负责一个单一的模块用途（例如，一个节点用于控制车轮电机，一个节点用于控制激光测距仪等）。 每个节点都可以通过主题、服务、操作或参数向其他节点发送和接收数据。 一个完整的机器人系统由许多协同工作的节点组成。 在 ROS 2 中，单个可执行文件（C++ 程序、Python 程序等）可以包含一个或多个节点。 具体参考: 官方教程 nodes 帮助 ros2 nodes -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看节点列表 ros2 node list 查看节点关系图 rqt_graph 重映射 ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle ros2 node list 查看节点信息 ros2 node info ros2 node info /my_turtle Services 服务是 ROS 图中节点的另一种通信方法。 服务基于调用和响应模型，而不是主题的发布者-订阅者模型。 虽然主题允许节点订阅数据流并获得持续更新，但服务仅在客户端专门调用时才提供数据。 具体参考: 官方教程 services 帮助 ros2 service -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看服务列表 ros2 service list # 显示服务列表及消息类型 ros2 service list -t 查看服务接收到的消息类型 ros2 service type ros2 service type /clear 找到使用某类消息类型的服务 ros2 service find ros2 service find std_srvs/srv/Empty 查看服务消息类型定义 ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv 调用服务命令,清除行走轨迹 ros2 service call ros2 service call /clear std_srvs/srv/Empty 生成新乌龟 ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: 'turtle2'}\" Parameters 参数是节点的配置值。 您可以将参数视为节点设置。 节点可以将参数存储为整数、浮点数、布尔值、字符串和列表。 在 ROS 2 中，每个节点都维护自己的参数。 有关参数的更多背景信息，请参阅概念文档。 具体参考: 官方教程 parameters 帮助 ros2 param -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看服务列表 ros2 param list 获取参数值 ros2 param get ros2 param get /turtlesim background_g 设置参数值 ros2 param set ros2 param set /turtlesim background_r 150 导出参数值 ros2 param dump ros2 param dump /turtlesim 独立导入参数 ros2 param load ros2 param load /turtlesim ./turtlesim.yaml 启动节点同时导入参数 ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml Actions 动作是 ROS 2 中的一种通信类型，用于长时间运行的任务。 它们由三部分组成：目标、反馈和结果。 操作基于主题和服务。 它们的功能类似于服务，除了操作是可抢占的（您可以在执行时取消它们）。 他们还提供稳定的反馈，而不是返回单一响应的服务。 操作使用客户端-服务器模型，类似于发布者-订阅者模型（在主题教程中描述）。 “动作客户端”节点将目标发送到“动作服务器”节点，该节点确认目标并返回反馈流和结果。 具体参考: 官方教程 action 帮助 ros2 action -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 按G|B|V|C|D|E|R|T 实现旋转，按F键盘取消l 查看节点action的服务端和客户端 ros2 node info /turtlesim 查看动作列表 ros2 action list ros2 action list -t # 显示动作类型 查看动作信息 ros2 action info ros2 action info /turtle1/rotate_absolute 查看动作消息内容 ros2 interface show turtlesim/action/RotateAbsolute 发送动作目标信息 ros2 action send_goal ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" # 带反馈信息 ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" --feedback RQt RQt 是一个图形用户界面框架，它以插件的形式实现各种工具和界面。 可以将所有现有的 GUI 工具作为 RQt 中的可停靠窗口运行！ 这些工具仍然可以以传统的独立方式运行，但 RQt 可以更轻松地在单个屏幕布局中管理所有不同的窗口。 具体参考: 官方教程 您可以通过以下方式轻松运行任何 RQt 工具/插件： rqt rqt 帮助 rqt -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 动作浏览器: / Plugins -> Actions ->Action Type Browser 参数重配置: / Plugins -> configuration ->Parameter Reconfigure 节点图: /Node Graph 控制转向: /Plugins -> Robot Tools -> Robot Steering 服务调用: /Plugins -> Services -> Service Caller 服务类型浏览器: Plugins -> Services -> Service Type Browser 消息发布: Plugins -> Topics -> Message Publisher 消息类型浏览器: Plugins -> Topics -> Message Type Browser 话题列表: Plugins -> Topics -> Topic Monitor 绘制曲线图: Plugins -> Visualization -> Plot 查看日志: rqt_console ros2 run rqt_console rqt_console ros2 run turtlesim turtlesim_node ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}\" TF2 tf2 是变换库，它允许用户随着时间的推移跟踪多个坐标系。 tf2 以时间缓冲的树结构维护坐标系之间的关系，并让用户在任何需要的时间点在任意两个坐标系之间变换点、向量等。 具体参考: 官方教程 让我们从安装演示包及其依赖项开始。 sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations 跟随 launch启动2个小乌龟，第一个小乌龟自动跟随第二个 ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py 通过键盘控制第一个小乌龟移动 ros2 run turtlesim turtle_teleop_key 查看TF树 ros2 run tf2_tools view_frames.py evince frames.pdf 查看两个坐标系之间的关系 ros2 run tf2_ros tf2_echo [reference_frame] [target_frame] ros2 run tf2_ros tf2_echo turtle2 turtle1 在rviz上查看TF关系 ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz URDF URDF 是统一机器人描述格式，用于指定 ROS 中的机器人几何和组织。 具体参考: 官方教程 完整语法 # describe: # Parameters: name=\"\" # Child node: # Description: # Parameters：name=\"\" # Child node: # describe: # Parameters: # child nodes: # description # parameters # Child node: # Description: # Parameters: # length=\"0.6\" # radius=\"0.2\" # description # Parameters:size=\"0.6 0.1 0.2\" # Description #Parameters: filename=\"package://urdf_tutorial/meshes/l_finger_tip.dae\" # Description: collision element, prioritized # parameters # child node # description # parameters # Child nodes: # description: mass # Parameters: value=10 # Description: Inertia # Parameters: i+\"Cartesian product of xyz\" (9 in total)=\"0.4\" # Description: # Parameters: # rpy=\"0 1.5 0\" # xyz=\"0 0 -0.3\" # Description # Parameters：name=\"blue\" # Description # Parameters： # name=\"\" # type=\"\" # fixed # prismatic # child node # Description # Parameters：link=\"\" # Description： # Parameters：link=\"\" # Description： # Parameters：xyz=\"0 -0.2 0.25\" # Description # Parameters： # effort=\"1000.0\" maximum effort # lower=\"-0.38\" Joint upper limit (radians) # upper=\"0\" Joint lower limit (radians) # velocity=\"0.5\" Maximum velocity # Description： Press ? axis rotation # Parameters：xyz=\"0 0 1\"，along the Z axis # Description： # Parameters：name=\"blue\" # child node： # description： # Parameters：rgba=\"0 0 0.8 1\" 安装依赖库 sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher sudo apt install ros-foxy-xacro 下载源代码 cd ~/dev_ws git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial 编译源代码 colcon build --packages-select urdf_tutorial 运行示例 ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf Launch ROS 2 中的启动系统负责帮助用户描述他们系统的配置，然后按照描述执行。 系统的配置包括要运行的程序、运行它们的位置、传递给它们的参数，以及 ROS 特定的约定，这些约定通过为每个组件提供不同的配置，使得在整个系统中重用组件变得容易。 它还负责监视已启动流程的状态，并报告和/或响应这些流程状态的变化。 用 Python、XML 或 YAML 编写的launch文件可以启动和停止不同的节点，以及触发和处理各种事件。 具体参考: 官方教程 Setup 创建一个新目录来存储您的launch文件： mkdir launch 编写启动文件 让我们使用 turtlesim 包及其可执行文件将 ROS 2 启动文件放在一起。 正如刚才提到的。 将完整代码复制并粘贴到 launch/turtlesim_mimic_launch.py 文件中： from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package='turtlesim', namespace='turtlesim1', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', namespace='turtlesim2', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', executable='mimic', name='mimic', remappings=[ ('/input/pose', '/turtlesim1/turtle1/pose'), ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) 运行ros2启动文件 要运行上面创建的launch文件，请进入您之前创建的目录并运行以下命令： 语法格式为： ros2 launch cd launch ros2 launch turtlesim_mimic_launch.py launch 帮助 ros2 launch -h 运行节点 ros2 launch turtlesim multisim.launch.py 查看launch文件有哪些参数 ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments ros2 launch turtlebot3_bringup robot.launch.launch.py -s 运行launch文件带参数 ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr 运行节点并调试 ros2 launch turtlesim turtlesim_node.launch.py -d 只输出节点描述 ros2 launch turtlesim turtlesim_node.launch.py -p 运行组件 ros2 launch composition composition_demo.launch.py Run run用于运行单个节点，组件程序。 run 帮助 ros2 run -h 运行节点 ros2 run turtlesim turtlesim_node 运行节点带参数 ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2 运行组件容器 ros2 run rclcpp_components component_container 运行组件 ros2 run composition manual_composition Package 一个包可以被认为是你的 ROS 2 代码的容器。 如果您希望能够安装您的代码或与他人共享，那么您需要将其组织在一个包中。 借助软件包，您可以发布您的 ROS 2 作品并允许其他人轻松构建和使用它。 ROS 2 中的包创建使用 ament 作为其构建系统，并使用 colcon 作为其构建工具。 您可以使用官方支持的 CMake 或 Python 创建包，但确实存在其他构建类型。 具体参数: 官方教程 创建工作空间 为每个新工作区创建一个新目录。 名称并不重要，但它有助于表明工作区的用途。 让我们为“开发工作区”选择目录名称 ros2_ws： mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src pkg 帮助 ros2 pkg -h 列出功能包 ros2 pkg executable turtlesim 输出某个功能包可执行程序 ros2 pkg executable turtlesim 创建Python功能包 在运行包创建命令之前，请确保您位于 src 文件夹中。 cd ~/ros2_ws/src 在 ROS 2 中创建新包的命令语法是： ros2 pkg create --build-type ament_python # 您将使用可选参数 --node-name 在包中创建一个简单的 Hello World 类型可执行文件。 ros2 pkg create --build-type ament_python --node-name my_node my_package 构建package 将包放在工作区中特别有价值，因为您可以通过在工作区根目录中运行 colcon build 来一次构建许多包。 否则，您将不得不单独构建每个包。 # 返回到工作区目录： cd ~/ros2_ws # 现在你可以构建你的包： colcon build Source setup文件 要使用您的新包和可执行文件，首先打开一个新终端并获取您的主要 ROS 2 安装源。 然后，从 ros2_ws 目录中，运行以下命令来获取您的工作空间： source install/setup.bash 现在您的工作区已添加到您的路径中，您将能够使用新包的可执行文件。 使用 package 要运行您在包创建期间使用 --node-name 参数创建的可执行文件，请输入以下命令： ros2 run my_package my_node ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.3-rivzIntroductionAndUse/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.3-rivzIntroductionAndUse/","title":"6.2.3 Rviz2介绍以及使用","keywords":"","body":"rviz2的简单介绍及使用 rviz是ROS中一款三维可视化平台，一方面能够实现对外部信息的图形化显示，另外还可以通过 rviz 给对象发布控制信息，从而实现对机器人的监测与控制。 rviz2的简介 ros2安装成功表明rviz2也一起安装成功了，因为ros2的安装包含了rviz2。 打开一个一个新的终端(快捷键Ctrl+Alt+T)输入命令打开rviz2 rviz2 打开rviz2,显示如下界面： 各个区域介绍 左侧为显示器列表，显示器是在3D世界中绘制某些内容的东西，并且可能在显示列表中具有一些可用的选项。 上方是工具栏，允许用户用各种功能按键选择多种功能的工具 中间部分为3D视图: 它是可以用三维方式查看各种数据的主屏幕。3D视图的背景颜色、固定框架、网格等可以在左侧显示的全局选项（Global Options）和网格（Grid）项目中进行详细设置。 下方为时间显示区域，包括系统时间和ROS时间等。 右侧为观测视角设置区域，可以设置不同的观测视角。 本部分我们只进行粗略的介绍，如果您想了解更多详细的内容，可以前往用户指南进行查看。 mycobot_ros2安装与更新 请查看 ROS2的安装 章节末尾。 简单使用 通过launch.py文件启动 本例子建立在您已经完成环境搭建，并成功将本公司的代码从GitHub上复制下来的基础上。 打开一个控制台终端(快捷键Ctrl+Alt+T) 输入一下命令进行ROS2的环境配置。 cd ~/colcon_ws colcon build --symlink-install source install/setup.bash 再输入： mycobot 280-M5版本： ros2 launch mycobot_450 test.launch.py 打开rviz2，并得到如下结果： 如果您想了解更多rviz的相关资料信息，您可以前往官方文档进行查看 mycobot pro 450版本前提条件 Ctrl+Alt+T )，打开终端窗口查看设备名称： ```bash # 查看机械臂的设备名称 ls /dev/ttyUSB* # 旧版本 myCobot280 M5 # 如果终端没有显示/dev/ttyUSB相关名称，需要使用如下命令 ls /dev/ttyACM* # 新版本 myCobot280 M5 ``` - 授予机械臂串口权限： ```bash # 默认设备名是/dev/ttyUSB0，如果设备名不是默认值，需要修改。 sudo chmod 777 /dev/ttyUSB0 # 旧版本 myCobot280 M5 sudo chmod 777 /dev/ttyACM0 # 新版本 myCobot280 M5 ``` 然后输入用户密码（**注意：** 输入密码是不显示的，输入正确即可）。 --> 450系列rviz使用指南 机械臂的控制 滑块控制 打开一个命令行，运行： 接着你可以**通过拖动滑块来控制 rviz 中的模型移动**。真实的 mycobot 将跟着一起运动. **请注意：由于在命令输入的同时机械臂会移动到模型目前的位置，在您使用命令之前请确保rviz中的模型没有出现穿模现象** **不要在连接机械臂后做出快速拖动滑块的行为，防止机械臂损坏** --> 模型跟随 GUI 控制 --> 键盘控制 命令行中将会输出 mycobot 信息，如下： ```bash [INFO] [launch]: All log files can be found below /home/elephant/.ros/log/2022-05-19-16-25-45-949761-elephant-virtual-machine-19111 [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [19114] [INFO] [rviz2-2]: process started with pid [19116] [INFO] [follow_display-3]: process started with pid [19118] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link joint2 had 1 children [robot_state_publisher-1] Link joint3 had 1 children [robot_state_publisher-1] Link joint4 had 1 children [robot_state_publisher-1] Link joint5 had 1 children [robot_state_publisher-1] Link joint6 had 1 children [robot_state_publisher-1] Link joint6_flange had 0 children [robot_state_publisher-1] [INFO] [1652948746.290904045] [robot_state_publisher]: got segment joint1 [robot_state_publisher-1] [INFO] [1652948746.290967253] [robot_state_publisher]: got segment joint2 [robot_state_publisher-1] [INFO] [1652948746.290973124] [robot_state_publisher]: got segment joint3 [robot_state_publisher-1] [INFO] [1652948746.290977490] [robot_state_publisher]: got segment joint4 [robot_state_publisher-1] [INFO] [1652948746.290981670] [robot_state_publisher]: got segment joint5 [robot_state_publisher-1] [INFO] [1652948746.290985737] [robot_state_publisher]: got segment joint6 [robot_state_publisher-1] [INFO] [1652948746.290989943] [robot_state_publisher]: got segment joint6_flange [follow_display-3] [INFO] [1652948746.664601707] [follow_display]: port:/dev/ttyUSB0, baud:115200 [rviz2-2] [INFO] [1652948746.828773551] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1652948746.830452458] [rviz2]: OpenGl version: 4.1 (GLSL 4.1) [rviz2-2] [INFO] [1652948746.874021926] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] Parsing robot urdf xml string. ``` 接着，打开另一个命令行，运行： - mycobot 280-M5版本： ```bash ros2 run mycobot_280 teleop_keyboard ``` 你会在命令行中看到如下输出： ```bash Mycobot Teleop Keyboard Controller --------------------------- Movimg options(control coordinations [x,y,z,rx,ry,rz]): w(x+) a(y-) s(x-) d(y+) z(z-) x(z+) u(rx+) i(ry+) o(rz+) j(rx-) k(ry-) l(rz-) Gripper control: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Resave home pose q - Quit currently: speed: 10 change percent: 2 ``` 在该终端中，您可以通过命令行中的按键控制机械臂的状态和对机械臂进行移动操作。 --> 末端执行器 支持的末端执行器： myCobot垂直吸泵V2.0、摄像头法兰 适用设备： myCobot 280 M5、myCobot 280 PI、myCobot Pro 450 myCobot垂直吸泵V2.0 加载模型 --> 滑块控制 注意：该功能仅支持对机械臂的控制 打开一个命令行，运行： 接着你可以**通过拖动滑块来控制 rviz 中的模型移动**。真实的 mycobot 将跟着一起运动. **请注意：由于在命令输入的同时机械臂会移动到模型目前的位置，在您使用命令之前请确保rviz中的模型没有出现穿模现象** **不要在连接机械臂后做出快速拖动滑块的行为，防止机械臂损坏** --> 3 GUI控制 在前面的基础上，本包还提供了简单的 Gui 控制界面。 该方式意在于真实机械臂相互联动，请连接 mycobot。 打开命令行： --> 摄像头法兰 加载模型 打开一个命令行，运行： --> 滑块控制 注意：该功能仅支持对机械臂的控制 打开一个命令行，运行： 接着你可以**通过拖动滑块来控制 rviz 中的模型移动**。真实的 mycobot 将跟着一起运动. **请注意：由于在命令输入的同时机械臂会移动到模型目前的位置，在您使用命令之前请确保rviz中的模型没有出现穿模现象**。 **不要在连接机械臂后做出快速拖动滑块的行为，防止机械臂损坏**。 --> 5.3 摄像头法兰 && 吸泵 1 加载模型 打开一个命令行，运行： --> URDF模型地址 1 myCobot 垂直吸泵V2.0 myCobot Pro 450 版本 2 摄像头法兰 myCobot Pro 450 版本 3 摄像头法兰 && 吸泵 myCobot Pro 450 版本 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.4-Moveit2/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.2-ROS2/6.2.4-Moveit2/","title":"6.2.4 Moveit2介绍以及使用","keywords":"","body":"MoveIt2 MoveIt2 简介 MoveIt2 是ROS2中的一个集成开发平台，由多种用于操纵机械臂的功能包组成，包括：运动规划、操作、控制、逆运动学、3D感知和碰撞检测等。 核心功能 运动规划（Motion Planning）MoveIt 2 提供基于 OMPL（Open Motion Planning Library）和其他第三方库的运动规划能力，支持多种规划算法和约束。 逆向运动学（Inverse Kinematics, IK）MoveIt 2 使用插件机制支持不同的 IK 解算器，能够快速计算机械臂的目标位姿。 碰撞检测与避免（Collision Detection & Avoidance）MoveIt 2 内置强大的碰撞检测功能，确保机器人在规划和执行运动时不会与周围环境发生碰撞。 动态场景感知（Dynamic Scene Awareness）MoveIt 2 支持动态更新环境模型，可以实时感知障碍物的变化。 控制与执行（Control & Execution）MoveIt 2 提供运动控制接口，与机器人硬件紧密集成，确保规划路径可以准确执行。 可视化工具（Visualization Tools）与 RViz 2 集成，支持直观的交互和调试功能，可以实时显示运动规划和执行过程。 MoveIt 2 的优势 基于 ROS 2 的实时性支持ROS 2 的 DDS 通信架构赋能 MoveIt 2，在实时性和可靠性上有显著提升。 模块化设计MoveIt 2 采用模块化架构，支持用户根据需要加载或替换模块，提供极大的灵活性。 跨平台支持MoveIt 2 支持在多种操作系统（如 Ubuntu、Windows）和硬件平台上运行。 活跃的社区支持MoveIt 2 拥有一个全球化的开发者社区，持续提供更新、功能扩展和技术支持。 配置 URDF - 通用机器人描述格式。 SRDF - 包括机器人的关节组、虚拟关节和被动关节、机器人姿势、自碰撞，通常由用户使用 MoveIt2 设置助手创建。 MoveIt2 配置 - 包括关节限制、运动学、运动规划、感知和其他信息。这些组件的配置文件由MoveIt2设置助手自动生成 (MoveIt2配置助手)，并存储在机器人的相应MoveIt2配置包的配置目录中。 如何使用MoveIt2 注意： 为了更好的运动规划效果，机械臂末端Atom固件版本为6.5，python驱动库pymycobot版本为3.5.3 mycobot_ros2 现已集成了 MoveIt2 部分。 打开命令行运行： ros2 lanuch mycobot_280_moveit2 demo.launch.py 运行效果如下： 如果需要让真实的机械臂同步执行计划，需要再打开一个命令行，运行： ros2 run mycobot_280_moveit2_control sync_plan 案例演示： ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/","title":"6.3 基于C++ 开发使用","keywords":"","body":"C++ 使用c++语言，您可以通过我们公司开发的c++动态库，进行自由开发（坐标控制、角度控制、io控制、夹爪控制等），控制我们公司已经研发出来的部分机器人。 C++是什么？ C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。 C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C++不仅拥有计算机高效运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。 适用设备： myCobot 280 myCobot 280 M5 myCobot 280 for Arduino myCobot 320 myCobot 320 M5 myCobot Pro 450 编程开发 部分集成开发环境（IDE) Visual Studio (Visual C++) Dev C++ C++ Builder 编译器 Ultimate++ Digital Mars C-Free MinGW C++开发使用引导 您可以根据以下指引来使用 C++对我们的机械臂进行开发 1.环境搭建 2.编译运行 3.关节控制 4.坐标控制 5.IO控制 6.夹爪控制 7.api说明 8.使用案例 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.1-download.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.1-download.html","title":"6.3.1 环境搭建","keywords":"","body":"C++ 环境搭建 确认开发目标 MycobotCpp是一个和mycobot进行串口通讯的接口程序，调用的是我们公司自己开发的mycobot库，里面有简单的使用案例。如果您想通过c++进行自由开发，控制我们公司已经研发出来的机器人，那么它是您的选择。 支持的机械臂型号：myCobot 280-M5、myCobot 320-M5、myCobot Pro 450 运行MycobotCpp所需要的软件：vs2019、qt5.12.10、vsaddin（qt插件）。 Windows环境配置 安装vs2019 下载： 首先在官网下载vs2019。 安装： 安装完成后，会出现下图所示界面，主要选择“通用Windows平台开发、使用C++的桌面开发、ASRNET和Web开发”这3个（此处只是建议，具体可根据自己的需求选择，vs2019安装时间较长）。 环境变量配置： 此电脑--》右键 属性--》高级系统设置--》环境变量--》看系统变量处，点击新建--》变量名：VCINSTALLDIR 变量值：找到Redist所在目录(如：D:\\vs2019\\VC），具体如下图所示： 安装qt5.12.10 下载： 下载qt5.12.10及以上版本都可以，具体操作如下图： 安装： 首先登录qt账号，没有就先注册。接下来会出现选择组件的界面，windows上选择MinGW和MSVC即可，具体如下图所示： 环境变量配置： 此电脑--》右键 属性--》高级系统设置--》环境变量--》看系统变量处，点击新建--》变量名：QTDIR 变量值：msvc2017_64所在目录（如：D:\\qt5.12.10\\5.12.10\\msvc2017_64，具体看自己电脑的安装路径），具体如下图所示： 安装qt插件vsaddin 下载： 首先选择对应vs2019的vsaddin版本,具体操作如下图： 安装：直接安装即可 配置： vs2019菜单栏 扩展--》QT VS ToolS--》QT Versions--》add new qtversion Path选择msvc2017_64所在路径（如：D:\\qt5.12.10\\5.12.10\\msvc2017_64），具体操作如下图所示： Linux环境配置 安装qt5.12.10 下载： 下载地址和Windows一样，选择linux上的安装包即可，具体可看上面的8.1.2.2。 安装： 命令行安装：运行./“安装包名称”，如果没有执行权限，加执行权限：sudo chmod +x “安装包名称”，然后进入图形界面，和Windows一样； 图形界面安装：和Windows一样。 建议直接普通用户权限安装qt，安装成功后可以执行qmake --version，出现如下界面安装成功： 配置： 打开配置文件，普通用户安装qt：vi ~/.bashrc，root用户安装qt：vi ~/.profile。在配置文件中添加：export QTDIR=“qt所在目录”（如：export QTDIR=$HOME/Qt/5.12.10/gcc_64），具体如下图所示： ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.2-build.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.2-build.html","title":"6.3.2 编译运行","keywords":"","body":"myCobotCpp编译运行 下载 源码下载 github上下载MycobotCpp。 动态库下载 依赖库下载（下载最新版本，注意选择Windows或者Linux，后缀.zip为Windows所需要的库，.tar.gz为Linux需要的库） Windows下运行 编译 vs2019打开MycobotCpp,选择x64-Release编译（启动项旁边，如果没有，点击下拉框--》管理配置进行添加），同时cmake设置的配置处也要选择release，最后点击生成。注意：一定选择x64-Release进行编译，具体如下图所示： 运行 添加库文件：将.lib添加到myCobotCpp/lib，.lib和.dll添加到myCobotCppExample.exe同级目录下，如out/build/x64-Release/bin（.lib和.dll这两个文件在myCobotCpp-0.0.3-windows-msvc-x86_64.zip压缩包内） 运行：选择启动项（绿色播放键旁，也就是运行按钮旁），下拉选择myCobotCppEXample.exe(bin\\myCobotCppExample.exe)，点击运行，具体如下图所示： 常见问题及解决办法： 运行时错误： 如果myCobotCpp.dll缺失，将之前放到lib目录下的myCobotCpp.dll放到mycobotcppexample.exe所在目录下 如果报缺少QT5Core.dll，打开qt command（菜单栏搜索QT），选择msvc 2017 64-bit，执行windeployqt --release myCobotCppExample.exe所在目录（如：windeployqt --release D:\\vs2019\\myCobotCpp\\out\\build\\x64-Release\\bin） 此处执行命令后如果报找不到vs安装路径，请检查vs环境变量的设置 以上步骤执行后，如果报缺少qt5serialport.dll文件，将qt安装目录处的此文件(路径如：D:\\qt5.12.10\\5.12.10\\msvc2017_64\\bin)，拷贝到myCobotCppExample.exe所在目录 Linux下运行 编译构建 mkdir build && cd build cmake .. cmake --build .运行 复制所有.so文件到lib目录下 命令行运行：./bin/myCobotCppExample（此处是在build目录下运行） 在Ubuntu20.04上运行 编译 mkdir build && cd build cmake .. cmake --build .运行 复制所有.so文件到lib目录下（注意下载后解压，不要在Windows解压后复制到Ubuntu，直接在Ubuntu解压，如：tar -xvf 然后直接拖动文件到终端） 将libQt5SerialPort.so.5(在QT安装目录，如：/home/“用户名”/Qt5.12.10/5.12.10/gcc_64/lib)软链接到mycobotcpp/build/bin（不要直接复制），命令如下（注意选择你们的路径）：ln -s /home/“用户名”/Qt5.12.10/5.12.10/gcc_64/lib/libQt5SerialPort.so.5 /home/“用户名”/myCobotCpp/build/bin/libQt5SerialPort.so.5 常见问题及解决办法 编译时出错： 找不到QTDIR。解决：查看QTDIR是否配置正确，可在命令行输出查看：echo $QTDIR 运行时出错： 串口问题：无法打开串口。解决：修改机械臂串口权限，不能直接chmod...，这样每次重启都要再次该权限。直接修改文件： cd /etc/udev/rules.d sudo gedit 20-usb-serial.rules 在文件在加入：KERNEL==\"ttyUSB*\" MODE=\"0777\" 找不到文件问题：如无法打开或者找不到libQt5SerialPort.so.5。解决：检查上面的运行步骤2 注意 如果不使用cmake编译，如直接在MFC中使用，按下图所示进行配置： ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.3-angle.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.3-angle.html","title":"6.3.3 关节控制","keywords":"","body":"关节控制 对于串联式多关节机器人，关节控制是针对机械臂各个关节的变量进行的控制，目标是让机械臂各个关节按照一定速度达到目标位置。 单关节控制 发送单关节角度 WriteAngle(Joint joint, double value, int speed = DefaultSpeed) 返回值：无 参数说明：参数1：关节号（1-6） 参数2：角度(-170°- 170°) 参数3：速度(0-100)，默认为30 示例： mycobot::MyCobot::I().WriteAngle(mycobot::Joint::J1, 10, 30); 多关节控制 获取全部关节角度 GetAngles() 返回值：Angles类型 参数说明：无 示例： mycobot::Angles angles= mycobot::MyCobot::I().GetAngles(); 发送全部关节角度 WriteAngles(const Angles& angles, int speed = DefaultSpeed) 返回值：无 参数说明：参数1：全部角度（std::array,角度取值范围-170°- 170°） 参数2：速度(0-100)，默认为30 示例： mycobot::Angles goal_angles = { 5, 5, 5, 5, 5, 5 }; mycobot::MyCobot::I().WriteAngles(goal_angles, 30); 完整使用案例 下面这段代码是一个控制 MyCobot 机械臂的程序，它负责检查控制器连接、启动和停止机械臂、获取机械臂状态、设置关节角度并在出现异常时处理错误。 int main(int argc, char* argv[]) try { QCoreApplication a(argc, argv); // 创建 QCoreApplication 对象，用于支持 Qt 事件循环 using namespace std::chrono_literals; // 引入时间单位字面量（如 200ms） // 检查机械臂控制器是否连接 if (!mycobot::MyCobot::I().IsControllerConnected()) { std::cerr ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.4-coord.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.4-coord.html","title":"6.3.4 坐标控制","keywords":"","body":"坐标控制 坐标控制是让机械臂以指定姿态移动到指定点，分为x，y，z，rx，ry，rz。X，Y，Z 表示的是机械臂头部在空间中的位置（该坐标系为直角坐标系），rx，ry，rz表示的是机械臂头部在该点的姿态（该坐标系为欧拉坐标）。 单参数控制 发送单参数坐标 WriteCoord(Axis axis, double value, int speed = DefaultSpeed) 返回值：无 参数说明：参数1：坐标号（Axis枚举类型，int：1-6（X-RZ）），参数2：坐标（X、Y、Z取值范围 -300-300.00 单位 mm RX、RY、RZ,取值范围-180-180），参数3：速度(0-100)，默认为30 示例： mycobot::MyCobot::I().WriteCoord(mycobot::Axis::X, 10, 30); 多参数控制 获取全部坐标 GetCoords() 返回值：Coords类型 参数说明：无 示例： mycobot::Coords coords = mycobot::MyCobot::I().GetCoords(); 发送全部坐标 WriteCoords(const Coords& coords, int speed = DefaultSpeed) 返回值：无 参数说明：参数1：坐标（X、Y、Z取值范围 -300-300.00 单位 mm RX、RY、RZ,取值范围-180-180） 参数2：速度(0-100)，默认为30 示例： mycobot::Coords goal_coords = { 5, 5, 5, 5, 5, 5 }; mycobot::MyCobot::I().WriteCoords(goal_coords, 30); 完整使用案例 下面这段代码是一个控制 MyCobot 机械臂的控制程序的主要入口。在这个程序中，程序首先检查控制器是否连接到机械臂。如果连接成功，程序会将机械臂上电并停止当前的动作。接下来，它会获取并输出机械臂的当前角度和坐标，并尝试将所有关节移动到指定的目标角度。程序在目标角度就位前，会持续输出当前的角度信息。最后，程序对某个关节进行角度调整，并在调整后停止机械臂的动作。如果过程中发生错误，程序会捕获异常并退出。 int main(int argc, char* argv[]) try { QCoreApplication a(argc, argv); // 创建一个 QCoreApplication 对象以支持 Qt 事件循环 using namespace std::chrono_literals; // 引入用于时间处理的字面量（如 200ms） // 检查机械臂控制器是否连接 if (!mycobot::MyCobot::I().IsControllerConnected()) { std::cerr ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.5-io.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.5-io.html","title":"6.3.5 IO控制","keywords":"","body":"io控制 机械臂底部M5Stack-basic和末端Atom上都有引脚，可以通过io控制设置引脚的高低电平，控制系泵等工具，各个机械臂类型输入输出引脚号请看下面的说明表： 底部M5Stack-basic输入输出引脚说明表： 机械臂型号 输入引脚号 输出引脚号 myCobot 280-M5 35、36 2、5、26 末端Atom输入输出引脚说明表： 机械臂型号 输入引脚号 输出引脚号 myCobot 280-M5 19、22 23、33 basic io控制（m5) 设置输出io高低电平 SetBasicOut(int pin_number, int pin_signal) 返回值：无 参数说明：参数1：引脚号（basic输出引脚号），参数2：状态（0--低电平，1--高电平） 案例： mycobot::MyCobot::I().SetBasicOut(2, 1); 获取输入io状态 GetBasicIn(int pin_number) 返回值：引脚状态（0--低电平，1--高电平） 参数说明：引脚号（basic输入引脚号） 案例：设置输出引脚2为高电平 mycobot::MyCobot::I().GetBasicIn(35); Atom io控制 设置输出io高低电平 SetDigitalOut(int pin_number, int pin_signal) 返回值：无 参数说明：参数1：引脚号（atom输出引脚号），参数2：状态（0--低电平，1--高电平） 案例： mycobot::MyCobot::I().SetDigitalOut(23, 1); 获取输入io状态 GetDigitalIn(int pin_number) 返回值：引脚状态（0--低电平，1--高电平） 参数说明：引脚号（atom输入引脚号） 案例： mycobot::MyCobot::I().GetDigitalIn(19); 完整使用案例 int main(int argc, char* argv[]) try { QCoreApplication a(argc, argv); using namespace std::chrono_literals; if (!mycobot::MyCobot::I().IsControllerConnected()) { std::cerr ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.6-gripper.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.6-gripper.html","title":"6.3.6 夹爪控制","keywords":"","body":"夹爪控制 夹爪安装： 自适应夹爪将夹爪插在atom上面的引脚上，具体看下图： 电动夹爪插在顶端上的接口处，具体看下图： 注意：myCobot 280-m5无电动夹爪，只有myCobot 320-m5有电动夹爪。 自适应夹爪控制 支持设备：myCobot280、320&&myPalletizer 260 SetGriper(int open) 返回值：无 参数说明：夹爪开关状态（0--关，1--开） 案例：由于延迟，第一次控制夹爪，可能不成功，建议发送两次 for (int i = 0; i mycobot::MyCobot::I().SetGriper(1); mycobot::MyCobot::I().SleepSecond(3); mycobot::MyCobot::I().SetGriper(0); mycobot::MyCobot::I().SleepSecond(3); } 完整使用案例 int main(int argc, char* argv[]) try { QCoreApplication a(argc, argv); using namespace std::chrono_literals; if (!mycobot::MyCobot::I().IsControllerConnected()) { std::cerr ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.7-API.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.7-API.html","title":"6.3.7 api说明","keywords":"","body":"myCobot API 在使用下列函数接口的时候请先导入我们的API库，否则无法运行成功，库的下载以及导入请看编译运行章节内容。 实例化MyCobot 1.1 I(); 功能：实例化MyCobot 返回值：MyCobot类型，myCobot对象的单例实例 参数说明：无 注意：在调用下面的API时，不需要在单独实例化，调用此API即可 机器人整体运行状态 Overall Status 2.1 PowerOn(); 功能：机械臂上电 返回值：无 参数说明：无 注意：机械臂上电后，无法手动移动机械臂 2.2 PowerOff(); 功能：机械臂掉电 返回值：无 参数说明：无 注意：机械臂上电后，如果想要手动移动机械臂，可以调用此API 2.3 SetFreeMoveMode(bool free_move = true); 功能：设置自由移动模式 返回值：无 参数说明：开启还是关闭自由移动，true--开启自由移动，false--关闭自由自动 注意：自由自动开启后，可以手动移动机械臂，同时atom上面的灯会变成黄色，关闭会变成绿色 2.4 IsFreeMoveMode() 功能：检测当前是否为自由移动模式 返回值：bool类型，true-开启了自由移动，false-自由移动未开启 参数说明：无 2.5 IsControllerConnected(); 功能：检测系统是否正常 返回值：无 参数说明：bool类型，返回false将无法控制机械臂 输入程序控制模式 MDI Mode and Robot Control (Manual Data Input) 3.1 IsInPosition(const Coords& coords, bool is_linear = true); 功能：检查机械臂是否到达指定的点位（角度或者坐标） 返回值：bool类型，返回false--未到达指定点位，返回true--到达指定点位 参数说明：参数1：所有角度或者坐标 参数2：0或者1（坐标为1（true)，角度为0(false)） 3.2 IsMoving(); 功能：检测机械臂是否正在运动 返回值：bool类型,true--正在运动，false--未运动 参数说明：无 3.3 WriteAngle(Joint joint, double value, int speed = DefaultSpeed) 功能：发送单关节角度 返回值：无 参数说明：参数1：关节号（1-6） 参数2：角度(-170°- 170°) 参数3：速度(0-100)，默认为30 3.4 GetAngles() 功能：获取全部关节角度 返回值：Angles类型 参数说明：无 3.5 WriteAngles(const Angles& angles, int speed = DefaultSpeed) 功能：发送全部关节角度 返回值：无 参数说明：参数1：全部角度（std::array,角度取值范围-170°- 170°） 参数2：速度(0-100)，默认为30 3.6 WriteCoord(Axis axis, double value, int speed = DefaultSpeed) 功能：发送单参数坐标 返回值：无 参数说明：参数1：坐标号（Axis枚举类型，int：1-6（X-RZ）），参数2：坐标（X、Y、Z取值范围 -300-300.00 单位 mm RX、RY、RZ,取值范围-180-180），参数3：速度(0-100)，默认为30 3.7 GetCoords() 功能：获取全部坐标 返回值：Coords类型 参数说明：无 3.8 WriteCoords(const Coords& coords, int speed = DefaultSpeed) 功能：发送全部坐标 返回值:无 参数说明：参数1：坐标（X、Y、Z取值范围 -300-300.00单位 mm RX、RY、RZ,取值范围-180-180），参数2：速度(0-100)，默认为30 3.9 StopRobot() 功能：机械臂停止运动 当机械臂运动时，可以调用此API，让机械臂停止运动 返回值：无 参数说明：无 运行辅助信息 Running Status and Settings 4.1 GetSpeed() 功能：获取机械臂运动的速度 返回值：int类型，机械臂运动速度（0-100） 参数说明：无 4.2 SetSpeed(int percentage) 功能：设置机械臂运动的速度 返回值：无 参数说明：机械臂移动速度（0-100） 4.3 GetJointMin(Joint joint) 功能：读取关节最小角度 返回值：double类型，最小角度（关节最小能运行到的角度） 参数说明：关节号（1-6） 4.4 GetJointMax(Joint joint); 功能：读取关节最大角度 返回值：double类型，最大角度（关节最大能运行到的角度） 参数说明：关节号（1-6） 4.5 SleepSecond(unsigned time) 功能：等待 返回值：无 参数说明：时间单位为秒 JOG运行与操作 JOG mode and operation 5.1 JogCoord(Axis axis, int direction, int speed = DefaultSpeed) 功能：使机械臂朝坐标轴方向运动 返回值:无 参数说明：参数1：坐标号（1-6，x y z rx ry rz)，参数2：方向(1--正方向，0--反方向），参数3：速度（默认为30，范围：0-100） 注意：此API会让机械臂一直朝坐标轴正反方向运动，到达限位后或者中途调用JogStop才会停止运动 5.2 JogAngle(Joint joint, int direction, int speed = DefaultSpeed) 功能：使某个关节运动直至Jogstop或是到达限位 返回值：无 参数说明：参数1：关节号（1-6），参数2：方向（1--正方向，0--反方向），参数3：速度（默认30，范围：0-100） 注意：此API会让机械臂关节一直朝正反方向运动，到达限位后或者中途调用JogStop才会停止运动 5.3 JogCoordAbsolute(Axis axis, double value, int speed = DefaultSpeed) 功能：使某个坐标轴运动至给定坐标 返回值：无 参数说明：参数1：坐标号（1-6，x y z rx ry rz)，参数2：坐标（X、Y、Z取值范围 -300-300.00 单位 mm RX、RY、RZ,取值范围-180-180），参数3：速度（默认30，范围：0-100） 5.4 JogAngleAbsolute(Joint joint, double value, int speed = DefaultSpeed) 功能：使某个关节运动至给定角度 返回值：无 参数说明：参数1：关节号（1-6），参数2：角度（范围：-170-170），参数3：速度（默认30，范围0-100） 5.5 JogCoordIncrement(Axis axis, double increment, int speed = DefaultSpeed) 功能：使某个坐标运动设定的坐标增量 返回值：无 参数说明：参数1：坐标号（1-6， x y z rx ry rz），参数2：坐标增量值，参数3：速度（默认30，范围：0-100） 注意：机械臂进行步进运动：比如当前x轴坐标为100，增量值为50，运动完后，x轴坐标将为150 5.6 JogAngleIncrement(Joint joint, double increment, int speed = DefaultSpeed) 功能：使某个关节运动设定的角度增量 返回值：无 参数说明：参数1：关节号（1-6），参数2：关节增量值，速度（默认30，范围：0-100） 注意：机械臂进行步进运动：比如当前关节1坐标为-100，增量值为50，运动完后，关节1将为50 Atom 末端IO控制 Atom IO Control 6.1 SetDigitalOut(int pin_number, int pin_signal) 功能：设置输出io高低电平 返回值：无 参数说明：参数1：引脚号（atom输出引脚号），参数2：状态（0--低电平，1--高电平） 6.2 GetDigitalIn(int pin_number) 功能：获取输入io状态 返回值：引脚状态（0--低电平，1--高电平） 参数说明：引脚号（atom输入引脚号） 6.3 SetGriper(int open) 功能：控制自适应夹爪 返回值：无 参数说明：夹爪开关状态（0--关，1--开） 6.4 SetElectricGriper(int open) 功能：控制电动夹爪 返回值：无 参数说明：夹爪开关状态（0--关，1--开） 底座M5Stack-basicIO控制 M5Stack-basic IO Control 7.1 SetBasicOut(int pin_number, int pin_signal) 功能：设置输出io高低电平 返回值：无 参数说明：参数1：引脚号（basic输出引脚号），参数2：状态（0--低电平，1--高电平） 7.2 GetBasicIn(int pin_number) 功能：获取输入io状态 返回值：引脚状态（0--低电平，1--高电平） 参数说明：引脚号（basic输入引脚号） ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.8-example.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.3-Cplus/6.3.8-example.html","title":"6.3.8 使用案例","keywords":"","body":"使用案例 这段代码是一个控制 MyCobot 机械臂的程序，主要包括对机械臂控制器的连接检测、机械臂的基本动作控制（如上电、停止、设置输出引脚、获取输入引脚状态）、以及关节角度的设定和检查等功能。程序还包括异常处理，以确保在发生错误时程序能够正确退出。 项目中的myCobotExample.cpp为使用案例，您可以根据需要在此基础上进行修改： int main(int argc, char* argv[]) try { QCoreApplication a(argc, argv); // 创建 QCoreApplication 对象，用于支持 Qt 事件循环 using namespace std::chrono_literals; // 引入时间单位字面量（如 200ms） // 检查机械臂控制器是否连接 if (!mycobot::MyCobot::I().IsControllerConnected()) { std::cerr 代码中的关键功能解释： 连接检测：首先检查 MyCobot 机械臂的控制器是否连接成功，未连接则退出程序。 机械臂上电：如果连接成功，机械臂上电并启动，随后设置机械臂上的输出引脚。 IO 引脚控制：控制 M5 和 atom 的输入输出引脚，通过设置或读取这些引脚的电平来进行特定的硬件控制操作（如输出信号或读取状态）。 夹爪控制：通过注释掉的代码可以看到如何控制自适应夹爪和电动夹爪的开合。 关节角度控制：设置机械臂的目标角度，并监控其是否已经移动到目标位置，程序持续输出机械臂的 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/6-SoftwareDevelopment/6.4-CommunicationProtocolPackage/6.4-communication.html":{"url":"3-FunctionsAndApplications/6-SoftwareDevelopment/6.4-CommunicationProtocolPackage/6.4-communication.html","title":"6.4 基于通信协议包开发","keywords":"","body":"通信与报文命令 注意：使用通信协议直接通信，需要在basic中烧录transponder，在atom中烧录最新版的atomMain 机械臂运动参数 关节 *关节最小值° 关节最大值° 关节最大速度°/s 关节最大加速度°/s² J1 -360 360 120 200 J2 -135 135 120 200 J3 -135 135 120 200 J4 -150 150 120 200 J5 -360 360 120 200 J6 -360 360 120 200 Axis *关坐标最小值mm 坐标最大值mm 坐标最大速度mm/s 坐标最大加速度mm/s² x -281.45 281.45 100 400 y -281.45 281.45 100 400 z -70 412.76 100 400 rx -180° 180° 40° 66°/s² ry -180° 180° 40° 66°/s² rz -180° 180° 40° 66°/s² USB通信设置Communication Settings 请确保您的通信设置如下 总线接口： USB Type-C连接 波特率： 115200 数据位： 8 奇偶校验：无 停止位： 1 命令帧说明及单一指令解析 主机Basic向从机发送数据，从机接收到数据后进行解析，如包含返回值的指令，从机会在500ms内返回给主机。 命令帧发送与接收格式 所有命令为十六进制，发送与接收格式一致。 每个通信命令必须包含以下5个部分，其中3、4可为空。 1 命令针头: 0xFE 0xFE 固定 必含 2 有效命令长度: 0x02 ~ 0x10 以下所有命令的长度 必含 3 命令序号: 00 ~ 8F 现已开发了多种命令 可为空 4 命令内容: 若干 可为空 5 命令结束: 0XFA 固定 必含 指令解析 主机Basic向从机发送数据，从机接收到数据后进行解析，如包含返回值的指令，从机会在500ms内返回给主机。 类型 数据描述 数据长度 说明 命令帧 头字节0 1 帧头识别，0XFE 头字节1 1 帧头识别，0XFE 数据长度字节 1 不同指令对应不同长度数据 命令字节 1 视不同命令而定 数据帧 数据 0-16 命令附带数据，视不同命令而定 结束帧 结束字节 1 停止位，0XFA 单一指令解析 机械臂上电 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X10 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 10 FA 无返回值 机械臂掉电并断开连接 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X11 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 11 FA 无返回值 Atom状态查询 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X12 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 12 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X12 Data[4] 上电/断电 0X01/0X00 Data[5] 结束帧 0XFA 假设Atom处于上电状态 串口返回示例：FE FE 03 12 01 FA 机械臂仅掉电 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X13 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 13 FA 无返回值 机器人系统检测正常 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X14 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 14 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X14 Data[4] 正常连接/断开连接 0X01/0X00 Data[5] 结束帧 0XFA 假设Atom连接成功 串口返回示例：FE FE 03 14 01 FA 指令刷新模式开关（设置插补/刷新运动模式） 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X16 Data[4] 指令帧 0X01/0X00 Data[5] 结束帧 0XFA 设置为刷新运动模式： 串口发送示例：FE FE 03 16 01 FA 设置为插补运动模式： 串口发送示例：FE FE 03 16 00 FA 机器人自由模式(关闭所有扭力输出) 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X1A Data[4] 打开/关闭 01/00 Data[5] 结束帧 0XFA 设置为自由移动运动模式： 串口发送示例：FE FE 03 1A 01 FA 检查是否是自由模式 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X1B Data[5] 结束帧 0XFA 串口发送示例：FE FE 02 1B FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X1B Data[4] 打开/关闭 0X01/0X00 Data[5] 结束帧 0XFA 假设Atom处于自由移动模式 串口返回示例：FE FE 03 1B 01 FA 读取角度（读取走位信息） 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X20 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 20 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X0E Data[3] 返回指令帧 0X20 Data[4] 1号舵机角度高位 Angle1_high Data[5] 1号舵机角度低位 Angle1_low Data[6] 2号舵机角度高位 Angle2_high Data[7] 2号舵机角度低位 Angle2_low Data[8] 3号舵机角度高位 Angle3_high Data[9] 3号舵机角度低位 Angle3_low Data[10] 4号舵机角度高位 Angle4_high Data[11] 4号舵机角度低位 Angle4_low Data[12] 5号舵机角度高位 Angle5_high Data[13] 5号舵机角度低位 Angle5_low Data[14] 6号舵机角度高位 Angle6_high Data[15] 6号舵机角度低位 Angle6_low Data[16] 结束帧 0XFA 串口返回示例：FE FE 0E 20 00 8C 00 3D FF E6 FF 3F 00 AF FF 51 FA 如何得出1号关节角度 temp = angle1_low+angle1_high*256 Angle1=（temp \\ 33000 ?(temp – 65536) : temp）/100 计算方式：角度值低位 + 角度高位值乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以100 如果小于33000就直接除以100 （其余同理） 发送单独角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X06 Data[3] 指令帧 0X21 Data[4] 舵机序号 joint_no Data[5] 角度值高位 angle_high Data[6] 角度值低位 angle_low Data[7] 指定速度 sp Data[8] 结束帧 0XFA 使1号舵机以20%速度移动到零位 串口发送示例：FE FE 06 21 01 00 00 14 FA joint_no取值范围: 1~6 angle_high：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的高字节 angle_low：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的低字节 无返回值 发送全部角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0F Data[3] 指令帧 0X22 Data[4] 1号舵机角度值高字节 Angle1_high Data[5] 1号舵机角度值低字节 Angle1_low Data[6] 2号舵机角度值高字节 Angle2_ high Data[7] 2号舵机角度值低字节 Angle2_ low Data[8] 3号舵机角度值高字节 Angle3_ high Data[9] 3号舵机角度值低字节 Angle3_ low Data[10] 4号舵机角度值高字节 Angle4_ high Data[11] 4号舵机角度值低字节 Angle4_ low Data[12] 5号舵机角度值高字节 Angle5_ high Data[13] 5号舵机角度值低字节 Angle5_ low Data[14] 6号舵机角度值高字节 Angle6_ high Data[15] 6号舵机角度值低字节 Angle6_ low Data[16] 指定速度 Sp Data[17] 结束帧 0XFA 发送全部角度均为零/让机械恢复到零位，以30%速度移动 串口发送示例：FE FE 0F 22 00 00 00 00 00 00 00 00 00 00 00 00 1E FA angle1_high：数据类型byte 计算方式：1号舵机角度值乘以100 先转换成int形式 再取十六进制的高字节 angle1_low：数据类型byte 计算方式：1号舵机角度值乘以100 先转换成int形式 再取十六进制的低字节 （其余同理） 无返回值 读取全部坐标 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X23 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 23 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X0E Data[3] 返回指令帧 0X23 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 结束帧 0XFA 串口返回示例：FE FE 0E 23 01 BC FD A0 10 15 DC 66 FF 54 DE 21 FA 如何得出x坐标 temp = x_low + x_high*256 x坐标=（temp \\ 33000 ?(temp – 65536) : temp）/10 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以10 如果小于33000就直接除以10 （y坐标z坐标同理） 如何得出rx坐标 temp = rx_low + rx_high*256 rx坐标=（temp \\ 33000 ?(temp – 65536) : temp）/100 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以100 如果小于33000就直接除以100 （ry坐标rz坐标同理） 发送单独坐标参数 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X06 Data[3] 指令帧 0X24 Data[4] axis x/y/z/rx/ry/rz Data[5] 指定xyz/rxryrz参数高位 xyz/ rxryrz_high Data[6] 指定xyz/rxryrz参数低位 xyz/rxryrz_low Data[7] 指定速度 Sp Data[8] 结束帧 0XFA 设定X坐标为200，目标速度为20 串口发送示例：FE FE 06 24 01 07 D0 14 FA 指定坐标axis：数据类型byte 取值范围：1~6 xyz_high：数据类型byte 计算方式：x/y/z坐标值乘以10 再取十六进制的高字节 xyz_low：数据类型byte 计算方式：x/y/z坐标值乘以10 再取十六进制的低字节 rxryrz_high：数据类型byte 计算方式：rx/ry/rz乘以100 再取十六进制的高字节 rxryrz_low：数据类型byte 计算方式：rx/ry/rz乘以100 再取十六进制的低字节 无返回值 发送全部坐标参数 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X10 Data[3] 指令帧 0X25 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 指定速度 Sp Data[17] 模式 0X01 Data[18] 结束帧 0XFA 设定机械臂末端目标点位（150.3，-68.7，101.8，10.18，0，-90），目标速度10 串口发送示例：FE FE 10 25 05 DF FD 51 03 FA BC 30 00 00 DC D8 0A 01 FA x_high：数据类型byte 计算方式：x坐标乘以10 再取十六进制的高字节 x_low：数据类型byte 计算方式：x坐标乘以10 再取十六进制的低字节 （y轴坐标z轴坐标同理） rx_high：数据类型byte 计算方式：rx坐标值乘以100 再取十六进制的高字节 rx_low：数据类型byte 计算方式：rx坐标值乘以100 再取十六进制的低字节 （ry轴坐标rz轴坐标同理） 无返回值 程序暂停 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X26 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 26 FA 无返回值 程序是否暂停 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X27 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 27 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X27 Data[4] 暂停/未暂停 0X01/0X00 Data[5] 结束帧 0XFA 假设程序处于暂停状态 串口返回示例：FE FE 03 27 01 FA 程序恢复 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X28 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 28 FA 无返回值 程序停止 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X29 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 29 FA 无返回值 是否达到点位 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0E/0X0F Data[3] 指令帧 0X2A Data[4] 坐标x高位/1号舵机角度值高字节 x_high/Angle1_high Data[5] 坐标x低位/1号舵机角度值低字节 x_low/Angle1_low Data[6] 坐标y高位/2号舵机角度值高字节 y_high/Angle2_high Data[7] 坐标y低位/2号舵机角度值低字节 y_low/Angle2_low Data[8] 坐标z高位/3号舵机角度值高字节 z_high/Angle3_high Data[9] 坐标z低位/3号舵机角度值低字节 z_low/Angle3_low Data[10] 坐标rx高位/4号舵机角度值高字节 rx_high/Angle4_high Data[11] 坐标rx低位/4号舵机角度值低字节 rx_low/Angle4_low Data[12] 坐标ry高位/5号舵机角度值高字节 ry_high/Angle5_high Data[13] 坐标ry低位/5号舵机角度值低字节 ry_low/Angle5_low Data[14] 坐标rz高位/6号舵机角度值高字节 rz_high/Angle6_high Data[15] 坐标rz低位/6号舵机角度值低字节 rz_low/Angle6_low Data[16] 坐标/角度 0X01/0X00 Data[17] 结束帧 0XFA 判断机械臂是否到达原点 串口发送示例： FE FE 0F 2A 00 00 00 00 00 00 00 00 00 00 00 00 00 FA x_high：数据类型byte 计算方式：x坐标乘以10 先转换为int类型 再取十六进制高字节 x_low：数据类型byte 计算方式：x坐标乘以10 先转换为int类型 再取十六进制低字节 （y轴坐标z轴坐标同理） rx_high：数据类型byte 计算方式：rx坐标乘以100 先转换为int类型 再取十六进制高字节 rx_low：数据类型byte 计算方式：rx坐标乘以100 先转换为int类型 再取十六进制低字节 （ry轴坐标rz轴坐标同理） angle_high：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的高字节 angle_low：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的低字节 Type：数据类型byte（暂未使用） 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X2a Data[4] 到达点位/未到达点位 0X01/0X00 Data[5] 结束帧 0XFA 假设机械臂未到达指定点位 串口返回示例：FE FE 03 2A 00 FA 机械臂运动检测 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X2B Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 2B FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X2B Data[4] 运动中/未运动 0X01/0X00 Data[5] 结束帧 0XFA 假设程序处于运动状态 串口返回示例：FE FE 03 2B 01 FA jog-关节方向运动 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X30 Data[4] 关节舵机序号 Joint Data[5] 关节舵机方向 direction Data[6] 指定速度 sp Data[7] 结束帧 0XFA 设定1号舵机顺时针方向以20%速度转动 串口发送示例： FE FE 05 30 01 01 14 FA 关节序号取值范围: 1~6 di：数据类型byte 取值范围 0和1 sp：数据类型byte 取值范围0-100 无返回值 jod-绝对控制 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X06 Data[3] 指令帧 0X31 Data[4] 关节舵机序号 Joint Data[5] 关节舵机角度值高字节 Angle_high Data[6] 关节舵机角度值低字节 Angle_low Data[7] 指定速度 sp Data[8] 结束帧 0XFA 设定1号舵机转到45°，速度20 串口发送示例： FE FE 06 31 01 11 94 14 FA 关节序号取值范围: 1~6 Angle_high：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的高字节 Angle_low：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的低字节 sp：数据类型byte 取值范围0-100 无返回值 jog-坐标方向运动 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X32 Data[4] 指定坐标 axis Data[5] 关节舵机方向 di Data[6] 指定速度 sp Data[7] 结束帧 0XFA 设定机械臂往x方向运动，速度20 串口发送示例： FE FE 05 32 01 01 14 FA axis 取值范围: 1~6，分别代表x,y,z,rx,ry,rz di：数据类型byte 取值范围 0和1 sp：数据类型byte 取值范围0-100 无返回值 jog-步进模式 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X06 Data[3] 指令帧 0X33 Data[4] 关节舵机序号 Joint Data[5] 关节舵机角度值高字节 Angle_high Data[6] 关节舵机角度值低字节 Angle_low Data[7] 指定速度 sp Data[8] 结束帧 0XFA 设定1号舵机角度增加45，以20%速度转动 串口发送示例： FE FE 06 33 01 11 94 14 FA 关节序号取值范围: 1~6 Angle_high：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的高字节 Angle_low：数据类型byte 计算方式：角度值乘以100 先转换成int形式 再取十六进制的低字节 sp：数据类型byte 取值范围0-100 无返回值 发送电位值 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X06 Data[3] 指令帧 0X3A Data[4] 关节舵机序号 Joint Data[5] 电位值高位 Encoder_high Data[6] 电位值低位 Encoder_low Data[7] 指定速度 sp Data[8] 结束帧 0XFA 示例，设定5号关节到2048电位，以20%速度转动 串口发送示例： FE FE 06 3A 05 08 00 14 FA 关节序号取值范围:1~6 Joint：数据类型byte Encoder_high：数据类型byte 计算方式：取电位值（十六进制）的高位 Encoder_low：数据类型byte 计算方式：取电位值值（十六进制）的低位 无返回值 获取电位值 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X3B Data[4] 关节序号 joint Data[5] 结束帧 0XFA 获取2号舵机电位值 串口发送示例： FE FE 03 3B 02 FA 关节序号取值范围：1-6 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X04 Data[3] 返回指令帧 0X3B Data[4] 舵机电位值高位 Encoder_high Data[5] 舵机电位值低位 Encoders_low Data[6] 结束帧 0XFA 串口返回示例： FE FE 04 3B 08 07 FA 如何计算电位值 电位值 = 电位值低位 + 电位值高位 * 256 发送六个舵机的电位值 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0F Data[3] 指令帧 0X3C Data[4] 1号舵机电位值高字节 encoder_1_high Data[5] 1号舵机电位值低字节 encoder_1_low Data[6] 2号舵机电位值高字节 encoder_2_high Data[7] 2号舵机电位值低字节 encoder_2_low Data[8] 3号舵机电位值高字节 encoder_3_high Data[9] 3号舵机电位值低字节 encoder_3_low Data[10] 4号舵机电位值高字节 encoder_4_high Data[11] 4号舵机电位值低字节 encoder_4_low Data[12] 5号舵机电位值高字节 encoder_5_high Data[13] 5号舵机电位值低字节 encoder_5_low Data[14] 6号舵机电位值高字节 encoder_6_high Data[15] 6号舵机电位值低字节 encoder_6_low Data[16] 指定速度 Sp Data[17] 结束帧 0XFA 发送所有电机的电位值均为2048，速度为20 串口发送示例：FE FE 0F 3C 08 00 08 00 08 00 08 00 08 00 08 00 14 FA （参考上方发送单独电位值） encoder_1_high：数据类型byte 计算方式： 1号舵机电位值先转换为int类型 再取十六进制高字节 encoder_1_low：数据类型byte 计算方式： 1号舵机电位值先转换为int类型 再取十六进制低字节 （其余同理） Sp：数据类型byte 取值范围：0~100 无返回值 读取六个舵机的电位值 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X3D Data[4] 结束帧 0XFA 串口发送示例： FE FE 02 3D FA 返回数据结构 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0E Data[3] 指令帧 0X3D Data[4] 1号舵机电位值高字节 encoder_1_high Data[5] 1号舵机电位值低字节 encoder_1_low Data[6] 2号舵机电位值高字节 encoder_2_high Data[7] 2号舵机电位值低字节 encoder_2_low Data[8] 3号舵机电位值高字节 encoder_3_high Data[9] 3号舵机电位值低字节 encoder_3_low Data[10] 4号舵机电位值高字节 encoder_4_high Data[11] 4号舵机电位值低字节 encoder_4_low Data[12] 5号舵机电位值高字节 encoder_5_high Data[13] 5号舵机电位值低字节 encoder_5_low Data[14] 6号舵机电位值高字节 encoder_6_high Data[15] 6号舵机电位值低字节 encoder_6_low Data[16] 结束帧 0XFA 假设当前机械臂各关节都处于0位 串口返回示例： FE FE 0E 3D 08 00 08 00 08 00 08 00 08 00 08 00 FA 如何计算电位值 电位值 = 电位值低位 + 电位值高位 * 256 设置速度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X41 Data[4] 指定速度 sp Data[5] 结束帧 0XFA Sp：数据类型byte 取值范围：0~100 设定当前速度为50% 串口发送示例：FE FE 03 41 32 FA 无返回值 读取关节最小角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X4A Data[4] 关节舵机序号 Joint_number Data[5] 结束帧 0XFA 读取2号关节最小角度 串口发送示例： FE FE 03 4A 02 FA joint_no取值范围：1-6 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X05 Data[3] 返回指令帧 0X4A Data[4] 关节舵机序号 Joint_number Data[5] 舵机角度值高位 Angle_high Data[6] 舵机角度值低位 Angle_low Data[7] 结束帧 0XFA 串口返回示例： FE FE 05 4A 02 F9 F2 FA 如何得出关节最小角度 temp = angle1_low+angle1_high*256 Angle1=（temp \\ 33000 ?(temp – 65536) : temp）/10 计算方式：角度值低位 + 角度高位值乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以10 如果小于33000就直接除以10 读取关节最大角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X4B Data[4] 关节舵机序号 joint_number Data[5] 结束帧 0XFA joint_no取值范围：1-6 读取2号关节的最大角度 串口发送示例： FE FE 03 4B 02 FA 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X05 Data[3] 返回指令帧 0X4B Data[4] 关节舵机序号 joint_number Data[5] 舵机角度值高位 Angle_high Data[6] 舵机角度值低位 Angle_low Data[7] 结束帧 0XFA 串口返回示例： FE FE 05 4B 02 06 72 FA 如何得出关节最大角度 temp = angle1_low+angle1_high*256 Angle1=（temp \\ 33000 ?(temp – 65536) : temp）/10 计算方式：角度值低位 + 角度高位值乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以10 如果小于33000就直接除以10 设置关节最小角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X4C Data[4] 关节舵机序号 Joint_number Data[5] 关节舵机角度值高字节 Angle_high Data[6] 关节舵机角度值低字节 Angle_low Data[7] 结束帧 0XFA 设置2号关节最小角度为0 joint_no取值范围：1-6 angle1_high：数据类型byte 计算方式：舵机角度值乘以100 先转换成int形式 再取十六进制的高字节 angle1_low：数据类型byte 计算方式：舵机角度值乘以100 先转换成int形式 再取十六进制的低字节 串口发送示例： FE FE 05 4C 02 00 00 FA 无返回值 设置关节最大角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X4D Data[4] 关节舵机序号 Joint_number Data[5] 关节舵机角度值高字节 Angle_high Data[6] 关节舵机角度值低字节 Angle_low Data[7] 结束帧 0XFA 设置2号关节最大角度为45 joint_no取值范围：1-6 angle1_high：数据类型byte 计算方式：舵机角度值乘以100 先转换成int形式 再取十六进制的高字节 angle1_low：数据类型byte 计算方式：舵机角度值乘以100 先转换成int形式 再取十六进制的低字节 串口发送示例： FE FE 05 4C 02 11 94 FA 无返回值 查看连接 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X50 Data[4] 关节舵机序号 Joint_number Data[5] 结束帧 0XFA joint_no取值范围：1-6 查看1号舵机是否连接 串口发送示例：FE FE 03 50 01 FA 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X04 Data[3] 指令帧 0X50 Data[4] 关节舵机序号 Joint_number Data[5] 连接/未连接 0X01/0X00 Data[6] 结束帧 0XFA 1号舵机连接正常 串口返回示例：FE FE 04 50 01 01 FA 查看舵机是否全部上电 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X51 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 51 FA 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X03 Data[3] 指令帧 0X51 Data[4] 上电/未上电 0X01/0X00 Data[5] 结束帧 0XFA 并没有全部舵机上电 串口返回示例：FE FE 03 51 01 FA 读取伺服参数 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0X53 Data[4] 关节舵机序号 joint_no Data[5] 数据地址 data_id Data[6] 结束帧 0XFA 读取1号舵机位置P比例参数 串口发送示例：FE FE 04 53 01 15 FA joint_no取值范围 1~6 Data_id：数据类型byte，取值如下表 地址 功能 取值范围 初始值 取值解析 20 LED报警 0-254 0 1\\0 = 打开或关闭LED报警 21 位置环P 0-254 10 控制电机的比例系数 22 位置环I 0-254 0 控制电机的微分系数 23 位置环D 0-254 1 控制电机的积分系数 24 最小启动力 0-1000 0 设置最小输出力矩 1000 = 100% 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X03 Data[3] 返回指令帧 0X53 Data[4] 返回数据 data Data[5] 结束帧 0XFA 串口返回示例：FE FE 03 53 10 FA 设置舵机伺服参数 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X52 Data[4] 关节舵机序号 joint_no Data[5] 数据地址 data_id Data[6] 数据 data Data[7] 结束帧 0XFA 设置1号舵机位置P比例参数为1 串口发送示例：FE FE 05 52 01 15 01 FA joint_no取值范围:1~6 无返回值 data_id取值如下表 地址 功能 取值范围 初始值 取值解析 20 LED报警 0-254 0 1\\0 = 打开或关闭LED报警 21 位置环P 0-254 10 控制电机的比例系数 22 位置环I 0-254 0 控制电机的微分系数 23 位置环D 0-254 1 控制电机的积分系数 24 最小启动力 0-1000 0 设置最小输出力矩 1000 = 100% 设置舵机零点 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X54 Data[4] 关节舵机序号 joint_number Data[5] 结束帧 0XFA 设置1号舵机的零位 串口发送示例：FE FE 03 54 01 FA joint_number:1~6 无返回值 刹车单个电机 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X55 Data[4] 关节舵机序号 joint_number Data[5] 结束帧 0XFA 刹车1号舵机 joint_number:1~6 串口发送示例：FE FE 03 55 01 FA 无返回值 单个电机掉电 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X56 Data[4] 舵机序号 Servo_no Data[5] 结束帧 0XFA 让3号舵机掉电 串口发送示例：FE FE 03 56 03 FA Servo_no：1~6 无返回值 单个电机上电 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X57 Data[4] 舵机序号 Servo_no Data[5] 结束帧 0XFA 给1号舵机上电 串口发送示例：FE FE 03 57 01 FA Servo_no:1~6 无返回值 设置atom引脚模式 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0X60 Data[4] 引脚序号 pin_no Data[5] 输入/输出 00X00/00X01 Data[6] 结束帧 0XFA 设置atom pin22为输入模式 串口发送示例：FE FE 04 60 16 00 FA Pin_no：数据类型byte Pin_mode：0/1 无返回值 设置Atom IO(setDigitalOutput) 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0X61 Data[4] 引脚序号 Pin_no Data[5] 电平信号 0X00/0X01 Data[6] 结束帧 0XFA 设置引脚P23为高电平 串口发送示例：FE FE 04 61 17 01 FA 无返回值 读取Atom IO(getDigitalInput) 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X62 Data[4] 引脚序号 pin_no Data[5] 结束帧 0XFA 读取引脚P22的电平信号 串口发送示例：FE FE 03 62 16 FA 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X04 Data[3] 返回指令帧 0X62 Data[4] 引脚序号 pin_no Data[5] 电平信号 0X00/0X01 Data[6] 结束帧 0XFA 假设引脚P22为高电平 串口返回示例：FE FE 04 62 16 01 FA 读取夹爪角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X65 Data[6] 结束帧 0XFA 串口发送示例：FE FE 02 65 FA 返回数据结构 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X65 Data[4] 夹爪张开幅度 value Data[6] 结束帧 0XFA value：0-100% 假设夹爪处于全张开状态 串口返回示例：FE FE 03 65 64 FA 夹爪张开大小 = 6 * 16 + 4 = 100 设置夹爪模式 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0X66 Data[4] 夹爪张开/收拢 0X00/0X01 Data[5] 速度 Sp Data[6] 结束帧 0XFA 设置夹爪以50速度张开 串口发送示例：FE FE 04 66 00 32 FA 无返回值 设置夹爪角度 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0X67 Data[4] 夹爪张开幅度 value Data[6] 速度 Sp Data[7] 结束帧 0XFA 假设夹爪张开50%，速度为20 串口发送示例：FE FE 04 67 32 14 FA value直接换算成16进制即可 无返回值 夹爪设置零点 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X68 Data[4] 结束帧 0XFA 设置夹爪当前位置为零点 串口发送示例：FE FE 02 68 FA 检测夹爪是否运动 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X69 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 69 FA 返回数据结构 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X69 Data[4] 停止/运动 00/01 Data[5] 结束帧 0XFA 假设夹爪处于停止状态 串口返回示例：FE FE 03 69 00 FA 设定atom屏幕RGB灯的颜色 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X05 Data[3] 指令帧 0X6A Data[4] R 0X00/0XFF Data[5] G 0X00/0XFF Data[6] B 0X00/0XFF Data[7] 结束帧 0XFA 设置RGB为蓝色 串口发送示例：FE FE 05 6A 00 00 FF FA 无返回值 设置底座IO输出 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0Xa0 Data[4] 引脚序号 Pin_no Data[5] 电平信号 0X00/0X01 Data[6] 结束帧 0XFA 设置引脚2输出高电平 串口发送示例：FE FE 04 a0 02 01 FA 读取底座IO输入 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0Xa1 Data[4] 引脚序号 Pin_no Data[5] 结束帧 0XFA 串口发送示例：FE FE 03 a1 02 FA 返回数据结构 数据域 说明 数据 Data[0] 返回识别帧 0XFE Data[1] 返回识别帧 0XFE Data[2] 返回数据长度帧 0X04 Data[3] 返回指令帧 0Xa1 Data[4] 引脚序号 Pin_no Data[5] 电平信号 0X00/0X01 Data[6] 结束帧 0XFA 假设引脚2为高电平 串口返回示例：FE FE 04 a1 02 01 FA 获取WiFi账号&密码 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0Xb1 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 b1 FA 串口返回示例：ssid: MyCobotWiFi2.4G password: mycobot123 ssid：WiFi账号 password：WiFi密码 设置端口号 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X04 Data[3] 指令帧 0Xb2 Data[4] 端口号高字节 port_high Data[5] 端口号低字节 port_low Data[6] 结束帧 0XFA 假设设置端口号为7000 串口发送示例：FE FE 04 b2 1b 58 FA port_high：端口号十六进制高字节 port_low：端口号十六进制低字节 无返回值 设置工具坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0E Data[3] 指令帧 0X81 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 结束帧 0XFA 假设设置（0，0，50，0，0，0）为工具坐标系 串口发送示例：FE FE 0E 81 00 00 00 00 13 88 00 00 00 00 00 00 FA 无返回值 获取工具坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X82 Data[6] 结束帧 0XFA 串口发送示例：FE FE 02 82 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X0E Data[3] 返回指令帧 0X82 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 结束帧 0XFA 串口返回示例：FE FE 0E 82 00 00 00 00 13 88 00 00 00 00 00 00 FA 如何得出x坐标 temp = x_low + x_high*256 x坐标=（temp \\ 33000 ?(temp – 65536) : temp）/10 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以10 如果小于33000就直接除以10 （y坐标z坐标同理） 如何得出rx坐标 temp = rx_low + rx_high*256 x坐标=（temp \\ 33000 ?(temp – 65536) : temp）/100 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以100 如果小于33000就直接除以100 （ry坐标rz坐标同理） 设置世界坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X0E Data[3] 指令帧 0X83 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 结束帧 0XFA 假设设置（0，0，50，0，0，0）为世界坐标系 串口发送示例：FE FE 0E 83 00 00 00 00 13 88 00 00 00 00 00 00 FA 无返回值 获取世界坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X84 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 82 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X0E Data[3] 返回指令帧 0X84 Data[4] 指定x坐标高位 x_high Data[5] 指定x坐标低位 x_low Data[6] 指定y坐标高位 y_high Data[7] 指定y坐标低位 y_low Data[8] 指定z坐标高位 z_high Data[9] 指定z坐标低位 z_low Data[10] 指定rx坐标高位 rx_high Data[11] 指定rx坐标低位 rx_low Data[12] 指定ry坐标高位 ry_high Data[13] 指定ry坐标低位 ry_low Data[14] 指定rz坐标高位 rz_high Data[15] 指定rz坐标低位 rz_low Data[16] 结束帧 0XFA 串口返回示例：FE FE 0E 84 00 00 00 00 13 88 00 00 00 00 00 00 FA 如何得出x坐标 temp = x_low + x_high*256 x坐标=（temp \\ 33000 ?(temp – 65536) : temp）/10 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以10 如果小于33000就直接除以10 （y坐标z坐标同理） 如何得出rx坐标 temp = rx_low + rx_high*256 x坐标=（temp \\ 33000 ?(temp – 65536) : temp）/100 计算方式：x坐标值低位 +x坐标值高位乘以256 先判断是否大于33000 如果大于33000就再减去65536 最后除以100 如果小于33000就直接除以100 （ry坐标rz坐标同理） 设置基坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X85 Data[4] 基坐标/世界坐标 00/01 Data[5] 结束帧 0XFA 假设设置坐标系为世界坐标系 串口发送示例：FE FE 03 85 01 FA 无返回值 获取基坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X86 Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 86 FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X86 Data[4] 基坐标/世界坐标 00/01 Data[4] 结束帧 0XFA 串口返回示例：FE FE 03 86 01 FA 设置末端坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X03 Data[3] 指令帧 0X89 Data[4] 法兰/工具 00/01 Data[5] 结束帧 0XFA 假设设置末端坐标系为工具 串口发送示例：FE FE 03 89 01 FA 无返回值 获取末端坐标系 数据域 说明 数据 Data[0] 识别帧 0XFE Data[1] 识别帧 0XFE Data[2] 数据长度帧 0X02 Data[3] 指令帧 0X8a Data[4] 结束帧 0XFA 串口发送示例：FE FE 02 8a FA 返回数据结构 数据域 说明 数据 Data[0] 返回帧头 0XFE Data[1] 返回帧头 0XFE Data[2] 返回长度帧 0X03 Data[3] 返回指令帧 0X8a Data[4] 法兰/工具 00/01 Data[4] 结束帧 0XFA 串口返回示例：FE FE 03 8a 01 FA 附录： 在ATOM库和运动学库中添加了相应的坐标变换程序，具体实现方式如下所述： 改变末端坐标系 通过setEndType和getEndType函数可以设置末端坐标系，EndType::FLANGE为将末端设置为法兰，EndType::TOOL为将末端设置为工具末端。 通过setToolReference和getToolReference函数可以设置读取工具的坐标信息。设置时是以法兰坐标系为相对坐标系，工具末端信息是相对于法兰坐标系的。 将EndType设置为FLANGE后，GetCoords和WriteCoords方法均以法兰位置计算。 将EndType设置为TOOL后，GetCoords和WriteCoords方法均以工具末端位置计算。 改变基坐标系 通过setReferenceFrame函数可以设置基坐标系，RFType::BASE为将机器人基座作为基坐标，RFType::WORLD为将世界坐标系作为基坐标。getReferenceFrame函数为读取当前基坐标系种类。 通过setWorldReference和getWorldReference函数可以设置读取基坐标系信息。设置时是以世界坐标系为相对坐标系，输入机器人的基座相对于世界坐标系的位置信息。 当基坐标系为基座时，GetCoords和WriteCoords方法均以基座为参考坐标系。 当基坐标系为世界坐标系时，GetCoords和WriteCoords方法均以世界坐标系作为参考坐标系。 通信相关更改（暂时） 现增加末端坐标系的设置与读取，世界坐标系的设置与读取，当前参考坐标系的设置与读取，末端类型的设置与读取，移动方式的设置与读取，机械臂信息的发送接收。 这些通信暂时设置为0x80至0x8A 在ParameterList.h文件中新增roboticMessages空间用于添加机械臂通信信息，现只暂时增加“没有逆解”的提示，后续可陆续增加。 MOVEL功能简单设计思想如下： 求出初始点位和目标点位之间的欧式距离，以欧式距离为基准，每隔10mm插入一个插值点，如果插值点没有逆解，搜索位置不变三个方向姿态正负PI/30的临近空间内是否有逆解，主要是避免奇异值以及一些恰好不能求出解的特殊位置。 MOVEL和JOG的点位发送间隔时间改为动态时间，根据两点之间最大关节移动距离计算移动时间，再讲该移动时间减去特定时长作为时间间隔。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/7-ExamplesRobotsUsing/":{"url":"3-FunctionsAndApplications/7-ExamplesRobotsUsing/","title":"7 成功案例","keywords":"","body":"Introduction ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.1.html":{"url":"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.1.html","title":"7.1 机器人复合案例","keywords":"","body":""},"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.2.html":{"url":"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.2.html","title":"7.2 3D视觉无序分拣","keywords":"","body":""},"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.3.html":{"url":"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.3.html","title":"7.3 Lerobot ACT模仿学习","keywords":"","body":""},"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.4.html":{"url":"3-FunctionsAndApplications/7-ExamplesRobotsUsing/7.4.html","title":"7.4 DeepSeek 语音控制","keywords":"","body":""},"3-FunctionsAndApplications/8-FilesDownload/":{"url":"3-FunctionsAndApplications/8-FilesDownload/","title":"8 配套资源","keywords":"","body":"第八章 配套资源 本章节将详细介绍产品的各类配套资源，旨在帮助用户全面了解和高效使用我们的产品。无论是产品资料、图纸、软件资料及源码，还是系统资料和宣传资料，我们都提供了详尽的信息和下载链接，以确保用户能够充分利用这些资源进行产品开发、操作和推广 产品资料下载 产品资料包括myCobot Pro 450机械臂的详细规格、技术参数和使用说明。此部分内容旨在帮助用户全面了解机械臂的性能和功能，确保在使用过程中获得最佳体验 产品图纸 产品图纸部分提供了myCobot Pro 450机械臂的详细3D图和2D图。这些图纸对于需要进行定制化设计或进行维护的工程人员来说尤为重要，可以帮助他们更好地理解机械臂的构造。 软件资料及源码 软件资料及源码部分包含与myCobot Pro 450机械臂配套的软件安装包、驱动程序及相关的开源代码。用户可以通过这些资料进行软件安装、升级及二次开发，提升机械臂的功能和应用场景 系统资料 系统资料提供了myCobot Pro 450机械臂的系统架构和工作原理说明，涵盖硬件和软件的协同工作方式。此部分有助于用户在集成和调试过程中，快速定位和解决问题，确保系统稳定运行 (资料有待更新) 宣传资料 宣传资料部分包含myCobot Pro 450机械臂的产品宣传册、展示视频及客户案例。这些资料不仅展示了机械臂的核心优势和应用场景，还提供了实际应用中的成功案例，帮助潜在客户更直观地了解产品的价值。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/8-FilesDownload/8.1-ProductInformation/":{"url":"3-FunctionsAndApplications/8-FilesDownload/8.1-ProductInformation/","title":"8.1 产品资料","keywords":"","body":"产品资料下载 产品资料包括myCobot Pro 450机械臂的详细规格、技术参数和使用说明。此部分内容旨在帮助用户全面了解机械臂的性能和功能，确保在使用过程中获得最佳体验 下载链接 你可以通过以下链接下载所有相关的产品资料：产品资料下载 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/8-FilesDownload/8.2-ProductDrawings/":{"url":"3-FunctionsAndApplications/8-FilesDownload/8.2-ProductDrawings/","title":"8.2 产品图纸","keywords":"","body":"产品图纸 产品图纸部分提供了myCobot Pro 450机械臂的详细3D图和2D图。这些图纸对于需要进行定制化设计或进行维护的工程人员来说尤为重要，可以帮助他们更好地理解机械臂的构造。 机器3D模型 机器 3D模型文件 myCobot Pro 450 下载 机器2D图纸 机器 机器2D图纸 myCobot Pro 450 下载 配件3D模型 myCobot 系列 配件 3D模型文件 自适应夹爪 下载 力控夹爪 下载 气动夹爪 下载 手机支架 下载 3D相机 下载 独头吸泵 下载 模块化吸盘 下载 摄像头法兰 下载 笔夹持器 下载 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/8-FilesDownload/8.3-SoftwareInformationAndSourceCode/":{"url":"3-FunctionsAndApplications/8-FilesDownload/8.3-SoftwareInformationAndSourceCode/","title":"8.3 软件资料及源码","keywords":"","body":"软件资料及源码 软件资料及源码部分包含与myCobot Pro 450机械臂配套的软件安装包、驱动程序及相关的开源代码。用户可以通过这些资料进行软件安装、升级及二次开发，提升机械臂的功能和应用场景 你可以通过以下链接下载所有相关的产品资料：软件资料下载 软件下载链接包含以下常用软件 myStudio 2.0 一站式服务平台myStudio，整合myCobot软件资源及各类资料， 主要功能： 支持固件下载与更新; 提供产品使用视频教程； 维护/维修方面等信息； RoboFlow RoboFlow是一款可人机交互的操作软件，是我司为方便用户快速掌握机械臂的操作、使用而开 发。 通过简单的操作流程帮助用户高效率完成机械臂控制和编程工作。 myBlockly myBlockly是一个完全可视的模块化编程软件，属于图形化编程语言，适合初级用户熟悉编程。 使用者以拖拽拼图的方式开发出应用程序，即可创造出简单及复杂的功能。 Meta Care Meta Care是一款有趣的宠物模拟游戏，融合了宠物养育、故事和成就收集等元素。 -游戏需要全程联网。 -您需要拥有Meta Dog，并通过蓝牙与您的设备进行连接。 -游戏仅支持安卓设备。 Elephant Luban Elephant Luban 是一款G-Code轨迹生成使用平台，提供用户基础的使用案例，选择写字画 画， 激光雕刻使用场景，快速开启DIY创意空间。 MyCobot Controlle MyCobot Controller是一款通过蓝牙控制MyCobot系列机械臂的APP。 您可以使用手机移动 机械臂。如果您是安卓用户，请前往[Google Play Store] 如果您是IOS用户，请等待软件 发布后再搜索下载。 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/8-FilesDownload/8.4-SystemInformation/":{"url":"3-FunctionsAndApplications/8-FilesDownload/8.4-SystemInformation/","title":"8.4 系统资料","keywords":"","body":"系统资料 系统资料提供了myCobot Pro 450机械臂的系统架构和工作原理说明，涵盖硬件和软件的协同工作方式。此部分有助于用户在集成和调试过程中，快速定位和解决问题，确保系统稳定运行 ← 上一章 | 下一章 → "},"3-FunctionsAndApplications/8-FilesDownload/8.5-PromotionalMaterials/":{"url":"3-FunctionsAndApplications/8-FilesDownload/8.5-PromotionalMaterials/","title":"8.5 宣传资料","keywords":"","body":"宣传资料 宣传资料部分包含myCobot Pro 450机械臂的产品宣传册、展示视频及客户案例。这些资料不仅展示了机械臂的核心优势和应用场景，还提供了实际应用中的成功案例，帮助潜在客户更直观地了解产品的价值。 机器 产品画册 myCobot Pro 450 下载 产品开箱视频 产品开箱视频 产品宣传视频 产品宣传视频 用户案例 用户案例 ← 上一章 | 下一章 → "},"4-SupportAndService/9-AboutUs/9.AboutUs.html":{"url":"4-SupportAndService/9-AboutUs/9.AboutUs.html","title":"9 关于我们","keywords":"","body":"大象机器人 1. 公司介绍 大象机器人(Elephant Robotics)立足于中国·深圳，是一家专注于机器人研发设计及自动化解决方案的高新科技企业。 我们致力于为机器人教育及科研机构、商业场景、工业生产提供高柔性的协作机器人、简单易学的操作系统以及智能的自动化解决方案。其产品质量及智慧方案备受韩国、日本、美国、德国、意大利、希腊等数家来自世界 500 强名企工厂的一致认可与好评。 大象机器人秉持“Enjoy Robots World”的愿景，倡导人与机器人的协同工作，让机器人成为人类工作生活的好帮手，帮助人们从简单、重复、枯燥的工作中解放出来，充分发挥人机协同优势，进而提高工作效率，帮助人类缔造美好新生活。 未来，大象机器人希望通过新一代尖端科技推动机器人产业发展，携手与客户伙伴们共同开启自动化智能化新时代。 2. 发展历程 2016.08 -----大象机器人有限公司正式成立 2016.08 -----进入 HAX 孵化器，获得 SOSV 种子轮投资 2016.08 ----- 开始研发 Elephant S 工业协作机器人 2017.01 -----获评 “CES 中国最具创新企业 Top10” 2017.04 -----出席汉诺威工业博览会及韩国自动化展览会 2017.07 -----两位创始人入选福布斯亚洲评选的“30 位 30 岁以下商业精英” 2017.10 -----第五代单臂工业协作机器人 Elephant S 问世 2018.04 -----获得”云天使基金”天使轮投资 2018.06 -----首次公开亮相 2018 年汉诺威世界工业博览会 2018.06 -----获得长江商学院“智造创业 MBA 奖” 2018.06 -----获得清华经管“创业加速器 X-elerator 奖” 2018.11 -----获得亚洲智能硬件大赛深圳赛区第二名 2018.11 -----获得高工金球奖“最具投资企业奖” 2019.03 -----获得高工金球奖“领军人物奖” 2019.04 -----2019 年 3 月 Catbot 获“工业机器人创新奖” 2019.09 -----出席华为欧洲生态大会(HCE)，正式成为华为生态伙伴一员 2019.11 -----大象机器人携手哈工大出席 IROS 国际智能机器人与系统大会 2019.12 -----大象机器人-华南理工大学“智能机器人联合开发实验室”正式揭牌 2019.12 -----荣获高工 2019 年度“创新技术奖” 2019.12 -----荣获高工 2019 年度“十大快速成长企业” 2019.12 -----荣获深圳装备工业-工业机器人细分领域-“新锐企业奖” 2019.12 -----世界首款仿生机器猫 MarsCat 问世 2020.05 -----创始人获得 2019 年度深圳市机器人新锐人物奖 2020.10 -----全球最轻最小的六轴协作机器人 myCobot 问世 2021.03 -----面向科研的最小协作机器人 myCobotPro 320 问世 2021.05 -----火星仿生猫 MarsCat 获得新华财经、中国日报、南京日报、哈尔滨日报等多家媒体的竞相报道 2021.07 -----发布最小的复合机器人底盘 – 小象移动机器人 myAGV 2021.09 -----全球首款全包裹式的四轴机械臂-小象码垛机械臂 myPalletizer 问世 3. 相关链接 购买链接 淘宝：https://shop504055678.taobao.com Shopify： https://shop.elephantrobotics.com/ 速卖通：https://elephantrobotics.aliexpress.com/store/1101941423其他信息 官网： https://www.elephantrobotics.com 视频 Bilibili： https://space.bilibili.com/2126215657 Youtube： https://www.youtube.com/c/Elephantrobotics Facebook： https://www.facebook.com/mycobotcreator/ Linkedin： https://www.linkedin.com/company/18319865 X (Twitter)： https://twitter.com/CobotMy Discord： https://discord.gg/2MAherp7nt Hackster： https://www.hackster.io/elephant-robotics 4. 联系我们 我们的工作时间为中国工作日，北京时间上午 10 点至下午 6 点。 如果您有任何其他问题，请通过以下方式联系我们。E-mail : support@elephantrobotics.com - 如果您有购买意向或任何参数问题，请发送电子邮件至此邮箱。 [E-mail](sales@elephantrobotics.com) : sales@elephantrobotics.com 如您在使用本产品的过程中遇到使用问题，请先阅读手册第九章，如果列出的问题无法帮助您解决，而您又有更多的售后问题，请向本邮箱发送电子邮件。E-mail : support@elephantrobotics.com 我们将在 1-2 个工作日内给予答复； 微信:我们只为通过微信购买 mycobot 系列产品的用户提供一对一服务。 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/accessories.html":{"url":"4-SupportAndService/10-Accessories/accessories.html","title":"10 周边配件","keywords":"","body":"产品配件 在现实世界中，不同的配件能以各种方式增强机器人的能力。例如，夹爪、传感器和工具等配件可以帮助机器人执行各种任务，从而提高其多功能性和灵活性。 大象机器人致力于让每个人都能轻松使用机器人和这些配件，将用户从选择合适配件的复杂性中解放出来，使其能够迅速开始使用机器人。 配件类型 为了满足客户在不同场景下的需求，我们设计了各种类型的配件，包括夹爪、吸盘、摄像头模块和其他抓取装置，以便用户直接选择合适的末端执行器。 夹爪 力控夹爪 气动夹爪 自适应夹爪 吸泵 独头吸泵 模块化吸盘 夹持器 笔夹持器 手机夹持器 其余功能类配件 摄像头法兰 3D相机 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.1-myGripperF100.html":{"url":"4-SupportAndService/10-Accessories/10.1-myGripperF100.html","title":"10.1 力控夹爪","keywords":"","body":"myGripper F100 力控夹爪 1 产品图片 2 规格参数说明 名称 myGripper F100 力控夹爪 材料 PC、PBT 尺寸 156X106X61mm 工艺技术 注塑 夹取范围 0-100毫米（默认指尖） 重复性精度 0.5 mm 使用寿命 30万次开合 驱动模式 电驱动 传动方式 齿轮+连杆 尺寸 158x105x55mm 重量 340 g 额定负载 500g 工作电压 24V 固定方法 螺丝固定 使用环境要求 常温常压 控制接口 RS485/IO 控制/按键控制 适用设备 ER myCobot 320系列,ER Mercury系列,ER myCobot Pro 600,ERmyCobot Pro 630,ER myCobot Pro 450,其他通用机器人 3 工作原理 在电机的驱动下，机械手的手指表面做直线往复运动，实现打开或关闭动作。通过设置夹持力矩，使工件的冲击最小，定位点可控，夹紧可控。 4 使用场景 实验操作：在科研实验中，完成试管、器皿等的抓取和移动，确保实验的安全和准确性。 教育演示：作为教学工具，帮助学生理解机器人抓取原理，培养实践能力。 物料搬运：在模拟生产线或仓储中，搬运各种规格的物料，提高工作效率。 5 安装方式 用螺丝和垫片将夹爪连接件安装到机械臂末端法兰 再用螺丝将夹爪安装在连接件上 最后用M8航空线将夹爪和机械臂就行连接 6 python控制方式 基于450末端IO 控制 基于IO控制的方式只能控制夹爪全开全合 from pymycobot import ElephantRobot import time mc=ElephantRobot(\"192.168.1.159\",5001) mc.start_client() def gripper_open(): mc.set_digital_out(16,0) mc.set_digital_out(17,1) def gripper_close(): mc.set_digital_out(16,1) mc.set_digital_out(17,0) if __name__==\"__main__\": gripper_open() time.sleep(2) gripper_close() time.sleep(2) 基于USB转485模块控制 注意：使用该方式控制夹爪，需要将连接夹爪的M8航空线的一端接到USB转485模块上。即M8航空线带插头的一端连接夹爪，一端连接USB转485模块和24V电源。 接线说明： 连接夹爪端的 24V，GND, 485_A(T/R+,485+) , 485_B(T/R-,485-)共 4 根线，电源为24V直流稳压电源或是630底部IO的24V，将模块的 USB 插口插入到电脑的 USB 接口 485A 接入 485 转 USB 模块 A+; 485B 接入 485 转 USB 模块 B-; 24V 接入 24V 直流稳压电源正极/630底部IO的24V; GND 接入 24V 直流稳压电源负极/630底部IO的GND 驱动库安装 点击下载驱动库 串口依赖库安装 在电脑终端执行下面命令，安装依赖库 pip install pyserial API说明 get_firmware_version() 功能: 获取夹爪固件主版本号 参数: 无 返回: (int)固件主版本号 get_modified_version() 功能: 获取夹爪固件次版本号 参数: 无 返回: (int)固件次版本号 get_gripper_Id() 功能: 获取夹爪ID 参数: 无 返回: (int)夹爪ID get_gripper_baud() 功能: 获取夹爪波特率 参数: 无 返回:(int) 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 get_gripper_value() 功能: 获取夹爪的当前位置数据信息 参数: 无 返回: (int)夹爪的当前位置数据 get_gripper_status() 功能: 获取夹爪的当前状态 参数: 无 返回:(int) 0-3 0: 正在运动 1: 停止运动，未检测到夹到物体 2: 停止运动，检测到夹到了物体 3: 检测到夹到物体以后，物体掉落 get_gripper_speed() 功能: 获取夹爪的当前速度 参数: 无 返回: (int)夹爪的当前速度 get_gripper_P() 功能: 获取夹爪PID的P值 参数: 无 返回: (int)夹爪PID的P值 get_gripper_I() 功能: 获取夹爪PID的I值 参数: 无 返回: (int)夹爪PID的I值 get_gripper_D() 功能: 获取夹爪PID的D值 参数: 无 返回: (int)夹爪PID的D值 get_gripper_cw() 功能: 获取夹爪顺时针可运行误差 参数: 无 返回: (int)夹爪顺时针可运行误差 get_gripper_cww() 功能: 获取夹爪逆时针可运行误差 参数: 无 返回: (int)夹爪逆时针可运行误差 get_gripper_mini_pressure() 功能: 获取夹爪最小启动力 参数: 无 返回: (int)夹爪最小启动力 get_gripper_io_open_value() 功能: 获取夹爪Io张开角度 参数: 无 返回: (int)夹爪Io张开角度 get_gripper_io_close_value() 功能: 获取夹爪Io闭合角度 参数: 无 返回: (int)获取夹爪Io闭合角度 get_gripper_queue_count() 功能: 获取夹爪当前队列的数据量 参数: 无 返回: (int)夹爪当前队列的数据量 get_gripper_vir_pos() 功能: 获取夹爪舵机虚位数值 参数: 无 返回: (int)夹爪舵机虚位数值 get_gripper_protection_current() 功能: 获取夹爪夹持电流 参数: 无 返回: (int)夹爪夹持电流 set_gripper_Id(value) 功能: 设置夹爪ID号 参数: value: (int) 夹爪ID，取值范围 1-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_baud(value) 功能: 设置夹爪波特率 参数: value: (int) 夹爪波特率，取值范围 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_enable(value) 功能: 设置夹爪使能状态 参数: value: (int) 使能状态，取值范围 0-1 0: 掉使能 1: 上使能 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_value(value,speed) 功能: 设置夹爪以指定的速度转动到指定的位置 参数: value: (int) 位置，取值范围 0-100 speed: (int) 速度，取值范围 1-100 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_calibration() 功能: 设置夹爪零位校准 参数: 无 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_P(value) 功能: 设置夹爪PID的P值 参数: value: (int) P值，取值范围 0-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_I(value) 功能: 设置夹爪PID的I值 参数: value: (int) I值，取值范围 0-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_D(value) 功能: 设置夹爪PID的D值 参数: value: (int) D值，取值范围 0-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_cw(value) 功能: 设置夹爪顺时针可运行误差 参数: value: (int) 误差，取值范围 0-16 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_cww(value) 功能: 设置夹爪逆时针可运行误差 参数: value: (int) 误差，取值范围 0-16 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_mini_pressure(value) 功能: 设置夹爪最小启动力 参数: value: (int) 最小启动力，取值范围 0-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_torque(value) 功能: 设置夹爪扭矩 参数: value: (int) 扭矩，取值范围 0-300 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_output(value) 功能: 设置夹爪IO 参数: value: (int) 夹爪IO，取值范围 0-3 0: out1 off,out2 off 1: out1 on,out2 off 2: out1 off,out2 on 3: out1 on,out2 on 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_io_open_value(value) 功能: 设置夹爪Io张开位置 参数: value: (int) 位置，取值范围 0-100 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_io_close_value(value) 功能: 设置夹爪Io闭合位置 参数: value: (int) 位置，取值范围 0-100 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_speed(speed) 功能: 设置夹爪速度 参数: speed: (int) 速度，取值范围 1-100 返回:(int) 0-1 0: 失败 1: 成功 set_abs_gripper_value(value,speed) 功能: 设置夹爪以指定的速度转动到指定的绝对位置 参数: value: (int) 位置，取值范围 1-100 speed: (int) 速度，取值范围 1-100 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_vir_pos(value) 功能: 设置夹爪舵机虚位数值 参数: value: (int) 虚位，取值范围 0-100 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_protection_current(value) 功能: 设置夹爪夹持电流 参数: value: (int) 虚位，取值范围 1-254 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_pause() 功能: 设置夹爪暂停运动 备注: 只对set_abs_gripper_value()生效 参数: 无 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_resume() 功能: 设置夹爪恢复运动 备注: 只对set_abs_gripper_value()生效 参数: 无 返回:(int) 0-1 0: 失败 1: 成功 set_gripper_stop() 功能: 设置夹爪停止运动，并清空消息队列 备注: 只对set_abs_gripper_value()生效 参数: 无 返回:(int) 0-1 0: 失败 1: 成功 案例程序 from elegripper import Gripper import time if __name__==\"__main__\": g=Gripper(\"COM27\",baudrate=115200,id=14)##填写实际的串口号和波特率和夹爪ID print(\"夹爪的实际ID为:\",g.get_gripper_Id()) print(g.set_gripper_value(100,100)) time.sleep(2) print(g.set_gripper_value(0,100)) time.sleep(2) ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.2-PneumaticGripper.html":{"url":"4-SupportAndService/10-Accessories/10.2-PneumaticGripper.html","title":"10.2 气动夹爪","keywords":"","body":"气动夹爪 兼容型号： myCobot 320、myCobot Pro 630、myCobot Pro 600、myCobot Pro 450 产品图片 规格 名称 mycobot 气动夹爪 模型 myCobotPro_Gripper_Air_10 材料 金属 + 7500 尼龙 夹取范围 0-8mm 夹紧力 外径 34N 内径 45N 驱动模式 气动 传输方式 活塞缸 尺寸 67.3×38×23.6mm 重量 180g 固定方法 螺丝固定 使用环境要求 常温常压 控制接口 输入/输出控制 适用设备 myCobot 320 系列、 myCobot Pro 630系列、 myCobot Pro 600系列、myCobot Pro 450 系列 用于抓取物体 引言 气动夹爪又称气动手指或气动夹钳，是一种利用压缩空气作为动力抓取或抓取工件的执行器。它体积小、重量轻、外形紧凑，能够实现单向和双向抓取、自动对中、高重复精度和自动控制磁性开关。 气动夹爪套件包括夹爪法兰、气泵、φ8 气管、φ6 气管、φ8-6 快速接头、电磁阀和电缆。其主要功能是代替人力抓取工作，可有效提高生产效率和工作安全性。需要外接吸气泵。 工作原理 单活塞：轴驱动曲柄，气爪由活塞驱动开合。两个爪片上分别布置有相应的曲柄槽。为减小摩擦阻力，爪片与机身之间采用钢珠滑轨结构连接。 双活塞：由两个活塞控制，每个活塞通过一个滚轮和一个双曲柄与一个气动指连接，形成一个特殊的驱动单元。需要注意的是，气动指始终向中心轴向移动，每个气动指不能独立移动。 平行钳形气缸：如果气动指朝相反方向移动，则先前被压缩的活塞处于排气状态，而另一个活塞处于压缩状态。 适用对象 体积小于夹紧行程 重量小于最大夹紧重量 自定义指尖可扩展更多用法 安装使用 需要配合空压机使用： 将黑色插头插入排插； 将搭配的红色软管插入机器上的接口： 红色按钮为开关，往外拔即打开，按回去则关闭机器： 夹爪安装： 将空压机红色软管的另一端接上电磁阀的接口： 将电磁阀另一端再拧开一个接口供启动夹爪控制开合使用： 用配套的两根透明软管，一端接在电磁阀的两个接口： 透明软管另一端接在夹爪的两个接口上： 用配套螺丝将夹爪固定在机械臂末端： 电气连接： 连接线黑色接机械臂底座 GND，红色接 OUT1~OUT6 任意一个，根据选择的接口更改后续程序的引脚号，这里使用 OUT1： 3 通过 python 控制 使用前需要先启动机器人系统 确认机械臂的IP地址：终端输入 ifconfig 获取 from pymycobot import ElephantRobot import time # 将ip更改成P600树莓派的实时ip elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # 启动机器人必要指令 elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1) time.sleep(2) elephant_client.set_digital_out(0,0) time.sleep(2) ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.3-AdaptiveGripper.html":{"url":"4-SupportAndService/10-Accessories/10.3-AdaptiveGripper.html","title":"10.3 自适应夹爪","keywords":"","body":"myCobotPro 自适应夹爪 兼容型号： myCobot 320、myCobot Pro 630、myCobot Pro 600、myCobot Pro 450 产品图片 规格 名称 myCobotPro 自适应抓取器 黑白款 材料 光敏树脂 + 尼龙 工艺技术 3D 打印 夹取范围 0-90 mm 夹紧力 1000 grams 驱动模式 电驱动 变速箱模式 齿轮+连接杆 尺寸 158x105x55mm 重量 350 grams 固定方法 螺丝固定 使用环境要求 常温常压 控制接口 串行端口/IO 控制 适用设备 myCobot 320 系列、 myCobot Pro 630、 myCobot Pro 600、myCobot Pro 450 用于抓取物体 引言 机械手是一种能像人手一样工作的机器人部件。它具有结构复杂、抓取物体牢固、不易掉落、操作简便等优点。 抓手套件包括抓手连接线和法兰，通过可编程系统控制机械臂的末端效应器，实现抓取物体和多点定位等功能。抓手可用于所有开发环境，如 ROS、Arduino、Roboflow 等。 工作原理 在电机的驱动下，机械手的手指表面做直线往复运动，实现打开或关闭动作。电动机械手的加减速可控，对工件的冲击最小，定位点可控，夹紧可控。 适用对象 小方块 小球 长条物体 安装使用 夹爪安装： 结构安装： 将垫片对准机械臂末端孔位，配合螺丝拧紧： 将夹爪的螺丝孔对准垫片四周的孔位，配合细螺丝拧紧： 电气连接： 注意在机械臂不上电的状态下进行，即末端绿灯不亮的情况下进行插拔，如果带电热插拔，会有损坏夹爪的风险。 将 m8 线对准机械臂的接口，注意接口处有缺口，连接线有对应突起，确认方向后插入，并拧紧： 插入夹爪控制接口，同样注意缺口的方向： python编程控制 需要先使用roboflow将机械臂使能，再运行下面的python脚本内容，测试夹爪是否正常 确认机械臂的IP地址：终端输入 ifconfig 获取 IO控制模式 from pymycobot import ElephantRobot import time # 将ip更改成P600树莓派的实时ip elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # 启动机器人必要指令 elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(1) time.sleep(1) elephant_client.power_off()#夹爪透传换IO模式时需要先关闭机器再重启机器人一次，仅使用夹爪透传模式不必关闭机器人 elephant_client.power_off() time.sleep(3) elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) elephant_client.set_digital_out(16, 0) # IO恢复低电平 time.sleep(1) elephant_client.set_digital_out(17, 0) # IO恢复低电平 time.sleep(1) # IO模式 #夹爪全开全闭合控制代码，注意在夹爪透传切换IO模式时需要先关闭机器再重启机器人一次，才能切换回夹爪IO模式 for i in range(3): elephant_client.set_digital_out(16, 1) # 闭合夹爪 time.sleep(1) elephant_client.set_digital_out(17, 0) # IO恢复低电平 time.sleep(1) elephant_client.set_digital_out(16, 0) #IO恢复低电平 time.sleep(1) elephant_client.set_digital_out(17, 1) # 打开夹爪 time.sleep(1) elephant_client.set_digital_out(16, 0) # IO恢复低电平 time.sleep(1) elephant_client.set_digital_out(17, 0) # IO恢复低电平 time.sleep(1) 透传模式 from pymycobot import ElephantRobot import time # 将ip更改成P600树莓派的实时ip elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # 启动机器人必要指令 elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) # elephant_client.power_off()#夹爪透传换IO模式时需要先关闭机器再重启机器人一次，仅使用夹爪透传模式不必关闭机器人 elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) #透传模式 for i in range(3): elephant_client.set_gripper_value(26,20) time.sleep(1) elephant_client.set_gripper_value(86,20) time.sleep(1) 夹爪零位校准 夹爪出厂时已做过零位校准，若夹爪的行程不对，可以按照下面操作进行校准 在roboflow先关闭机器人，手动将夹爪张开到最大 然后再启动机器人 然后再执行下面脚本 from pymycobot import ElephantRobot import time # 将ip更改成P600树莓派的实时ip elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # 启动机器人必要指令 elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) elephant_client.set_gripper_calibrate() time.sleep(1) ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.4-PhoneHolderPro.html":{"url":"4-SupportAndService/10-Accessories/10.4-PhoneHolderPro.html","title":"10.4 手机支架","keywords":"","body":"myCobot Pro Mobile 手机支架 兼容型号: myCobot 600, myCobot Pro 630，myCobot Pro 450 产品图片 规格说明： 名称 myCobotPro手机夹持器 型号 myCobot_Pro_PhoneHolder_J6 材料 光敏树脂 夹持重量 200g 固定方式 螺丝固定 使用环境要求 常温常压 适用设备 myCobot 600、myCobot 630、myCobot Pro 450 myCobotPro手机夹持器： 夹取物体使用 简介 适用于拍摄等需要物理夹持的设备，可夹持多种手机，结构简单，易于安装拆卸。 适用物体 拍摄设备 安装 将手机夹持器固定在机械臂末端法兰即可 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.5-3DCamera.html":{"url":"4-SupportAndService/10-Accessories/10.5-3DCamera.html","title":"10.5 3D相机","keywords":"","body":"3D 相机 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.6-SingleSuctionPump.html":{"url":"4-SupportAndService/10-Accessories/10.6-SingleSuctionPump.html","title":"10.6 独头吸泵","keywords":"","body":"独头吸泵 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.7-ModuleSuctionCup.html":{"url":"4-SupportAndService/10-Accessories/10.7-ModuleSuctionCup.html","title":"10.7 模块化吸盘","keywords":"","body":"吸盘模块 兼容型号: myCobot 320、myCobot Pro 600、myCobot Pro 630、myCobot Pro 450 产品图片 规格说明 名称 模块吸盘 型号 myCobotPro_suctionPump 材料 尼龙 7100 吸盘数量 1/2/4 吸盘尺寸 直径 33mm 吸取重量 最大 1000g 动力源设备 吸吹一体空压机 固定方式 螺丝固定 控制接口 IO 控制 使用环境要求 常温常压 适用设备 myCobot 320、myCobot Pro 600、myCobot Pro 630、myCobot Pro 450 吸盘吸泵 :吸附物体使用 简介 吸盘吸泵是抽气口通过吸盘、管子等元件与待吸附物体连接，对吸盘抽真空，造成内部气压由常压变为负压，利用外界大气压和这个负压之间的压差作用，达到吸附住物体的目的。 整体结构是多功能可扩展吸盘，最多可安装 4 个；耐高压软管，可多次重复使用；吸吹一体空压机，可扩展其他功能。 工作原理 起动真空设备抽吸，使吸盘内产生负气压，从而将待提升物吸牢，即可开始搬送待提升物。 当待提升物搬送到目的地时，平稳地充气进真空吸盘内，使真空吸盘内由负气压变成零气压或稍为正的气压，真空吸盘就脱离待提升物,从而完成了提升搬送重物的任务。 适用物体 适用于带有平面物体 安装使用 需要配合空压机使用： 将黑色插头插入排插； 将搭配的红色软管插入机器上的接口： 红色按钮为开关，往外拔即打开，按回去则关闭机器： 吸盘安装： 将空压机红色软管的另一端接上电磁阀的接口： 用模块吸盘配套的透明软管分别接上电磁阀上方和模块吸盘软管分支的接口： 用配套螺丝将模块吸盘固定在机械臂末端： 将软管分支安装在模块吸盘上： 电气连接： 连接线黑色接机械臂底座 GND，红色接 OUT1~OUT6 任意一个，根据选择的接口更改后续程序的引脚号，这里使用 OUT1： 3 通过 python 控制 使用前需要先启动机器人系统 确认机械臂的IP地址：终端输入 ifconfig 获取 from pymycobot import ElephantRobot import time # 将ip更改成P600树莓派的实时ip elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # 启动机器人必要指令 elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1)#吸取 time.sleep(2) elephant_client.set_digital_out(0,0)#放开 time.sleep(2) ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.8-CameraModulePro.html":{"url":"4-SupportAndService/10-Accessories/10.8-CameraModulePro.html","title":"10.8 摄像头法兰","keywords":"","body":"myCobotPro 摄像头模块 兼容型号： myCobot 320, myCobot Pro 630、myCobot Pro 600、myCobot Pro 450 产品图片 规格说明： 名称 myCobotPro 摄像模组 型号 myCobot_Pro_cameraHolder_J6 材料 光敏树脂 USB 协议 USB2.0 HS/FS 镜头焦距 标配 1.7mm 视场角度 约 60° 支持的系统 Win7/8/10、Linux、MAC 固定方式 螺丝固定 使用环境要求 常温常压 适用设备 myCobot 320、myCobot Pro 600、myCobot Pro 630、myCobot Pro 450 摄像头法兰 : 机器视觉 简介 USB 高清摄像头可搭配吸泵、自适应夹爪、人工智能套装等，eye in hand 实现精确定位与标定。 安装使用 检查配件包东西是否齐全：螺丝及内六角扳手、带 usb 线的摄像头模组 摄像头安装： 结构安装： 将摄像头模组根据需要的方向对准机械臂末端，配合内六角扳手拧紧螺丝 电气连接： 将 USB 线插入底座 USB 接口： python编程控制 进入机器人系统，打开终端输入下列指令安装opencv sudo apt-get install -y libopencv-dev python3-opencv 新建一个python文件，填入以下代码 #encoding=utf-8 import cv2 import numpy as np cap = cv2.VideoCapture(0) while(True): ret, frame = cap.read() cv2.imshow('frame', frame) # 按下'q'退出 if cv2.waitKey(1) & 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() 然后在终端用python3 运行刚刚新建的python文件 ← 上一章 | 下一章 → "},"4-SupportAndService/10-Accessories/10.9-PenHolderPro.html":{"url":"4-SupportAndService/10-Accessories/10.9-PenHolderPro.html","title":"10.9 笔夹","keywords":"","body":"myCobot Pro 夹持器 兼容型号: myCobot 600、myCobot 630、myCobot Pro 450 产品图片 规格说明： 名称 myCobotPro 笔夹持器 型号 myCobot_Pro_penHolder_J6 材料 光敏树脂 固定方式 螺丝固定 使用环境要求 常温常压 适用设备 myCobot 600、myCobot 630、myCobot Pro 450 myCobotPro 笔夹持器： 使用机械臂写字画画时使用 简介 整体纯色设计，支持上下 15mm 超大行程伸缩，有效减少误差，可以用于写字、画画等应用。 适用物体 白板笔 安装使用 安装 将两颗短螺丝伸入夹持器孔位中,将笔固定住，注意笔头朝向： 使用内六角扳手将夹持器固定在机械臂末端： ← 上一章 | 下一章 → "},"5-Acknowledgments/11-Acknowledgements.html":{"url":"5-Acknowledgments/11-Acknowledgements.html","title":"11 致谢","keywords":"","body":"致谢 我们在这里表达我们对所有参与开发、测试和完善 myCobot 系列产品（包括 myCobot 280 pi、myCobot 280 M5、myCobot 280 JN、myCobot 280 For Arduino、myCobot Pro 450以及套件）的人员的深深感激。每一个细节的打磨和每一个功能的创新都离不开背后团队的辛勤工作和献身精神。 特别感谢： 研发团队：感谢你们的创新思维和无数个日夜的努力，将复杂的技术转化为用户友好的产品。质量保证与测试团队：你们对每一个细节的严格把控保证了我们产品的可靠性和用户的最终体验。客户支持团队：感谢你们为我们的用户提供专业的支持，帮助他们解决使用过程中的每一个问题。合作伙伴与供应商：你们的支持和服务对产品的成功至关重要。感谢你们的高质量原材料和部件，以及时刻准备支持的态度。投资者和顾问：没有你们的信任和资金支持，我们无法将这些创新带到市场。你们的洞察和指导也一直是我们前进的动力。 用户感谢： 我们特别感谢选择和信任 myCobot 系列产品的每一位用户。你们的反馈和建议是我们不断前进和改进的动力。我们承诺将继续倾听你们的声音，不断优化我们的产品和服务。 未来展望： 我们期待与所有的利益相关者一起，继续在机器人技术的道路上探索和进步。让我们携手创造更多的可能，为世界带来更大的便利和创新。 ← 上一章 "}}