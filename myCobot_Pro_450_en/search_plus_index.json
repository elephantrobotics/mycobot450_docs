{"./":{"url":"./","title":"Introduction","keywords":"","body":"myCobot Pro 450 The world's smallest collaborative robot Core Document This document contains comprehensive information from product introduction, detailed technical parameters to user instructions and product development guidance. The document will introduce the basic functions of the myCobot 280 M5 robot arm in depth, provide software development guidelines, and show successful application cases to help you understand how to effectively integrate myCobot 280 M5 into various applications. In addition, we also provide a wealth of support and service information to ensure that you can get the necessary help when you encounter any technical challenges. Document Description Depending on your needs and your level of expertise in myCobot 280 M5 application development, you can choose to follow this order from beginning to end or use it as a standalone reference. You can always use the sidebar navigation on the left to jump to any part of this document. The full text is divided into the following five sections: Product Information The product information section will provide you with a basic overview of the robot arm, including detailed technical specifications such as main functions, product parameters and electrical characteristics, to help you quickly understand the basic characteristics and usage environment of the product. In addition, this section will detail the application examples and supported extended development of the product, providing you with the necessary development guides and resources. At the end of the article, relevant purchase links and channels will be provided for your convenience. Basic Settings This section is an important section that every user of this product must read carefully. It covers key information about the use, transportation, storage and maintenance of the product, aiming to ensure the safety and efficiency of users when operating the product. In addition, this section also details the division of responsibilities for product failure or damage that may occur due to failure to follow these guidelines. Functions and Applications The Functions and Applications section details the basic functions of the robot arm and how to use the software, including system instructions and firmware functions. The Software Development Guide provides guidance based on different development environments, such as Python and ROS, to support technical developers in application expansion. By showing successful application cases and providing supporting resources, it provides you with practical references and necessary support materials for a deeper understanding and use of the product. Support and Services The Support and Services section will provide you with comprehensive troubleshooting guides and post-purchase service information, such as warranty and service terms, to help you quickly resolve problems when you encounter them, and ensure that you understand your rights and obligations after purchase. In addition, the 'About Us' section reinforces the user's understanding of the myCobot series product design and manufacturer, aiming to build trust and brand loyalty. Acknowledgements We appreciate your taking the time to read the myCobot 280 M5 User Manual. We hope that this document will help you better understand and effectively use this robot, thereby inspiring your creativity. If you have any questions or need further assistance, please feel free to contact our customer support team. We look forward to seeing the innovative projects you complete with myCobot 280 M5 and welcome you to join our fast-growing developer community. Document Directory Introduction Product Information 1. Product Introduction 2. Product Parameters Basic Settings 3. User Notice 4. First Time Installation 4.1 First-time self-check 4.2 Software issues 4.3 Hardware issues 4.4 Accessories issues 4.5 Others Functions and applications 5. Basic functions 5.1 System (function) instructions 5.2 Software instructions 5.3 Firmware Function Description 5.3.1 Drag teaching 5.3.2 Calibration 5.3.3 Computer control 5.3.4 Connection detection 5.4 PID control 6. Software development guide 6.1 Development and use based on python 6.1.1 Environment Construction 6.1.2 API Description 6.1.3 Joint Control 6.1.4 Coordinate Control 6.1.5 IO Control 6.1.6 Gripper Control 6.1.7 Robot exception handling 6.2 Development and Use Based on ROS1 6.2.1 Environment Setup 6.2.2 ROS Basics 6.2.3 Rivz Use 6.2.4 Basic Function Cases 6.3 Development and use based on ROS2 6.3.1 Environment Setup 6.3.2 ROS2 Basics 6.3.3 Rivz2 Use 6.3.4 Basic Function Cases 6.4 Development and Use Based on myStudio Pro 6.4.1 Initial Use of myStudio Pro 6.4.2 Install and Uninstall 6.4.3 Interface and Description 6.4.4 Q&A 6.4.5 myBlockly 6.4.6 QuickMove 6.4.7 Firmware and Applications 6.4.8 Settings 6.5 Development and use based on C++ 6.5.1 Environment Construction 6.5.2 Compile and Run 6.5.3 Joint Control 6.5.4 Coordinate Control 6.5.5 IO Control 6.5.6 Gripper control 6.5.7 API description 6.5.8 Use Case 6.6 Development and use based on serial communication protocol 7. Successful Cases Robot gripper carrying wooden block example Robot suction pump to carry wooden blocks 8. Supporting Resources 8.1 Product Information 8.2 Product Drawings 8.3 Software Information and Source Code 8.4 System Information 8.5 Promotional Materials Support and Services Contact Us Robot Arm Accessories Flat Base G-Stand Adaptive Gripper Parallel Gripper Flexible Gripper - Open Leg Type Vertical Suction Pump Double-head suction pump Integrated suction pump Pen holder Phone holder Dexterous hand USB camera Bamboo flange Acknowledgments "},"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html":{"url":"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html","title":"1. Product Introduction","keywords":"","body":"Chapter 1 Product Introduction 1.product description myCobot 280 M5 Desktop six-axis collaborative robot Product Introduction myCobot is jointly produced by Elephant Robot and M5stack. It is the world's smallest and lightest six-axis collaborative robot. It can be redeveloped according to user needs to achieve user customization. It is a productivity tool and a tool to expand the boundaries of imagination. myCobot weighs 850g, has a payload of 250g, and an effective working radius of 280mm. It is small in size but powerful in function. It can be matched with a variety of end effectors to adapt to a variety of application scenarios, and can also support the secondary development of multi-platform software to meet the needs of various scenarios such as scientific research and education, smart home, and commercial exploration. design concept The myCobot 280 series robot arm is a six-degree-of-freedom collaborative robot developed by Elephant Robotics for scenarios such as scientific research and education, maker applications, and commercial displays. The robot arm has a compact and exquisite appearance and structure, and a one-piece fully enclosed body design without any leaking cables. It is equipped with the robot motion control algorithm independently developed by Elephant Robotics, and supports multiple control modes such as angle, coordinate, potential value, and radian value, making it easier for users to understand the complex working principles of robots and the application principles of robots. It supports the development of application cooperation and can be expanded to a variety of main controls such as PCs, industrial computers, and embedded devices, suitable for a variety of application scenarios. Design goals Design goals description Application scenarios and features Universal multi-functional platform myCobot 280 M5 is suitable for a variety of application scenarios such as education, research and commercial display, maker development, etc. Its six degrees of freedom and 280mm arm span support complex motion control in various working environments. It can be equipped with a variety of end accessories such as grippers and suction pumps to meet various application scenarios. Educational Support myCobot 280 M5 supports drag-and-drop programming language and interactive drag-and-drop teaching, which facilitates the intuitive display of how the robot arm works. The product supports the myblocky graphical programming tool, which allows beginners to intuitively experience robot applications by dragging and combining different modules for programming. Programmability and scalability The myCobot 280 M5 is highly programmable, allowing users to customize and program it to meet the needs of future technologies based on emerging technologies. Through user-defined programming, the equipment can achieve optimized operation and experimental results to meet the ever-changing needs of research and development. Technological innovation and knowledge dissemination myCobot 280 M5 can be used as a platform to showcase the latest scientific and technological achievements in commercial exhibitions, aiming to enhance the public's understanding and interest in science and technology and promote the transformation of scientific and technological innovation into commercialization. By displaying and demonstrating the latest scientific and technological achievements, we can increase public participation, promote the popularization of scientific and technological knowledge and the market acceptance of scientific and technological products. Features Unique industrial design, extremely compact Integrated design, compact overall structure, net weight of only 850g, very easy to carry. Modular design, few spare parts, low maintenance cost, can be quickly disassembled and replaced, and realize plug and play High configuration, equipped with two displays It contains 6 high-performance servo motors with fast response, small inertia and smooth rotation. It has two display screens and supports fastLED library, which is convenient for expanding application interactive output. LEGO connector, M5 has thousands of applications The base uses M5Stack-basic as the main control, and thousands of application cases can be used directly. The base and the end are equipped with Lego technology parts interface, which is suitable for the development of various micro embedded devices. Graphical programming, supporting industrial robot software Using myBlockly visual programming software, programming is easy on the palm of your hand, and the operation is simple and easy to use. Supports Arduino + ROS open source system. Track entry, point saving myCobot 280 M5 supports drag-to-teach and can record the saved paths. It breaks away from the traditional path point storage mode and can save up to 60 minutes of different paths. 2.Product Application Client Educational institutions myCobot 280 can be used as a teaching and scientific research tool designed for robotic experiments and technology demonstrations. It can effectively support complex data analysis, algorithm development and verification activities, significantly improving research quality and educational effectiveness. Technical developers and engineers Supporting multiple programming languages such as Python, C++, C#, myCobot 280 M5 is suitable for professionals who need personalized programming and system integration. Its modular design and high programmability make it an ideal platform for developing and testing new control algorithms or robot applications. Trade show and public exhibition organisers myCobot 280 has become the preferred equipment for technology display and product demonstration with its precision operation display advantage. Dynamic demonstration not only attracts the audience, but also enhances their sense of participation, effectively promoting technological innovation and products. Geek development enthusiast myCobot 280 uses myBlockly visual programming software, which allows users to easily program on the palm of their hands and is easy to operate. It supports Arduino + ROS open source systems to meet the various creative needs of enthusiasts. Application Scenario User Group Application Scenarios Advantage Target Teachers and students in the field of education - STEM education- Robotics projects- Interdisciplinary research projects- Education and research - Improve students' interest in science and technology- Enhance hands-on skills and problem-solving skills- Promote innovative thinking and teamwork- Provide a practical platform for data collection and robotics Makers and technical developers - Prototype development- Experimental research- Algorithm testing and verification- Robot trial teaching - Accelerate research progress- Connect theory and practice- Promote technological innovation- Support multiple programming languages ​​and development environments Business presentations and marketing professionals - Exhibition displays- Technology demonstrations- Brand promotion - Attract potential customers and investors- Showcase the company's technological strength and innovative products- Enhance brand influence 3.Supported extension development The mycobot series of robotic arms are extremely valuable in the fields of education and scientific research, especially in Python and ROS (Robot Operating System), two widely used development environments. These environments provide strong support, allowing the mycobot series of products to be widely used in machine learning, artificial intelligence research, complex motion control, and visual processing tasks. At the same time, with dozens of accessories such as adaptive grippers, camera flanges, suction pumps, etc., you can give full play to myCobot's creative ideas. Python The robot supports Python and has a complete Python API library. The robot's joint angles, coordinates, grippers, etc. can be controlled through Python. ROS Supports both ROS1 and ROS2 versions, and provides RVIZ simulation environment support. Allows users to display the robot arm and collect the robot arm's status information in real time, making mycobot 280 M5 suitable for ROS beginners and educational purposes. Hardware interface Including IO, USB, etc., to facilitate the connection of various sensors and actuators. Software library Provides a wealth of open source libraries and APIs to simplify the development process. System compatibility Compatible with Windows, Linux, MacOS, and adaptable to a variety of development environments. C++ Using the C++ language, you can freely develop (coordinate control, angle control, IO control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. C# Using the C# language, you can freely develop (coordinate control, angle control, io control, gripper control, etc.) through the C# dynamic library provided by our company, and control some robots that our company has developed. Arduino Provides the open source program MyCobotBasic sample program. At the same time, users can also modify the open source program according to their own needs. JavaScript The robot can be controlled through the company's JavaScript language ecosystem library. myBlockly It is both a graphical programming software and a visualization tool. Users can drag and drop modules to create programs. This process is very similar to building blocks, which is convenient, fast and easy to use. 4.purchase address If you are interested in purchasing this device, please click on the link below Taobao：https://shop504055678.taobao.comShopify：https://shop.elephantrobotics.com/AliExpress：https://elephantrobotics.aliexpress.com/store/1101941423 Next Chapter → "},"1-ProductInformation/2.ProductParameter/2-ProductParameters.html":{"url":"1-ProductInformation/2.ProductParameter/2-ProductParameters.html","title":"2. Product Parameters","keywords":"","body":"Robot Parameters In the first chapter, we discussed the selling points of the product and its design concept, providing you with a panoramic perspective of the high-level understanding of the product. Now, let's move on to the second chapter - Robot Parameters. This chapter will be the key to your understanding of the product's technical details. A detailed understanding of these technical parameters will not only help you fully realize the advancement and practicality of our products, but also ensure that you can use these technologies more effectively to meet your specific needs. 1.Robot Specifications Index Parameters Name Little Elephant Collaborative Robot Arm Model myCobot 280 for M5 Degrees of Freedom 6 Payload 250g Working Radius 280mm Repeatability ±0.5mm Weight 800g Power Input 12V, 5A Operating Temperature -5-45℃ Communication Type-C 2.Control Core Parameters 2.1Main Controller Specifications Indicators Parameters Main Controller M5Stack-basic Main Controller Model ESP32 CPU 240MHz Dual Core. 600 DMIPS, 520KB SRAM. Wi-Fi, dual-mode Bluetooth Bluetooth 2.4G/5G Wireless 2.4G 3D Antenna Input 1, 2, 3, 5, 18, 19, 21, 22, 23, 25, 26, 35, 36 Output Shared with input LCD display 2.0\" @ 320*240 ILI9342C IPS panel, maximum brightness 853nit Physical buttons 2.2Auxiliary controller specification table Indicators Parameters Auxiliary control Atom Auxiliary control model ESP32 Auxiliary controller core parameters 240MHz dual-core. 600 DMIPS, 520KB SRAM. Wi-Fi, dual-mode Bluetooth Auxiliary controller flash 4MB LED matrix 5*5 LED light matrix LCD display 2.0\"@320*240 ILI9342C IPS panel, maximum brightness 853nit C type *1 Auxiliary control expansion IO G19, G21, G22, G23, G25, G33 3.Structural dimension parameters ! This chapter uses millimeters as distance units and degrees as angle units. 3.1Product dimensions and working space 3.2Joint range of motion Joints Range J1 -168 ~ +168 J2 -135 ~ +135 J3 -150 ~ +150 J4 -145 ~ +145 J5 -165 ~ +165 J6 -180 ~ +180 3.3Hole installation The robot base is mounted with flanges. The base is compatible with both LEGO technology and M4 screw installation. The robot end is equipped with a flange, and the end of the robotic arm is compatible with both LEGO technology holes and screw thread holes. 4.Electrical characteristic parameters 4.1Electrical interface of the robot base Introduction to the base A. The front of the base is shown in the figure below: ① Function interface group 1 ② Basic display screen ③ Button 1, Button 2, Button 3 B. The left side of the base is shown in the figure below: ① Grove 1, Grove 2 ② Power DC interface ③ Function interface group 2 ④ Reset button ⑤ Type C interface ⑥ Grove 3 C. The right side of the base is shown in the figure below: ① Functional interface group three D. The bottom interface surface of the base is shown in the figure below: ① Functional interface group four 4.2Base interface description Note: The functional interface groups are all 2.54mm DuPont interfaces, and 2.54mm DuPont cables can be used externally. A. The definitions of each interface in function interface group 1 and function interface group 4 are consistent. The definition of each interface is shown in the following table: Label Signal name Type Function Remarks 18 G18 I/O GPIO18 Not available when using TF card 19 G19 I/O GPIO19 Not available when using TF card 23 G23 I/O GPIO23 Not available when using TF card 22 G22 I/O GPIO22 21 G21 I/O GPIO21 G GND P GND 3V3 3V3 P DC 3.3V 5V 5V P DC 5V B. The definitions of each interface in function interface group 2 and function interface group 3 are consistent. The definition of each interface is shown in the following table: Label Signal name Type Function Remarks 3 G3 I/O GPIO3 Not available when using TypeC or Grove 2 1 G1 I/O GPIO1 Not available when using TypeC or Grove 2 16 G16 I/O GPIO16 Not supported yet 17 G17 I/O GPIO17 Not supported yet 2 G2 I/O GPIO2 5 G5 I/O GPIO5 25 G25 I/O GPIO25 Not supported 26 G26 I/O GPIO26 Not available when using Grove 1 35 G35 I/O GPIO35 Not supported 36 G36 I/O GPIO36 Not available when using Grove 1 RST RST - Controller reset Not supported BAT BAT - BTTERY Not supported 3V3 3V3 P DC 3.3V 5V 5V P DC 5V G GND P GND Note: I: Input only. I/O: This function signal includes input and output combination. When the tube angle is set as the output end, it will output a voltage of 3.3V. The pull current of a single tube angle decreases as the number of pins increases, from about 40mA to 29mA. If a GPIO is set to output mode, it outputs a high-level signal, and the circuit connection is shown in Figure 2.1.1.2-5, and the LED light will light up. The other function tables of the function interface are shown in the figure below. When other functions are used, the IO function is not available. C. Power DC interface: Use a DC power socket with an outer diameter of 6.5mm and an inner diameter of 2.0mm; the 8.4V 5A DC power adapter provided by the manufacturer can be used to power myCobot 280. D. Grove interface: Grove interface definition as shown in Figure A, Figure B, and Figure C Figure A Grove 1 Figure B Grove 2 Figure C Grove 3 E. Type C interface: can be used to connect and communicate with the PC. When this interface is used, the G1 and G3 interfaces are occupied. F. Reset button: used to reset the main control system. G. Button A, Button B, and Button C: used with the display screen for functional operations. H. Display screen: Use a 2-inch IPS screen, which can be used to display myCobot communication status/correct the robot origin with buttons, etc. 4.3 Electrical interface of the end of the robot Introduction to the end of the robot A. The end of the robot is shown in Figure D and Figure E: Figure D End of the robot ① Servo interface ② Atom Figure E End of the robot ① Function interface group 5 ② Grove 4 ③ Type C End interface description A. The definitions of each interface of the function interface group 5 are shown in the following table: Label Signal name Type Function Remarks 5V 5V P DC 5V GND GND P GND 3V3 3V3 P DC 3.3V G22 G22 I/O GPIO22 G19 G19 I/O GPIO19 G23 G23 I/O GPIO23 G33 G33 I/O GPIO33 Note: I: Input only. I/O: This function signal contains input and output combination. When the tube angle is set as output terminal, it will output voltage 3.3V. The pull current of a single tube angle decreases as the number of pins increases, from about 40mA to 29mA. If a GPIO is set to output mode, it outputs a high-level signal, and the circuit connection is as shown in the figure below, and the LED light will light up. B. Type C interface: can be used to connect and communicate with the PC and update the firmware. C. Grove 4: definition as shown in Figure F Figure F Grove 4 D. Servo interface: used for the end extension gripper, currently supports the use of matching adaptive grippers. E. Atom: for 5X5 RGB LED (G27) display and key function (G39) 5.Cartesian coordinate parameters ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3-UserInstructions.html":{"url":"2-BasicSettings/3.UserNotice/3-UserInstructions.html","title":"3. User Notice","keywords":"","body":"Chapter 3 User Notice Chapter 3 User Notice is a must-read for every user to ensure that the user can achieve the established safety standards and efficiency when using the product. This chapter not only provides basic information on product use, transportation, storage and maintenance to ensure safe operation and maximized efficiency of the product, but also details the liability issues for product failure or damage that may result from failure to comply with these guidelines. 1.Safety Instructions Introduction This chapter details general safety information for personnel who perform installation, maintenance and repair work on the Elephant Robot. Please fully read and understand the contents and precautions of this chapter before handling, installing and using it. Hazard Identification The safety of collaborative robots is based on the premise of correctly configuring and using the robots. Moreover, even if all safety instructions are followed, injuries or damage to the operator may still occur. Therefore, it is very important to understand the safety hazards of robot use, which is conducive to preventing them before they happen. Tables 1-1 to 3 below are common safety hazards that may exist when using robots: Table 1-1 Dangerous safety hazards 1 Personal injury or robot damage caused by incorrect operation during robot handling. 2 Failure to fix the robot as required, such as lack of screws or screws not tightened, insufficient base locking capacity to stably support the robot for high-speed movement, etc., causing the robot to fall over, resulting in personal injury or robot damage. 3 Failure to correctly configure the robot's safety functions, or insufficient installation of safety protection tools, etc., causing the robot's safety functions to fail to function, thus causing danger. Table 1-2 Warning-level safety hazards 1 Do not stay in the robot's motion range when debugging the program. Improper safety configuration may not be able to avoid collisions that may cause personal injury. 2 The connection between the robot and other equipment may cause new hazards, and a comprehensive risk assessment needs to be re-performed. 3 Scratches and punctures caused by sharp surfaces such as other equipment or the robot's end effector in the working environment. 4 The robot is a precision machine and trampling may cause damage to the robot. 5 Failure to clamp in place or not removing the clamped object before turning off the robot's power or air source (not confirming whether the end effector is secure and the clamped object falls due to power loss) may cause dangers, such as damage to the end effector and injuries to people. 6 The robot may move unexpectedly. Do not stand under any axis of the robot under any circumstances! 7 The robot is a precision machine. If it is not placed stably during transportation, it may cause vibration, which may cause damage to the robot's internal components. 8 Compared with ordinary mechanical equipment, the robot has more degrees of freedom and a larger range of motion. Failure to meet the range of motion may cause unexpected collisions. Table 1-3 Safety hazards that may cause electric shock 1 Using non-original cables may cause unknown dangers. 2 Electrical equipment in contact with liquid may cause leakage. 3 There may be a risk of electric shock when the electrical connection is incorrect. 4 Always turn off the power of the controller and related devices and unplug the power plug before replacing. If the work is carried out in the power-on state, it may cause electric shock or malfunction. Safety Precautions The following safety rules should be followed when using the robot arm: The robot arm is a live device. Non-professionals are not allowed to change the circuit at will, otherwise it is easy to cause damage to the equipment or personal injury. When operating the robot arm, local laws and regulations should be strictly observed. The safety precautions and \"Danger\", \"Warning\" and \"Caution\" items described in the manual are only used as supplements to local safety regulations. Please use the robot arm within the specified environmental range. Exceeding the robot arm specifications and load conditions will shorten the product life or even damage the equipment. Personnel responsible for installing, operating and maintaining the myCobot robot arm must first undergo rigorous training, understand various safety precautions, and master the correct operation and maintenance methods before operating and maintaining the robot. Do not use this product in a humid environment for a long time. This product is a precision electronic component. Long-term operation in a humid environment will damage the device. Do not use this device in a high temperature environment. The outer surface of this device is made of photosensitive resin as raw material. Higher temperatures will damage the outer shell of the device and cause equipment failure. Highly corrosive cleaning is not suitable for cleaning the robot arm, and anodized parts are not suitable for immersion cleaning. Do not use this product without a base installed to avoid damage to the device or accidents. This product should be used in a fixed environment with no obstacles around. Do not use other power adapters for power supply. If the device is damaged due to the use of an adapter that does not meet the standards, it will not be covered by after-sales service. Do not disassemble, disassemble, or unscrew the screws or casing of the robot arm. If disassembled, warranty service cannot be provided. Personnel who have not received professional training are not allowed to repair faulty products or disassemble the robot arm without authorization. If the product fails, please contact myCobot technical support engineers in time. If the product is scrapped, please comply with relevant laws to properly dispose of industrial waste and protect the environment. Children must be monitored by someone during use, and the device must be turned off in time when the operation is completed. When the robot is in motion, do not put your hand into the range of motion of the robot arm to avoid injury. It is strictly forbidden to change or remove and modify the nameplate, instructions, icons and markings of the robot arm and related equipment. Please be careful during transportation and installation. Please place the robot gently and correctly in the direction of the arrow according to the instructions on the packaging box, otherwise it is easy to damage the machine. Do not burn other product drivers without authorization, or use unofficial recommended methods to burn firmware. If the device is damaged due to the user's personal burning of other firmware, it will not be covered by after-sales service. If you have any questions or suggestions about the contents of this manual, please log in to the official website of Elephant Robotics to submit relevant information: https://www.elephantrobotics.com Do not use the robot arm for the following purposes: Medical and life-critical applications. In an environment that may cause an explosion. Direct use without risk assessment. Use with insufficient safety function level. Use that does not meet the robot performance parameters. 2.Transportation and storage Packing and packaging   When packing and packaging the robot product, please make sure to use packaging materials and boxes designed for it. These materials can provide sufficient cushioning and support to prevent impact and vibration during transportation. Be sure to check that all parts are properly fixed to avoid looseness and damage. For fragile or sensitive parts, additional anti-vibration protection materials should be used for reinforcement. Finally, make sure that the outside of the packaging box is marked with clear handling and warning labels to indicate the correct handling method and storage direction. Logistics and Transportation   During transportation, the robot product should be transported in the original packaging. During transportation, it should be ensured that the robot product is stable as a whole in the packaging box and protected by appropriate measures. During transportation and long-term storage, the ambient temperature should be maintained in the range of -20 to +55°C, and the humidity should be ≤95% without condensation.   Because the robot is a precision machine, the robot product should be handled with care when it is removed from the packaging. During transportation, if it is not placed stably, it may cause vibration and damage the internal parts of the robot. Equipment Storage   After transportation, the original packaging should be properly stored in a dry place, the ambient temperature should be kept within the range of -20 to +55°C, the humidity should be ≤95% and there should be no condensation, in preparation for future repackaging and transportation needs. Do not stack other items on the original packaging box of the robot arm to prevent deformation of the packaging box and damage to the robot arm. 3.Maintenance and Care As a robot manufacturer, we value ensuring that our customers can properly and safely maintain and upgrade their robot equipment. To this end, we provide the following detailed maintenance and care guide, including common maintenance items and parts for repairing or upgrading hardware. Please read carefully: Common maintenance items and recommended cycles Maintenance items Description Recommended cycle Visual inspection Inspect the robot for obvious damage, foreign material accumulation or wear. Daily Structural cleaning Clean the robot structural parts with a clean, dry cloth. Avoid moisture and aggressive cleaning agents. Daily Fastener inspection Inspect and tighten all bolts and connectors. Daily Lubrication Lubricate joints and moving parts with the lubricant recommended by the manufacturer. Every 3 months Cable and wiring inspection Inspect the cables and wiring to ensure that there is no damage or wear. Monthly Electrical connection check Ensure that all electrical connections are secure and free of corrosion or damage. Monthly Software update Check and update the control software and application. Every update Software data backup Regularly back up key software configuration and data. Quarterly Firmware update Regularly check and update the firmware to obtain the latest features and security patches. Every update Sensor and device check Check sensors and other key devices to ensure normal operation. Monthly Emergency stop function test Regularly test the emergency stop function to ensure its reliability. Monthly Environmental condition monitoring Monitor the temperature, humidity, dust, etc. of the working environment to ensure that it meets the operating specifications of the robot. Continuous monitoring Safety configuration review Regularly check and confirm the safety configuration of the robot, such as speed limit and working range settings. Monthly Preventive maintenance plan execution Perform regular inspections and maintenance according to the manufacturer's maintenance plan. By Manufacturer's Guide 4.Guide to Independently Changing Robot Hardware We understand that customers may have the need to upgrade or repair robot hardware by themselves. Before performing any upgrade operations, please be sure to read the relevant parameters of the product in detail and confirm with our official personnel whether such operations are allowed. Operations without official permission may cause product failure and are not covered by the warranty. Material Requirements Officially manufactured or recommended materials: All accessories and components required for repairs and upgrades must be officially manufactured or explicitly recommended by us. This includes but is not limited to electronic components, sensors, motors, connectors, and any other replaceable parts. Material Acquisition: Customers can purchase the required repair and upgrade materials through our official channels. This ensures the quality and compatibility of the accessories. Repair or Upgrade Process Customer Self-Repair: Customers are responsible for completing the repair work. We will provide detailed repair instructions and manuals to guide customers through the repair steps. Follow official instructions: Repair operations should strictly follow the official instructions provided by us. Any deviation from the official instructions may cause damage to the equipment. Liability and Warranty Policy Division of Responsibilities: Manufacturer: Provide official instructions for repairs and upgrades, officially manufactured or recommended materials, and handle problems caused by manufacturing defects. Customer: Responsible for completing repairs in accordance with official instructions and using official accessories. Warranty Policy: Warranty Valid: Warranty is valid only if the repair operation fully follows our instructions and uses official accessories. Warranty Void: If the customer does not follow the official instructions or uses unofficial accessories for repairs or upgrades, any damage caused will not be covered by the warranty. Notes Safety First: Before performing any repair or upgrade operations, please make sure to follow all safety guidelines, including powering off and using appropriate protective equipment. Technical Support: If you encounter problems during the repair process, it is recommended to stop the operation and contact our technical support team for assistance. We strongly recommend that customers strictly follow these guidelines to ensure the safe and effective operation of the robot equipment. Improper repair operations may cause damage to the equipment and affect the warranty status. For further guidance or support, please contact our professional technical team in a timely manner. If you have read all of this chapter, please continue to the next chapter. ← Previous Chapter| Next Chapter → "},"2-BasicSettings/4.FirstTimeInstallation/4-FirstTimeInstallation.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4-FirstTimeInstallation.html","title":"4. First Time Installation","keywords":"","body":"Chapter 4 First Installation 1.Product Standard List Product List Image Thank you for choosing the Elephant Robot myCobot 280 M5 robot arm. This chapter is designed to help you easily get started with Elephant Robot products and enjoy every wonderful moment brought by the product. Product Standard List Comparison Table Serial Number Product 1 myCobot Robotic Arm (Model myCobot-280 M5) 2 myCobot Robotic Arm-Product Brochure 3 myCobot Robotic Arm-Supporting Power Supply 4 USB-Type C 5 Jumper 6 M4*35, Cup Head Hexagon, Full Thread, Stainless Steel Screws 7 Hexagon Wrench Note: After the packing box arrives, please confirm that the robot packaging is intact. If there is any damage, please contact the logistics company and the supplier in your area in time. After unpacking, please check the actual items in the box according to the item list. 2.Product Unpacking Guide Product Unpacking Graphic Guide Why do you need to follow the steps to disassemble the product In this section, we strongly recommend that you follow the specified steps to disassemble the product. This will not only help ensure that the product is not damaged during transportation, but also minimize the risk of unexpected failures. Please read the following graphic guide carefully to ensure the safety of your product during the unpacking process. 1 Check the packaging box for damage. If there is damage or missing accessories, please contact the logistics company and the supplier in your area in time. 2 Open the box and take out the product brochure, sponge packaging cover, myCobot robot arm, matching power supply, flat base and accessory bag. 3 Make sure each step is completed before proceeding to the next step to prevent unnecessary damage or omissions. Note: After taking out the product, please carefully check the appearance of each item. Please check the actual items in the box against the item list. 3.Product unboxing video guide If the video above does not play, you can click the link below to view the unboxing video unboxing video guide 4.Power-on inspection guide Structural installation and fixation During the movement of the robot arm, if the bottom surface of myCobot is not connected to the desktop or other bottom surface, myCobot will still shake or overturn. There are three common ways to fix the robot arm: 1) Use the Lego key to fix it on a base with a Lego interface We sell two types of bases: flat suction cup base and G-clip base ​ Flat base Applicable model: myCobot 280 Install suction cups at the four corners of the base and tighten them. Use the included Lego technology parts to connect the flat base and the bottom of the robot arm. Fix the four suction cups on a flat and smooth surface before starting to use. Tips: You can add a small amount of non-conductive liquid under the suction cup to fill the gap between the suction cup and the desktop to obtain the best adsorption effect. G-type base Applicable models: myCobot 280, myPalletizer 260 Use the G-clip to fix the base to the edge of the table Use the included Lego tech parts to connect the base and the bottom of the robot arm Make sure it is stable before starting to use 2 myCobot base screw hole connection The robot needs to be fixed on a solid base for normal use. Base weight requirement: fixed base or mobile base. Please make sure there are corresponding threaded holes on the fixed base before installation. Before formal installation, please confirm: The installation environment meets the requirements of the above \"Working Environment and Conditions\" table. The installation location is not less than the robot's working range, and there is enough space for installation, use, maintenance, and repair. Place the base in a suitable position. The installation related tools are ready, such as screws, wrenches, etc. After confirming the above content, please move the robot to the base installation table, adjust the robot position, and align the robot base fixing holes with the holes on the base installation table. After aligning the holes, align the screws with the holes and tighten them. Note: When adjusting the robot position on the base installation table, please try to avoid pushing and pulling the robot directly on the base installation table to avoid scratches. When manually moving the robot, please try to avoid applying external force to the fragile parts of the robot body to avoid unnecessary damage to the robot. 5. Common Problem Solving This section aims to help users solve common problems encountered during use, covering hardware, software, accessories, and how to self-check for the first time. If you encounter problems while using the robot arm, please read the contents of this section first to find solutions. If the listed problems cannot help you solve and you have more after-sales questions to consult, please add the after-sales butler WeChat. First-time self-check Common software problems and solutions Common hardware problems and solutions Common accessories problems and solutions Other problems and solutions If you have read all the contents of this chapter, please continue to the next chapter. ← Previous Chapter | Next Chapter → "},"4-SupportAndService/9.Troubleshooting/9.4-first-time-self-check.html":{"url":"4-SupportAndService/9.Troubleshooting/9.4-first-time-self-check.html","title":"4.1 First-time self-check","keywords":"","body":"First-time self-check- Machine Joint Function Verification Note: When starting the robot arm, please be careful not to let the robot arm be in a curled-up or touching position between joints. It is recommended that the robot arm posture should be as shown in Figure 1 below when starting. Figures 2 and 3 are both incorrect starting postures: Figure 1 (Correct Posture) Figure 2 (Incorrect Posture) Figure 2 (Incorrect Posture) Joint control method steps 1. Make hardware connections Hardware connections for M5 series machines: Make sure the M5 series robot is connected to the power adapter and USB data cable. 2. Install and configure the software environment You need to prepare a computer to use the M5 version of the machine. Install python, pymycobot library and USB serial port driver on the computer. For details, please refer to the environment configuration section of gitbook. 3. Choose the correct communication method Before using each communication method, you need to make sure that the LCD screen of M5 is adjusted to the corresponding mode and maintain this communication state to control the robot arm normally. When using myblockly, python, ros and other development methods for the M5 robotic arm, you need to ensure that the M5 LCD screen stays on the Atom: ok interface, as shown below: Note: When the screen displays Atom: no, you need to power on the machine again and check according to the self-check steps of the hardware-related \"How to solve the problem of the robotic arm not being able to lock when powered on\" in this article 4.USB communication example Please use myblockly or python source code examples to verify the joint motion of the robotic arm. Pay special attention to the need to select the corresponding serial port and baud rate when using the USB serial port opening method so that the robot arm can communicate with the computer normally and thus control the robot arm normally: Machine model Serial port number Baud rate 260 M5 Win: COM; Linux: /dev/ttyUSB 115200 270 M5 Win: COM; Linux: /dev/ttyUSB 115200 280 M5 Win: COM; Linux: /dev/ttyUSB 115200 Note: Regarding the selection of the COM port of the M5 series machine, it is necessary to make a real-time selection based on the port number recognized by the current personal computer, because the COM port number recognized by each person's computer may be different and not fixed. The specific selection scheme can be viewed in this document. \"Q: Why is the connection rejected when selecting a certain COM port? Or how to find the corresponding COM port?\" Answer 4.1 Robotic arm joint movement myblockly source code When you see the robot arm joint 1 cycle 3 times from 0 to 90 degrees, it means that the robot arm joint 1 responds normally. You can try to change the joint ID to test other joints and learn other cases in gitbook step by step or use the robot arm to do various interesting things! It is worth mentioning that if you are not familiar with the code block development method of myblockly, there is also a relatively quick way to verify the joints: use the myblockly fast movement tool to perform simple joint motion control. For specific usage, please refer to: Myblockly fast movement tool usage 4.2 Robotic arm joint motion joint python source code #The motion effect is that the robot arm moves around the zero position, and the 1-6 joints move one by one ±20 degrees import time from pymycobot.mycobot import MyCobot if __name__ == \"__main__\": cobot = MyCobot('com22',115200)#Select the corresponding port number and baud rate according to the model cobot.set_fresh_mode(1) cobot.send_angles([0, 0, 0, 0, 0, 0], 20) time.sleep(2) print(\"start\") for i in range(1,7): cobot.send_angle(i, (-30), 20) time.sleep(2) cobot.send_angle(i, (30), 20) time.sleep(2) cobot.send_angle(i, (0), 20) time.sleep(2) When you see the robot arm around the zero-position posture, 1-6 joints move one by one ±20 degrees, indicating that joints 1-6 respond normally, you can gradually learn to use other cases in gitbook or use the robot arm to do various interesting things! If you do not see the corresponding effect when executing the case, please refer to the common problem solutions below. In addition, please make sure that you have checked the following 5 points before contacting technical support personnel: Can the robot arm lock normally after power-on? If it cannot be locked, please refer to FQA hardware-related questions: \"Q: How to solve the problem that the robot arm cannot be locked after power-on?\" for troubleshooting If you have an M5 series robot arm, is your computer connected to the USB port on the side of the M5stack via type-c? If you have an M5 series robot arm, is your screen LCD now stuck in the Atom: ok interface? If you have an M5 series robot arm, the LCD interface shows Atom: no, please refer to \"Q: How to solve the problem that the robot arm cannot be locked after power-on?\" for troubleshooting Is there any error message when running the code? Please describe the usage details as detailed as possible. If convenient, please provide an operation video, which will help to quickly analyze and locate the problem. Thank you in advance! "},"4-SupportAndService/9.Troubleshooting/9.2-software.html":{"url":"4-SupportAndService/9.Troubleshooting/9.2-software.html","title":"4.2 Software issues","keywords":"","body":"Software Issues 1 myStudio related Q: What is myStudio? A: It is our company's self-developed software. It is a tool for burning or modifying the firmware of the existing robot arm launched by our company. Q: What is the method to troubleshoot the abnormal download of minirobot, Atom, and PICO firmware? Check whether the network connection is normal. During the firmware download process, you need to connect to the network to download the firmware first. Check whether the line has been connected. The details are as follows: In the M5/Arduino series machine, when burning the Atom firmware, you need to use a USB cable to connect the Atom interface at the end to the USB port of the computer; when the M5 series machine burns the nimirobot firmware, use a USB cable to connect the side interface of the M5stack to the USB port of the computer. Select the firmware of the corresponding model, and don't choose the wrong model. Download and install the driver. If it still cannot be recognized after downloading the driver, try to replace the latest ch340 driver. If the port number still cannot be displayed after installing the driver and the system is a win11 model, try How to install the CH340 driver in Win11 system. Try to change a USB cable, USB port or computer to download it to avoid abnormal firmware download caused by the cable not having data transmission function. Uninstall mystudio and reinstall mystudio in a non-C drive location, such as installing mystudio in the D drive. When mystudio is installed in the C drive, the file permissions are relatively strict, and the firmware may not be burned. Q: Why does the device not work properly after I burn the firmware to the ATOM terminal? A: The firmware of the ATOM terminal needs to use our factory firmware. Other unofficial firmware cannot be changed during use. If the device accidentally burns other firmware, you can use \"myCobot firmware burner\" to select ATOM terminal-select serial port-select ATOMMAIN firmware to burn the ATOM terminal. Q: Can the drag teaching in the firmware record the gripper action? A: It is temporarily impossible to use drag teaching to record the gripper action, because the gripper belongs to joint number 7, and our drag teaching can only record and play the movement of joints numbered 1-6. Q: Why can't drag teaching be performed after burning the minirobot firmware? A: First check whether the M5Stack-basic firmware and atom firmware are burned, whether the burned firmware corresponds to the requirements to be implemented, and whether the burned firmware is the latest version of the firmware. It is recommended to burn the minirobot firmware to version v2.1 and the top atommain firmware to version v4.1 and above (need to support mystudio version v4.3.1 and above). Q: What should I do if mycobot's serial port cannot be recognized on mystudio? A: If your computer device does not prompt for the connected robot arm, please install the serial port driver first. In addition, it should be noted that the Raspberry Pi, Arduino and Jetson nano series robot arms are cannot be connected to a laptop using a data cable, and you need to use mystudio in the built-in system to burn the firmware. Q: Can the trajectory recorded by dragging teaching be saved to the card? A: It cannot be saved to the memory card at present. And dragging teaching can only save one path at a time, and the next recording will overwrite the previous action. 2 Roboflow Related Q: What should I do if I cannot download the Roboflow software or if Roboflow fails to properly control the robot? A: Currently, the Roboflow software only supports the 600 Pro and 630 Pro (two professional collaborative robot models). It no longer supports the Mycobot collaborative series or other robot models. For Mycobot-series robots, it is recommended to use MyBlockly, Python, or ROS for control. Notably, MyBlockly is a software with a graphical interface similar to Roboflow. If you prefer visual, block-based programming, MyBlockly is the preferred choice. ​ 3 Python related Q: The running prompt is missing library filesQ: The error message: ModuleNotFoundError: No module named \"pymycobot\", how to deal with it? A1: Pymycobot is not installed. The corresponding solution is to reinstall pymycobot. The command is pip3 install pymycobot --upgrade --user A2: During the installation of Python, the \"Add Pythonxx to PATH\" in the figure below was not checked. You need to uninstall Python and reinstall Python, and check this option. A3: If it is an M5 or AR series machine, please confirm whether there are multiple Python versions in the PC. It is recommended to uninstall all Python versions in the PC and reinstall a version higher than Python 3.8. Note that there is only one Python version higher than Python 3.8 in the PC. If multiple python versions are required for actual use, please specify the python version used by pymycobot and specify the python version when calling the pymycobot library. A4: It is recommended to use version 3.9 of pyhton, as pyhton12 will be incompatible. Q: Is there a more popular explanation for the mode in send_coords(coords, speed, mode)? A: Linear 1 means that the end of the robot reaches the target position in a straight line. If it cannot go in a straight line due to limitations, structure, etc., the command will not be fully executed; Linear 0 means that the end reaches the target position in an arbitrary posture. Since there is no straight line restriction, it is not easy for the command to not be executed. Q: What is the difference between the interpolation and refresh modes of set_fresh_mode(mode)? A: Interpolation 0 means that many dense points are planned between the starting point and the end point, so as to achieve the effect of controlling the trajectory of the middle segment. How to achieve the effect of program parallelism: Non-interpolation 1 means that there is no planning of the middle segment, and the trajectory cannot be controlled, but the movement will be relatively smooth. Q：Is it normal for the trajectory not to be straight up and down when only the Z-axis is changed, but the final landing point is adjusted only in the Z-axis? How can the middle trajectory be ensured to be straight？ Turn on interpolation and walk in a straight line to ensure the trajectory set_fresh_mode(0) # Turn on interpolation send_coords(coords, speed, mode=1) # Walk in a straight line Note that the intelligent planning route set in send_coords will only be useful after turning on interpolation. Interpolation means that many dense points are planned between the starting point and the end point, so as to achieve the effect of controlling the trajectory of the middle section. Non-interpolation means that there is no planning of the middle section, and the trajectory cannot be controlled. Q: What does the return value of get_error_information() being -1 mean? A: The return value of get_error_information() is -1, indicating that communication is not possible. You need to check whether the power adapter and USB cable are connected, and whether the LCD screen stays on the Atom: ok interface. If the line is not connected successfully and does not display ok, communication abnormalities will occur. You need to reconnect and test again. Q: In the case of drawing with a 280 machine, it is found that the shape trajectory is not very straight. Can it be optimized? A1: It is normal to get a deviation in the trajectory when using a signature pen or hard stationery to draw this case. There are two main reasons for this deviation. First, mycobot uses a servo motor, which has a certain accuracy deviation (if it is a machine that has been used for a long time, the deviation of its joints will be greater due to aging of the joints). Second, when using a hard pen to draw, the contact distance with the desktop is relatively demanding. If the distance is too high, the trajectory is prone to interruption. If the distance is too low, the pen tip resistance will be too large and the drawing effect is not ideal. It is currently recommended to use soft stationery for drawing, such as brushes and other tools, which will help improve the drawing effect. A2: In addition, you can change the motion mode of the robot arm to interpolation mode, so that the motion trajectory will be relatively straight. set_fresh_mode(0) # Enable interpolation send_coords(coords, speed, mode=1) # Go straight Note that the intelligent planning route set in send_coords will only be useful after interpolation is turned on. Interpolation means that many dense points are planned between the starting point and the end point to achieve the effect of controlling the trajectory of the middle section. Q: The target position is identified, but the end cannot reach it. How to determine whether this coordinate can be reached and then process it? A: Use solve inv kinematics(target coords, current_angles) to see if there is a solution. solve_inv_kinematics(target_coords, current_angles) Function: Convert coordinates to angles. Parameters: target_coords: list A floating point list of all coordinates. current_angles: list A floating point list of all angles, the current angle of the robot Return value: list A floating point list of all angles. 4 ROS related Q: Is there a virtual machine image with a configured environment? A: We have provided a virtual machine environment with configured ROS1 and ROS2 environments and built-in ROS source code. Users can download it through the following link and import the virtual machine file into VirtualBox, saving the trouble of configuring the environment by themselves. When testing ROS cases, it is recommended to use the virtual machine environment we have configured for verification to avoid some case operation errors due to environmental configuration reasons Please refer to the operation steps video of importing virtual machine files into virtual machine software: https://drive.google.com/file/d/1KeYk_CUgDE46rVn7zbd0EhraIbgt3qZt/view?usp=sharing ROS1 virtual machine file download Download ROS2 virtual machine file Download virtual machine software VirtualBox Q: How to deal with errors when importing ROS2 virtual machine files? A: This is because the version of the virtual machine software Oracle VM VirtualBox is too low, and the virtual machine software version needs to be updated. Q: How to re-download the ROS source code package? A: Use the command to pull: git clone https://github.com/elephantrobotics/mycobot_ros.git Or download manually. The download method is to enter the ROS source code package address and follow the steps below. The source code package address is: https://github.com/elephantrobotics/mycobot_ros Q: What should I do if I run the ROS moveit case and get an error ImprotError: No module named yaml? A: In the first line of this script, change the Python interpreter to python3 Q: What should I do if the serial port cannot be found when running the virtual machine? A: Use a USB cable to connect the M5 robot to the PC, open the virtual machine settings → USB device → Add USB device → Select the serial port number QinHeng xxxxx, which is the serial port device of the machine. If there is no such device number, you can get the corresponding USB device number by re-plugging the device. The serial port number corresponding to the machine serial port device number is the one that changes when plugging and unplugging. Q: Using a mujoco-based environment for simulation training, the robot's xml file is required A: Currently, there is only the 280JN xml file on GitHub: 280JN Provide customers with methods on how to convert dae and urdf files into xml files, and let customers use meshlab to convert by themselves. Q: When the terminal switches to ~/catkin_ws/src and uses git to install and update mycobot_ros, the target path \"mycobot_ros\" already exists. What is the reason? A: This means that there is already a mycobot_ros package in ~/catkin_ws/src. You need to delete it in advance and then re-execute the git operation. Q: When rosrun is running, the terminal reports an error message counld not open port /dev/ttyUSB0: Permission: '/dev/ttyUSB0', why? A: The serial port permissions are insufficient. Enter sudo chmod 777 /dev/ttyUSB0 in the terminal to grant permissions. Q: When rosrun is running, the terminal prompts Unable to register with master node [http://localhost:11311]: master may not be running yet. Will keep trying. Why? A: Before running the ros program, you need to open the ros node. Enter roscore in the terminal. Q: When rosrun is running, the terminal reports an error message counld not open port /dev/ttyUSB0: No such file or directory: '/dev/ttyUSB1', why? A: The serial port is incorrect. You need to confirm the actual serial port of the current robot. You can check it through ls /dev/tty*. Q: In Ubuntu 18.04, catkin_make failed to build the code, and the terminal prompted Project 'cv_bridge' specifies '/usr/include/opencv' as an include dir, which is not found. and other error messages A: The opencv path in the configuration file does not match the actual system path. You need to use sudo to modify the configuration file (the path is /opt/ros/melodic/share/cv_bridge/cmake/cv_bridgeConfig.cmake), and the actual system opencv path is under the /usr/include/ path. Q: I just cloned the mycobot_ros package, and then ran the rosrun program directly. The error package 'mycobot_280' not found or the file could not be found appeared? A: The mycobot_ros that I just cloned needs to build the code for ros environment compilation. Terminal input cd ~/catkin_ws/ catkin_make source devel/setup.bash Q: After the compilation is completed, why does the following error appear when the launch command is run in a new terminal? A1: The system does not add ros environment variables, so you need to source each time you open a new terminal: cd ~/catkin_ws/ source devel/setup.bash A2: The system adds ros environment variables, and you do not need to execute source each time you open a new terminal: # noetic is Ubuntu20.04 system echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc A3: The file name in the command may be inconsistent with the actual file name in the mycobot_ros package. Please check the command carefully for errors. 5 C++ related Q: What should I do if I can't find various dll files? A1: If myCobotCpp.dll is missing, put myCobotCpp.dl in the lib directory to the directory where mycobotcppexample.exe is located. A2: If QT5Core.dll is missing, open qt command (search QT in the menu bar), select msvc2017 64-bit, and execute windeployqt--release to the directory where myCobotCppExample.exe is located (such as: windeployqt --release D:lvs2019myCobotCpploutlbuildlx64-Releaselbin). If the vs installation path cannot be found after executing the command here, please check the settings of the vs environment variables. After executing the above steps, if the qt5serialport.dll file is missing, move this file in the gt installation directory (path such as: D:lgt5.12.1015.12.10msvc2017 64bin), copy it to the directory where myCobotCppExample.exe is located Q: Generate the myCobotCppExample.exe executable file, what could be the problem? Select the start "},"4-SupportAndService/9.Troubleshooting/9.3-hardware.html":{"url":"4-SupportAndService/9.Troubleshooting/9.3-hardware.html","title":"4.3 Hardware issues","keywords":"","body":"Hardware Issues Q: How to resolve the issue if the M5 screen is not displaying anything？ Check if the power adapter is properly connected to the machine. You can try unplugging and replugging the power adapter. Gently press on the corners of the screen to ensure that the M5stack is making good contact with the internal expansion board. Check the GitBook and download the corresponding MiniRobot firmware. You can remove the base screws to inspect whether any internal cables are disconnected. If so, reconnect them before use. Q: How to solve the problem that the robot arm cannot be locked when powered on? Check whether the original power adapter is connected or whether the adapter is in good contact. You can try to re-plug the power adapter Check whether the joint can rotate normally when the power is off, whether there is too much or too little resistance, and preliminarily determine whether the internal structure is physically broken. If there is no physical break, continue to check. Check the Atom firmware as follows: Under normal circumstances, the robot arm will self-lock after power is turned on, and the Atom will light up green, as shown in the figure below (note that mechArm has no light display) After the robot arm is powered on, the Atom does not light up green or the joint cannot self-lock. You can check according to the following points: ① Gently press the Atom screen to make Atom contact well with the internal plate of the robotic arm. ② Check gitbook to get the method of using mystudio. According to the model and version information, use mystudio to download the corresponding Atom firmware. If you encounter any problems during the burning process, please refer to the relevant \"Firmware download exception\" in this article mystuidio to obtain the troubleshooting steps. ③ When the Atom firmware is successfully burned and the robotic arm is not connected to the power supply, use type-c to connect Atom. If the green light of Atom is on, but the green light of Atom is off after unplugging type-c, it is judged that Atom is normal, but there is a problem of circuit detachment or damage inside the robotic arm, and it is necessary to contact the technician to deal with it. ④ When the Atom firmware is successfully burned and the robotic arm is not connected to the power supply, use type-c to connect Atom but the green light is not on, it is judged that the Atom hardware is damaged and it is necessary to contact the technician to replace it. Q: After pressing the emergency stop, the emergency stop cannot be locked after release. How to lock the robotic arm again? You need to power on the machine again, for example, power on the machine with myblockly Q: How to optimize joint jitter, excessive joint angle deviation or joint weakness? Refer to the robot parameter introduction section to check whether the actual load is within the effective load range of the robot arm. Excessive load will cause joint jitter. The load of the actual joint can be appropriately reduced. Change the motion mode to refresh mode, so that the running trajectory of the robot arm will be relatively smooth. For specific APIs, please refer to set_fresh_mode(1) Check the following link to adjust pid: https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing Check the gitbook section and use mystudio to download the corresponding version of Atom firmware. It is recommended to download the latest Check Chapter 5 of the gitbook to calibrate the robot arm at zero position. You can also refer to the calibration steps in the following link: https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing For machines that have been used for a long time (more than 3 months), joints may age and produce joint gaps. You can follow the following video to manually bend the joints to check if there is any joint gap: https://drive.google.com/file/d/1tXDUALmfw1z0u6lM9uH5hOHivjbRoWxW/view?usp=sharing If there is a joint gap problem due to joint aging, this kind of jitter is inevitable due to the natural aging of the machine. Q: What is the joint zero position? Take the following figure as an example, there is an arched groove designed between the joint and the edge of the joint shell, which is the joint zero point Generally, the zero point posture after calibration is as follows: Pay special attention to the zero position posture of the 270 joint as follows: Q: Is there a method for zero point calibration? Please refer to Chapter 5 of gitbook or the following link: https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q: Is the IO port of G36 unusable? Why is there no voltage return when measuring with a multimeter? A: 36 on basic can be used and is defined as an input pin. If the customer needs to test whether the IO can be used, the customer can modify the basic firmware code by himself. The firmware is open source. The customer writes a program by himself, single control IO Q: What are the limits of myCobot's joints? A: One axis and five axes have limits. One axis is about 165° clockwise and about 165° counterclockwise. The five axes can rotate about 165° clockwise and counterclockwise Note: When rotating the robot arm, it should be rotated at a small angle and gently. After reaching the limit, it cannot be rotated forcefully. Q: What is the role of atom in the robot arm? A: Atom is mainly used in the robot arm to control the kinematic algorithm of the robot arm: including forward and inverse kinematics, solution selection, acceleration and deceleration, speed synchronization, multi-square interpolation, coordinate conversion, etc., and requires real-time control and multithreading. The relevant programs of atom are not open source yet. Q: What communication interfaces do different versions of the robot arm support? A: The robot arm based on the microprocessor supports socket communication TCP; the robot arm based on the microcontroller can communicate via USB to serial port. "},"4-SupportAndService/9.Troubleshooting/9.1-accessories.html":{"url":"4-SupportAndService/9.Troubleshooting/9.1-accessories.html","title":"4.4 Accessories issues","keywords":"","body":"Accessory related questions Q: 280M5 and suction pump 2.0 io connection diagram and quick use source code A: The new version v2.0 version of myblockly source code is as follows: The G5 pin on the suction pump is the suction pump switch control pin, and the G2 label is the solenoid valve control pin. Both are low level valid. The function of the solenoid valve is to make the suction pump more rapid when released. If the solenoid valve is not used, the suction pump can also work normally, but the speed of releasing the object when the suction pump is closed is relatively slow. The source code here uses the G5 pin to control the opening and closing of the suction pump, and the G2 pin to control the opening and closing of the solenoid valve. The opening and closing of the solenoid valve mainly works in the stage of closing the suction pump. Note that the pins designated for connecting the suction pump and the machine end are not fixed. On the machine end, the G2 and G5 pins are not the only options. They can be replaced with any other two common GPIOs on the machine for control. However, when changing the control pins, you need to pay attention to the G2 and G5 pin function descriptions on the suction pump end - the pin corresponding to the G5 label on the suction pump end is the suction pump switch control pin, and the G2 label is the solenoid valve control pin, both of which are low-level valid. As shown in the following source code, GPIO18 and 19 are used to control the suction pump. G19 is selected to connect the suction pump's G5 to control the suction pump opening and closing, and the other G18 is connected to the suction pump's G2 pin to control the solenoid valve. Q: What is the pin sequence and connection method of mycobot adaptive gripper? Please refer to the following figure for the pin introduction of mycobot adaptive gripper: Gripper connection method: Q: Parallel gripper usage source code Q: Is there anything to pay attention to between the gripping object and the movement of the robot arm? When the load is > 500g, the speed needs to be less than 50%. "},"4-SupportAndService/9.Troubleshooting/9.0-other.html":{"url":"4-SupportAndService/9.Troubleshooting/9.0-other.html","title":"4.5 Others","keywords":"","body":"Other Issue Q：How to use the mycobot test tool？ A：The \"mycobot test tool\" is intended for factory use only, and we do not recommend users to use it. Using this tool may lead to abnormalities in the zero position or PID, resulting in damage to the robot. Please delete this tool directly. If you have already used this tool and it has caused abnormal movement of the robot, please refer to the following instructions to readjust the PID and zero position. Furthermore, refrain from continuing to use this factory test tool in future operations. Resetting PID method reference link: https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing Zero position calibration method reference link: https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q: After the vertical suction pump is turned off, there is no air leakage and the adsorption can be done normally. However, the vertical suction pump is still in the state of adsorption when the program ends. What is the reason? A: 1. First check if the GPIO port is connected incorrectly. The correct connection method is shown in the figure Pi connection method M5 connection method: If the above is correct but still not working, you can try to swap the high and low levels in the code to find out the reason Figure 1 (source code) Figure 2 (modified) According to the modified code, it can be checked whether the closed solenoid valve and the vent valve are high-level venting or low-level venting, and so on. Q: How to reset to factory settings when the machine is abnormal? Restoring to factory settings mainly depends on resetting the firmware, image, pid and zero position. The following is the reset solution: About resetting the firmware: It is recommended to ensure that mystudio is updated to the latest version, and then download the corresponding latest Atom version firmware, minirobot firmware (only available in M5 series machines) and pico firmware (only available in 320 series models). For the method of resetting the firmware, please refer to the mystudio chapter of gitbook About resetting the image: When resetting the image, all contents in the original system will be cleared. If there are important files, please save them in advance. For the method of resetting the image, please refer to the system usage chapter of gitbook About resetting pid: Generally, when the machine has severe joint shaking, abnormal joint movement speed, and joints curled up, the pid can be reset. For the reset method, refer to: https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing About resetting zero position: Generally, when the machine has an incorrect zero position or the joint limit is abnormal, the zero position can be recalibrated. For the reset method, refer to: https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q: Where is the download path for the urdf file? A: Please refer to the following path. The urdf of all mycobot models is in this path: https://github.com/elephantrobotics/mycobot_ros/tree/noetic/mycobot_description/urdf Q: How to troubleshoot if the robot arm cannot be controlled when using Bluetooth or WiFi? A: The M5 robot arm supports three communication methods, namely USB serial port, WiFi and Bluetooth communication. The most commonly used USB serial port communication method is required. Before using each communication method, you need to ensure that the LCD screen of the M5 is adjusted to the corresponding mode and maintain this communication state to control the robot arm normally. wifi communication mode: When using the TCP/IP example in the python chapter, you need to keep the M5's LCD screen in the wifi communication interface, as shown below: bluetooth communication mode: When using the mobile phone APP control, you need to keep the M5's LCD screen in the Bluetooth communication interface, as shown below: After ensuring that the communication mode status is selected correctly, try to control the robot arm again Q: How long is the command transmission delay when controlling the motor through the robot's controller via serial port or socket communication? Is there a communication timing diagram? How about real-time performance? There is no delay test data for serial or socket communication. According to the feedback from our development and use, the real-time performance is still quite high and there will be no lag. Q: What is the base coordinate system of the 280M5 robot? Q: Are the joints of 280 controlled by the serial bus? A: Yes Q: Is there more explanation about the understanding of coordinates? A: The API for controlling coordinate movement is send_coords([x,y,z,rx,ry,rz], speed) x, y, z coordinates: Control the position of the end effector of the robot in space. Changing these coordinate values ​​will move the robot to different spatial positions, thereby achieving positioning in three-dimensional space. rx, ry, rz attitude angles: Control the attitude or orientation of the end effector of the robot. These values ​​are usually given in the form of Euler angles, describing the rotation of the end effector of the robot relative to the base coordinate system, and the order of Euler angles is zyx. Changing these values ​​will rotate the end effector of the robot to different angles or directions. For example: When you adjust +X, this means that the position of the end effector of the current robot arm moves a certain distance along the positive direction of the X axis of the current end effector. This action will cause the robot to move in a certain direction as a whole. And when you adjust RX, this means that the attitude of the end effector of the current robot arm rotates a certain angle around the X axis of the current end effector. This action will cause the robot to rotate as a whole and the direction of the end effector will change. In general, the adjustment of +X and RX will directly affect the motion state of the robot arm. +X controls the movement of the position, while RX controls the change of attitude. If you want to see the changes more intuitively, we recommend that you use myblockly's serial control tool to adjust a parameter at a time and observe its changes in the coordinate system. Please note that when observing rx, ry, and rz, if you want to be more intuitive, please pay attention to adjusting x and ry when the J1 joint is 0, and adjusting y and rx when the joint is 90. You can refer to the coordinate system diagram below: Q: Is there more explanation about the Offset of the DH parameter? Is the Offset rotated around z? A: The DH parameter describes the geometric and kinematic relationship between adjacent links in the robot arm. In the DH parameter table, the Offset parameter indicates the effect of the previous link rotating around its z-axis on the position of the next link, that is, the offset when connecting two links. For the Offset parameter in the robot arm, it generally indicates the effect of the previous link rotating around its own z-axis on the position of the next link, rather than rotating around the z-axis of the next link. Therefore, Offset is not a rotation around z, but a displacement when connecting two links. Q: What is the voltage range of the 280 robot arm power supply? How much is the instantaneous current? A: 12V plus or minus 10%, 5A Q: What is the inner diameter of the J1 joint of the 280M5? A: 70mm Q: Why are two coordinate systems defined at F1 in this DH model of the 280m5? Q: Following the above question, why are the physical distances of axis 1-2 different, but the origin settings are overlapping? A: Because the rotation axes intersect, DH modeling has regulations. If the rotation axes of adjacent joints intersect, the origin must be set at the intersection Q: If the servos of each axis are controlled and feedback is obtained, what is the shortest communication cycle? A: This needs to be determined according to the speed. The minimum response time is 50ms Q: Does the mycobot series machine have collision detection? A: 280 has algorithmic collision self-interference, which has been integrated into the API for setting joint angles and coordinates Q: What are the input parameters of Atom's USB interface? A: 5V @ 500mA Q: How to deal with the 270 j3 joint not being able to display joint values ​​in real time? A: Reference link: https://drive.google.com/drive/folders/1BrvMxJltcLsr8T8-4kKOB7SH0D_qZkIP?usp=sharing The corresponding firmware has been replaced, and the corresponding python file can be run directly Q: How to deal with the VNC dragging jam? A: If the jam is caused by dragging any window in VNC, you can make some configurations according to the picture below. The options need to be consistent with the picture below. After successful setting, the problem of VNC disconnection caused by dragging the window will be solved. Q: When replacing the second joint of 280, I found that 4 screws were stripped. How to remove them? Regarding the replacement of joints, the 4 screws do not need to be removed. Please remove the large screw in the middle, then fix the J2 joint body back, and then use force to pull out the entire coupling. I recorded a video for you to refer to for specific operations Q: Is the joint torque information provided? A: Our machines only provide the overall information of the entire joint, and do not provide the internal torque, voltage and current of the servo and motor actuator. The overall parameters of the robot arm are disclosed, such as repeatability, power supply voltage, etc. Q: How do you understand the relationship between the two coordinates in the following figure? A: If you want to view the transformation relationship between the coordinate system named \"turtle1\" and the coordinate system named \"turtle2\", you can use this command. In layman's terms, when you run this command, it will tell you the position and direction information of an object (\"turtle1\") relative to another object (\"turtle2\"). Just like you can know the position of a city relative to another city on a map Q: The environment of ROS2 has been accidentally changed. Can I just delete the 280pi ROS and reinstall it myself? A: Regarding the issue of reinstalling ROS, we do not recommend users to reinstall it themselves, because the construction of the ROS environment is relatively complex and prone to errors. If you need to reset the ROS environment, we recommend users to re-write the system image. For specific methods, please refer to Development and Use Based on ROS Q: How to transfer files from the host to the virtual machine A: Set up a shared folder as shown below to transfer files from the PC to the virtual machine Q: How to solve the problem of excessive repeated positioning deviation after the robot arm is in place at the same position? Both new and old machines can adjust pid to reduce deviation as much as possible. Appendix: https://docs.qq.com/doc/DU0VhT2JNVUdNUEJS, https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing However, the old version of the machine has gear gaps in the 2nd and 4th joints of the robot arm, which is easy to produce joint deviations under the action of gravity, which ultimately affects the end precision. The forces of the 2nd and 4th joints in these four sets of joint values ​​are inconsistent, so the precision is also different. It is currently recommended to adjust through the program. When the machine reaches the point, you can read the point again at this point to check if there is a deviation. On this basis, adjust the specific deviation value of the single joint to achieve the effect of reaching the specified point. Q: What is the difference between API and serial port instructions to directly control joints? API provides a simplified and abstract interface to make development more efficient and easy, suitable for rapid development and integration. Serial port commands provide direct, low-level control, suitable for scenarios that require fine-tuning or development of custom functions, but are usually more complex to develop and debug. In general: Using serial port commands to directly control the robot arm is more flexible, but also more complex, requiring a deep understanding of the communication protocol; while using API control is simpler and more convenient, but may be limited by the functions and performance provided by the API. Q: Windows runs git commands and reports errors A: This is caused by not installing git. You need to install git first and then use git commands Q: When using Arduino with 280M5, if you use a vertical suction pump, you cannot use the 2 and 5 IO ports. These two IO ports are occupied by the serial port. You can use other IO ports to control it. You can use the following code to control it. #include void setup() { pinMode(1,OUTPUT); pinMode(3,OUTPUT); } void loop() { delay(100); digitalWrite(1,1); delay(100); digitalWrite(3,0); delay(100); digitalWrite(1,0); delay(100); digitalWrite(3,1); delay(1000); } Q: What is the difference between MDI and JOG? A: MDI (Manual Data Input) is called the set value direct given operation mode. That is, after the upper controller directly sets the target position, speed, acceleration and deceleration, the axis automatically moves to the target position. MDI is also the most commonly used positioning function in practical applications. JOG moves continuously in a certain direction. Q: Overseas maintenance policy form Q: What is the latest supported version of pymycobot for each model? Q: How to distinguish between standard and improved DH tables sdh, std, standard mdh, modify, improved We provide standard DH tables. Customers can convert them by themselves if necessary. They are just two different description methods. Q: How to deal with the error of missing opencv_camera? A: The error message shows that the executable permission is missing. You may need to add the permission. Change to using mycobot_280 instead of pi itself, because the m5 side has occupied the file. Both sides cannot occupy it at the same time, otherwise it will cause the subsequent compilation to fail. Q: How to check the data transmission speed? A: Use the following code: import time from pymycobot.mycobot import MyCobot mc = MyCobot(\"COM8\",115200, debug = True) while 1: mc.get_angles() Write indicates the acquisition command sent, read indicates the returned message, and the left side indicates the time. Here, 518write + 611read are displayed, indicating that a get_angles read was completed in about 100ms, with a frequency of 10hz. Q: The indicator light of the adapter is not on A: It is possible that the adapter is powered off for self-protection after a short circuit. Disconnect the adapter for a few minutes before using it. If it does not work after a few minutes, wait a little longer. After 15 minutes, power on the adapter separately to see if it lights up. Q: A joint of the robot arm cannot move. How to deal with it? A: You can use a python script to read the angle in a loop, and then manually turn the joint to see if the angle changes. If there is a return value, check the following points and return the information to the technical support staff. Use get_servo_status to check if the J2 servo has hardware problems such as undervoltage/overvoltage Manually turn J2 to see if there is obvious resistance, and compare it with other joints; enable focus_servo(2) on J2 separately Use the script to check if there is any problem with the parameters Q: End zero position abnormality A: After using the adaptive gripper to grip objects for a long time, the gripper and end zero position abnormality will occur, and the gripper needs to be stationary. Q: What is forward kinematics and inverse kinematics? A: Forward kinematics refers to solving the position and posture of the robot's end effector (such as the gripper of the robot arm) in Cartesian space when the angles (or displacements) of each joint of the robot are known. It is implemented in the get_coords() API, but the specific algorithm is not public. Inverse kinematics is the opposite of forward kinematics. It refers to solving the angles (or displacements) of each joint of the robot when the position and posture of the robot's end effector in Cartesian space are known. write_coords(), send_coords() "},"3-FunctionsAndApplications/5.BasicFunction/":{"url":"3-FunctionsAndApplications/5.BasicFunction/","title":"5. Basic functions","keywords":"","body":"Chapter 5 Basic Functions This chapter mainly explains the basic functions and basic software usage of the product. This chapter is very important and should be read carefully. Before actually applying the robot, please make sure you understand the described operations correctly. 5.1 System (Function) Instructions This section will introduce the drivers that need to be installed before using the product and the factory firmware introduction. 5.2 Software Instructions myStudio is a one-stop platform for the use of myRobot/myCobot and other robots. It is convenient for users to select different firmware and download them according to their own usage scenarios, and at the same time learn related teaching materials and browse tutorial videos online. 5.3 Firmware Function Description This section will introduce the difference between microprocessors and microcontrollers, firmware burning instructions, and how to use the four main functions of the factory firmware for microcontroller devices: miniRoboFlow. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5.BasicFunction/5.1-Functionlnstruction/":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.1-Functionlnstruction/","title":"5.1 System (function) instructions","keywords":"","body":"Basic Function Application myStudio Before you start using the device, you first need to install the driver and update the device firmware. Install the driver Users can click the button below to download the corresponding CP210X or CP34X driver package according to the operating system they are using. After unzipping the package, select the installation package corresponding to the operating system bit number for installation. There are currently two driver chip versions, CP210X (for CP2104 version)/CP34X (for CH9102 version) driver package. If you are not sure about the USB chip used by your device, you can install both drivers at the same time. ( CH9102_VCP_SER_MacOS may have an error during the installation process, but it has actually been installed, so just ignore it.) For Mac OS, make sure the system \"Preferences->Security and Privacy->General\" is set before installation, and allow downloads from the App Store and approved developers. Download the bottom M5Stack-basic serial port driver CP210X Windows10 MacOS Linux CP34X Windows10 MacOS Download the terminal Atom serial port driver Windows10 Please follow this picture to complete the driver installation Update device firmware Before development, users should confirm whether the device firmware they are using is the latest version of the firmware, so that users can better use the device in subsequent development. Users can update the device firmware through myStudio. Factory firmware introduction Drag teaching Robot drag teaching means that the operator can directly drag the robot joints to move to the ideal posture and record it. Collaborative robots are the earliest systems with this function. This teaching method can avoid the various shortcomings of traditional teaching and is a technology with great application prospects in robots. Calibrating the robot arm Calibrating the robot arm is the prerequisite for precise control of the robot arm. Setting the joint zero position and initializing the potential value of the motor are the basis for subsequent advanced development. Communication The timeliness of communication is crucial for microcontroller manipulators. For microcontroller manipulators, we usually send control instructions to the Basic at the bottom. Through communication forwarding, the end effector will parse the instructions and then execute the target action. Currently, the communication methods of microcontroller devices are: serial communication, Bluetooth communication, WIFI communication. Users can choose the applicable communication method and perform programming operations. Connection detection Connection detection is a detection function for the connection status of the motor and Atom in the manipulator. This function is convenient for customers to troubleshoot equipment failures. In the connection detection, the device connection status of the manipulator can be seen, including servo connection and Atom communication status. Microcontroller devices The current firmware version of the device will be displayed on Basic. First use After understanding the existing functions of the firmware, please follow the steps in this section to start connecting and fixing the machine and start using the basic functions of the device. "},"3-FunctionsAndApplications/5.BasicFunction/5.2-Softwarelnstructions/":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.2-Softwarelnstructions/","title":"5.2 Software instructions","keywords":"","body":"myStudio Original intention of myStudio design myStudio is a one-stop platform for using robots such as myRobot/myCobot. It is convenient for users to select different firmware and download them according to their own usage scenarios, and at the same time learn related teaching materials and browse tutorial videos online. myStudio latest version and supported platforms Latest version: V3.5.8 Applicable to: Windows, Mac, Linux myStudio features Burn and update firmware Provide robot tutorials, such as user manuals, video tutorials, Q&A, etc. Information on maintenance and repairs myStudio applicable devices myCobot 280 myCobot 280 M5 myCobot 280 PI myCobot 280 Jetson Nano myCobot 280 for Arduino Firmware version recommendation Different models of robotic arms require different firmware to be burned. The following are the firmware versions recommended for burning different models of robotic arms. myCobot 280 series The myCobot 280 series has 4 versions: M5 version, PI version, ardunio version and jetsonnano version. Different versions have different core models, and the firmware and versions required to be burned are also different. Robot version number Core Required firmware to be burned Recommended firmware and version M5 version M5Stack-Basic miniRobot firmware Recommended to burn v2.1 version, you can use drag teaching, wifi, Bluetooth and other functions Atom atomMain firmware For products with serial numbers ER28001202200415 and earlier, or products without serial numbers, it is recommended to burn v4.1; for products with serial numbers ER28001202200416 and later, it is recommended to burn v5.1 myStudio environment setup myStudio download and installation Note: The installation path of myStudio cannot have any spaces Download address: 1. GitHub address After entering the download address, click myStudio on the right and select the corresponding version to download. Different suffixes represent different systems, please download the corresponding version: *.tra.xz —— Linux system *.dmg —— Mac system *.exe —— Window system 2. Official website address You can download it according to your computer system. Note: Please download the latest version. You can view the current version in the downloaded myStudio interface and update to the latest version. Driver Installation Users can click the button below to download the corresponding CP210X or CP34X driver package according to their operating system. After decompressing the package, select the installation package corresponding to the operating system bit number for installation. There are currently two driver chip versions, CP210X (for CP2104 version) and CP34X (for CH9102 version) driver package. If you are not sure which USB chip your device uses, you can install both drivers at the same time. ( During the installation process, an error may appear for CH9102_VCP_SER_MacOS, but the installation has actually been completed, so just ignore it.) For Mac OS, before installing, make sure that the system \"Preferences->Security and Privacy->General\" is set and that it allows downloads from the App Store and approved developers. Download the bottom M5Stack-basic serial port driver CP210X Windows10 MacOS Linux CP34X Windows10 MacOS Download the terminal Atom serial port driver Windows10 How to distinguish CP210X and CP34X chips As shown in the figure below, open Device Manager and check Ports (COM and LPT) If Port (COM and LPT) shows USB-Enhanced-SERIAL CH9102, it is CP34X chip If Port (COM and LPT) shows Silicon Labs CP210x USB to UART Bridge, it is CP210X chip Burn and update firmware myStudio video tutorial Burn M5Stack-Basic firmware Note: Pi series robot arms do not need to burn M5Stack-Basic firmware. Step 1: Connect to PC. The connection method between M5Stack-Basic and PC is shown in the figure below: Step 2: Select the port. After connecting, the USB port in the connection window of myStudio will show the connected development board (here is the myPalletizer 260M5 version as an example): Step 3: Click Login->M5Stack-basic to burn the required firmware: Note: The 280 PI/Jetson nano/Arduino version does not have M5Stack-basic, so it will display \"No data\" after connecting to myStudio. Burn Atom firmware Step 1: Connect to PC. Connect the Atom at the end with USB. Step 2: Select ATOM in the Board column, and the Atom firmware will appear in the Basic sidebar. There is only one Atom firmware, click to burn it (the following figure takes myCobot 280 as an example). 5.Power on and preliminary test myCobot must be powered by an external power supply to provide sufficient power: Rated voltage: 12V Rated current: 3-5A Plug Type: DC 5.5mm x 2.1 Note that you cannot just use the TypeC plugged into the M5Stack-basic for power. Use the official power adapter to avoid damage to the robot. Graphic guide Connect the power supply Start after connecting the power cord. Use the Type-C cable to connect to the corresponding USB port of the computer and the robot M5Stack-basic, and perform a connection test. The connection test is a detection function for the motor and Atom connection status in the robot. This function is convenient for customers to troubleshoot equipment failures Connection detection Step 1: Atom burns the latest version of atomMain. Step 2: M5Stack-basic burns minirobot, select Information function. Step 3: Press A key to start connection detection. The screen displays Atom and the connection status of the six motors. As shown in the figure, the motor connection is in good condition Step 4: Press the B key to start detecting the version information. The screen displays the robot version and the Basic firmware version. Step 5: Press the C key to exit this function The power-on detection is completed. "},"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/","title":"5.3 Firmware Function Description","keywords":"","body":"Factory firmware introduction Only introduce the myCobot series, myPalletizer series and mechArm series, which are divided into two categories: microcontrollers and microprocessors. Microcontroller devices: myCobot 280 M5 myCobot 320 M5 myPalletizer 260 M5 mechArm 27 M5 Microprocessor devices myCobot 280 Pi myCobot 320 Pi mechArm 270 Pi The difference between microprocessors and microcontrollers is mainly concentrated in three aspects: hardware structure, application field and instruction set characteristics: Hardware structure. The microprocessor is a single-chip CPU, while the microcontroller integrates the CPU and other circuits in an integrated circuit chip to form a complete microcomputer system. In addition to the CPU, the microcontroller also includes RAM, ROM, a serial interface, a parallel interface, a timer and an interrupt scheduling circuit. Application field. Microprocessors are usually used as CPUs in microcomputer systems. They are designed for such applications, which is also the advantage of microprocessors. However, microcontrollers are usually used in control-oriented applications, and the system design pursues miniaturization and minimizes the number of components. Microcontrollers are suitable for those occasions where input/output devices are controlled with very few components, while microprocessors are suitable for information processing in computer systems. Instruction set characteristics. Due to different applications, the instruction sets of microcontrollers and microprocessors are also different. The instruction set of microprocessors enhances processing capabilities, giving them powerful addressing modes and instructions suitable for operating large-scale data. Microprocessor instructions can operate on nibbles, bytes, words, and even double words. By using address pointers and address offsets, microprocessors provide addressing modes that can access large amounts of data. The self-increment and self-decrement modes make it very easy to access data in units of bytes, words, or double words. 1. Factory firmware for microcontrollers: miniRoboFlow miniRoboFlow has four main functions: Drag teaching (Maincontrol) Robot drag teaching, the operator can directly drag the robot joints to move to the ideal posture, and save the action in the machine through button operation. Collaborative robots are the earliest systems with this function. This teaching method can avoid the various shortcomings of traditional teaching and is a technology with great application prospects in robots. Calibration (Calliberation) Calibrating the robot arm is the prerequisite for precise control of the robot arm. Setting the joint zero position and initializing the motor potential value are the basis for subsequent advanced development. Computer control（Transponder) The timeliness of communication is very important for microcontroller robot arms. For microcontroller robot arms, we usually send control instructions to the M5Stack-basic at the bottom. Through communication forwarding, the end effector will parse the instructions and then execute the target action. At present, the communication methods of myCobot 280 are: serial communication, Bluetooth communication, and WIFI communication. Connection detection（Information) Connection detection is a detection function for the connection status of the motor and Atom in the robot arm. This function is convenient for customers to troubleshoot equipment failures. In the connection detection, the device connection status of the robot arm is seen, including the connection of the servo and the communication status of the Atom. The current firmware version of the device will be displayed on the M5Stack-basic in the microcontroller device. "},"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.1-moving/5.3.1.1-micro_controller.html":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.1-moving/5.3.1.1-micro_controller.html","title":"5.3.1 Drag teaching","keywords":"","body":"Implement drag teaching Drag teaching Robot drag teaching means that the operator can directly drag the robot's joints to move to the ideal posture and record it. Collaborative robots are the earliest systems with this function. This teaching method can avoid the various shortcomings of traditional teaching and is a technology with great application prospects in robots. Depending on the device type, the operation method is also different, the steps are as follows: Atom burn the latest version of atomMain M5Stack-basic burn minirobot, select Maincontrol function, microprocessor devices do not need to burn M5Stack-basic Press the record button/keyboard key Select the storage path, microprocessor devices do not have this step You can directly drag the joints of the robot arm to the expected position to complete a set of movements Press the specified button/keyboard key to save Press the play button/keyboard key/keyboard key Select the relative storage path, and the robot arm starts to move Press the exit button/keyboard key to exit this function In this section, we will teach you how to get started easily and experience the fun of collaborative robot dragging teaching Applicable devices myCobot 280 M5 myCobot 320 M5 myPalletizer 260 M5 mechArm 270 M5 Operation steps Step 1: Burn the latest version of atomMain in Atom. Step 2: Burn minirobot in M5Stack-basic and select the Maincontrol function. Step 3: Press the Record button. Step 4: Select the storage path and press Ram or Flash. Step 5: Drag the joints of the robot arm to the desired position to complete a set of movements. Step 6: Press any key to stop recording and save the record Step 7: Press the Play button Play. Step 8: Click the storage path just selected, press Ram/Flash, and the robot arm starts playing the saved record. Step 9: Press Pause to pause the movement, press Stop to stop the movement, and press Play to resume the movement. Video tutorial Tutorial video address: https://www.bilibili.com/video/BV16t4y167vw/ "},"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.2-calibration/5.3.2.1-micro_controller.html":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.2-calibration/5.3.2.1-micro_controller.html","title":"5.3.2 Calibration","keywords":"","body":"Implement robot arm calibration Calibrate the robot arm Tip: By default, the robot has already been operated before leaving the factory, so there is no need to repeat the operation. Incorrect use of this function may cause damage to the robot. If your robot works normally, please do not use it. Thank you for your cooperation. Calibrating the robot arm is the prerequisite for precise control of the robot arm. Setting the joint zero position and initializing the motor potential value are the basis for subsequent advanced development. Depending on the device type, the operation method is also different, the steps are as follows: Atom burn the latest version of atomMain M5Stack-basic burn minirobot, select Calibration function, microprocessor devices do not need to burn Basic Turn each joint of the robot arm to the zero position state (zero position scale line is aligned), press the calibration button to start calibrating the robot arm Press the test button to test the zero position of each joint of the robot arm Press the exit button to exit this function In this section, we will teach you how to calibrate the robot arm step by step, and after calibration, test and verify the joints of the robot arm. Applicable devices myCobot 280 M5 myCobot 320 M5 myPalletizer 260 M5 mechArm 270 M5 Operation steps Step 1: Atom burns the latest version of atomMain. Step 2: Basic burn minirobot, select Calibration function. Step 3: Press A key to start calibrating the robot arm. Step 4: First drag the robot arm to make joint 1 reach the zero position (zero position scale line is aligned). Step 5: According to the motor number (1~6) indicated on the screen, drag the robot arm to make each joint reach the zero position (align the zero position scale line) Step 6: Press NEXT in sequence to enter the next motor calibration until Already Calibrate all!! appears, and the calibration is completed. Step 7: Press EXIT to exit the calibration. Step 8: Press the B key to test the zero position of each joint of the robot arm. Step 9: Press the C key to exit this function. Video tutorial Address: https://www.bilibili.com/video/BV1FT4y1P7BV/ "},"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.3-transponder/5.3.3.1-micro_controller.html":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.3-transponder/5.3.3.1-micro_controller.html","title":"5.3.3 Computer control","keywords":"","body":"Computer control The timeliness of computer control is crucial for microcontroller robotic arms. For microcontroller robotic arms, we usually send control instructions to the Basic of the base, forward them through computer control, and the end effector will parse the instructions and then perform the target action. This function is currently mainly used by customers to develop robotic arms in different environments. Depending on the device type, the operation method is also different, the steps are as follows: Atom burns the latest version of atomMain M5Stack-basic burns minirobot, selects Transponder function, microprocessor devices do not need to burn M5Stack-basic Press the detection key to detect whether Basic and the end effector Atom are communicating normally Press the exit button to exit this function In this section, we can detect in real time whether Basic and the end effector Atom are communicating normally. Realize communication forwarding Applicable devices myCobot 280 M5 myCobot 320 M5 myPalletizer 260 M5 mechArm 270 M5 Operation steps Step 1: Atom burns the latest version of atomMain. Step 2: M5Stack-basic burns minirobot, selects the Transponder function. Step 3: Check the connection of Atom (ok means the connection is normal, otherwise it will display no). Step 4: Click Exit to exit this function. "},"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.4-connection/5.3.4.1-micro_controller.html":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.3-FirmwareFunctionDescription/5.3.4-connection/5.3.4.1-micro_controller.html","title":"5.3.4 Connection detection","keywords":"","body":"Connection detection Connection detection is a function that detects the connection status of the motor and Atom in the robot arm. This function is convenient for customers to troubleshoot equipment failures. In the connection detection, the device connection status of the robot arm is displayed, including servo connection and Atom communication status. The current firmware version of the device will be displayed on M5Stack-basic in microcontroller devices. Depending on the device type, the operation method is also different, the steps are as follows: Atom burn the latest version of atomMain M5Stack-basic burn minirobot, select Information function, microprocessor devices do not need to burn M5Stack-basic Press the detection button to detect the device connection status Press the firmware view button to view the current firmware version Press the exit button to exit this function In this section, we can learn how to use the device detection function for different types of devices. Applicable devices myCobot 280 M5 myCobot 320 M5 myPalletizer 260 M5 mechArm 270 M5 Operation steps Step 1: Atom burn the latest version of atomMain. Step 2: M5Stack-basic burn minirobot, select Information function. Step 3: Press the A key to start the connection detection. The screen displays Atom and the connection status of the six motors. Step 4: Press the B key to start the version information detection. The screen displays the robot version and Basic firmware version. Step 5: Press the C key to exit this function. "},"3-FunctionsAndApplications/5.BasicFunction/5.4-RobotPrecisionControl/":{"url":"3-FunctionsAndApplications/5.BasicFunction/5.4-RobotPrecisionControl/","title":"5.4 PID control","keywords":"","body":"Introduction to Motor PID Modification of the PID parameters can be a trade-off between the control accuracy of the robotic arm and the stability of the movement, we provide two sets of PID parameters, which are suitable for occasions requiring high stability of the movement, and for occasions requiring high precision of the movement. Applies to PID parameters with smooth motion, where motion accuracy is affected by false positives: ''' This document is applicable to the myCobot 280 series of robotic arms. The function is to modify the joint motor configuration parameters and verify the modification results.Please ensure that the robot control port is not occupied when using it. If you encounter failure, please run the file again. #Import dependent library files. import time from pymycobot import * #Define data address and data. #Define the serial port of the robotic arm，Please check your robot model and fill in the corresponding content. # _port = '/dev/ttyAMA0' _port = 'COM30' _baud = 115200 #Instantiate a hardware serial port. try: mc = MyCobot280(_port, _baud) except Exception as e: print(e) print(\"Error: The current serial port can not be used, please check whether the serial port serial number is correct, after confirming that there is no error, please re-run the program.\") exit() #Loop modification and display modification results. #joint_id = 1 - 6. for i in range(1,6): mc.set_servo_data(i,23,0) time.sleep(1) print(mc.get_servo_data(i,23)) input(\"The program ends, please press any key to exit.\") exit() PID parameters suitable for high-precision scenarios will cause the arm to continuously adjust the steady state error: ''' This document is applicable to the myCobot 280 series of robotic arms. The function is to modify the joint motor configuration parameters and verify the modification results.Please ensure that the robot control port is not occupied when using it. If you encounter failure, please run the file again. #Import dependent library files. import time from pymycobot import * #Define data address and data. #Define the serial port of the robotic arm，Please check your robot model and fill in the corresponding content. # _port = '/dev/ttyAMA0' _port = 'COM30' _baud = 115200 #Instantiate a hardware serial port. try: mc = MyCobot280(_port, _baud) except Exception as e: print(e) print(\"Error: The current serial port is not available, please check whether the serial port serial number is correct or not, after confirming that there is no error, please re-run the program.\") exit() #Loop modification and display modification results. #joint_id = 1 - 6. for i in range(1,6): mc.set_servo_data(i,23,4) time.sleep(1) print(mc.get_servo_data(i,23)) input(\"The program ends, please press any key to exit.\") exit() "},"3-FunctionsAndApplications/6.developmentGuide/":{"url":"3-FunctionsAndApplications/6.developmentGuide/","title":"6. Software development guide","keywords":"","body":"Chapter 6 Software Development Guide Usage Environment myCobot Pro 450 is developed and used based on PC. Since there is no built-in system in the robot arm, the robot arm and PC need to be combined during use. Please prepare the PC before use. Development Environment In order to meet the diverse application needs of robots in different scenarios, we have adapted the robot to multiple programming languages. So far, we have adapted the following mainstream programming languages, and we think you can use any of the following languages ​​for development. Please be sure to follow the instructions strictly. Any omitted steps may cause the corresponding language to fail to run successfully. I wish you a smooth use of the robot. 6.1 Python Our robot supports Python, and the development of the Python API library is also becoming more and more perfect. The robot's joint angles, coordinates, grippers and other aspects can be controlled by Python. 6.2 ROS1 ROS (Robot Operating System), as an open source robot operating system, provides unlimited possibilities for robot development and control. Our robot can be controlled in a modular way through ROS's rich control functions. Whether it is joint control, path planning or sensor feedback, ROS provides corresponding tools and libraries to make the control process more flexible and efficient. 6.3 ROS2 ROS 2 (Robot Operating System 2) is a flexible software framework designed for robot software development. Our robot can make application development more efficient and modular through a series of services and functions such as hardware abstraction, device drivers, library functions, visualization tools, messaging, and package management. 6.4 myStudio Pro myStudio Pro is a One-stop robot programming and control software, supporting visual programming interaction, quick movement control, drag teaching, and robot status query and configuration. 6.5 C++ C++ is the inheritance of C language. It can be used for both procedural programming in C language and object-based programming characterized by abstract data types. Using C++ language, you can freely develop (coordinate control, angle control, io control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. 6.6 Communication If you have a certain understanding of information theory, coding and robot communication functions, then you should understand that all communication originates from data transmission. In order to facilitate users to operate the robot, we have opened a communication protocol based on serial communication. You can use the serial assistant or encapsulate it into any programming language you are familiar with to control the robot. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/","title":"6.1 Development and use based on python","keywords":"","body":"What is Python? Our products are very friendly to Python, and the development of Python API library is also improving day by day. Through Python, the robot's joint angles, coordinates, grippers and other aspects can be controlled. There are many options. If you want to control our robot arm through Python programming, you can learn this chapter. Python was designed by Guido van Rossum of the Netherlands Institute for Mathematical and Computer Science Research in the early 1990s as a replacement for a language called ABC. Python provides efficient high-level data structures and simple and effective object-oriented programming. Python syntax and dynamic typing, as well as the nature of interpreted languages, make it a programming language for writing scripts and rapidly developing applications on most platforms. With the continuous update of versions and the addition of new language functions, it is gradually used for the development of independent and large projects. Python interpreter is easy to extend, and can be extended with new functions and data types using C or C++ (or other languages ​​that can be called from C). Python can also be used as an extension language in customizable software. Python has a rich standard library that provides source code or machine code for all major system platforms. Python development and use guide You can use Python to develop our robot arm according to the following guidelines Environment construction API description Joint control Coordinate control IO control Gripper control Robot exception handling ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html","title":"6.1.1 Environment Construction","keywords":"","body":"Environment setup pymycobot is a Python package for serial communication with myCobot, supporting Python3.5 and later versions. Before using pymycobot to control the robot arm, you need to build a Python environment. The following is a detailed description of Python download and installation. Linux System Install the pymycobot library in the console terminal: pip install pymycobot --upgrade --user Windows System Download and install Python Applicable devices: myCobot Pro 450 Currently, there are two versions of Python, one is 2.x version and the other is 3.x version. These two versions are incompatible. As 3.x version is becoming more and more popular, our tutorial will take the latest 3.10.7 version as an example. Install Python Note: Before installing, please confirm whether your computer is 64-bit or 32-bit. Right-click My Computer and select Properties. As shown in the figure below, it is a 64-bit operating system, so select the 64-bit Python installation package. Python official download address: https://www.python.org/downloads/ Click the Downloads option to start downloading Python, click Add Python 3.10 to PATH, click Install Now to start installing Python The prompt \"Setup was successful\" appears, indicating that the installation is complete Run Python After successful installation, open the command prompt window (Win+R, enter cmd and press Enter), and type python. Two situations will occur. Situation 1: The prompt in the picture indicates that Python has been successfully installed. The prompt >>> indicates that we are already in the Python interactive environment. We can enter any Python code and get the execution result immediately after pressing Enter. Case 2: If the input is wrong (for example, enter pythonn), an error message will appear: Note: The error message is generally caused by not configuring the environment variables. You can refer to 1.3 Configure environment variables to modify the environment variables. Configure environment variables Since Windows will search for python.exe according to the path set by a Path environment variable, if it is not found, an error will be reported. Therefore, if you miss checking Add Python 3.10 to PATH during installation, you need to manually add the path where python.exe is located to Path, or reinstall Python and remember to check the Add Python 3.10 to PATH option. The following are the steps to manually add the path where python.exe is located. Right-click My Computer –> Select Properties –> Select Advanced System Settings –> Select Environment Variables in the lower right corner: Environment variables mainly include user variables and system variables. The environment variables that need to be set are in these two variables. As shown in the figure below: User variables are used to download programs that can be used in cmd commands. Write the absolute path of the program to the user variable and you can use it, as shown in the figure below: After completing the above steps, open the command prompt window (Win+R, then enter cmd, press Enter), type Python, and the prompt in the figure below indicates success: PyCharm installation and use PyCharm is a powerful Python editor with cross-platform capabilities. First, let's introduce the installation steps of PyCharm in Windows system. Download address: https://www.jetbrains.com/pycharm/download/#section=windows Download and install After entering the website, we will see the following interface: Download the file according to the interface introduction. Professional means professional version, and Community means community version. It is recommended to install the community version because it is free to use. After downloading, start installing and click Next: Select the corresponding options according to your personal preferences, and then click Next: The following interface appears and continue to click Next: Click Finish to complete the installation: Create a project After PyCharm is installed, enter the software and create the first program. Click the PyCharm icon on the desktop to enter PyCharm, as shown in the figure below, and click New Project: After clicking, find Interpreter, start setting the interpreter, and click Add Interpreter: Click New, find the python.exe storage location, and check the Inherit global site-package option: Set Location. Location is where the PyCharm project is stored. You can choose it according to your needs. Create a new PyCharm file. Right-click the document icon pointed by the arrow, click New, click Python File, and the new file is created successfully. Name Python File: After the file is successfully created, you will enter the following interface and you can write your own program Before use Firmware burning. Firmware refers to the device \"driver\" stored inside the device. Only through firmware can the operating system implement the operation of a specific machine according to the standard device driver. Different versions of the robot arm need to burn different firmware (refer to the MyStudio chapter). pymycobot installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), and enter the following command: pip install pymycobot --upgrade --user The following words appear, indicating that the pymycobot package has been successfully installed Source code installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), enter the following command to install: git clone -b develop https://github.com/elephantrobotics/pymycobot.git #Where fills in your installation address, if not filled in, the current path is used by default cd /pymycobot #Enter the pymycobot folder of the download package #Run one of the following commands according to your python version # Install python2 setup.py install # or python3 setup.py install Simple use of Python After the above preparations are completed, start to control the robot arm through Python code. Here, the MyCobot Pro 450 version is used as an example for demonstration. First, open the PyCharm you installed, create a new Python file, enter the following code, and import our library: from pymycobot import Pro450Client Note: If you enter from pymycobot import Pro450Client, there is no red wavy line under the font, which proves that it has been successfully installed and can be used. If a red wavy line appears, you can refer to How ​​to install the API library , How ​​to call the API library. If you do not want to install the API library through the above command, you can download the project to your local computer through the following github. First, go to the project address: https://github.com/elephantrobotics/pymycobot. Then click the Code button on the right side of the webpage, and then click Download ZIP to download it locally. Put the pymycobot folder in the compressed package pymycobot file project into your python dependency library directory, and you can directly import and use it. Simple Demonstration import time from pymycobot import Pro450Client pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication print(pro450.get_angles()) # Read all joint angles pro450.send_angle(1, 90, 50) # Control J1 joint movement to 90 degrees at a speed of 50 ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html","title":"6.1.2 API Description","keywords":"","body":"Pro 450 Python Socket API [toc] API usage instructions API (Application Programming Interface), also known as Application Programming Interface functions, are predefined functions. When using the following function interfaces, please import our API library at the beginning by entering the following code, otherwise it will not run successfully: Note: Before use, please make sure that the MyCobot Pro 450 server is turned on. # Example from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) print(mc.get_angles()) 1. System Status get_system_version() function： get system version Return value： system version get_modified_version() function： Read the revision number, for internal use only Return value： Correction version number get_robot_type() function： Detection robot model Return value： Definition Rule: Actual machine model. For example, the MyCobot Pro 450 model is 4503 get_atom_version() function： Get the end version number Return value： End parameters(float) get_tool_modify_version() function： Read end correction version number Return value： end correction version 2. Overall Status is_init_calibration() function: Check if the robot is initialized for calibration Return value: bool: True if the robot is initialized for calibration, False otherwise get_fresh_mode() function: Query sports mode Return value: 0: Interpolation mode 1: Refresh mode set_fresh_mode() function: Set command refresh mode Parameters: 1: Always execute the latest command first. 0: Execute instructions sequentially in the form of a queue. get_debug_state() Function: Get the current robot's debug logging mode. Return value: int: Current debug logging state. 0: No debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: All logs set_debug_state(log_state) Function: Set the debug logging mode for the current robot. Parameters: log_state: int, debug log state (0 to 7) 0: Do not log any debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: Log all logs Return value: int 1 - Success 0 - Failure 1 - Error 3.Robot abnormal control get_robot_status() function: Upper computer error security status Return value: 0 - Normal. other - Robot triggered collision detection servo_restore(joint_id) function：Clear joint abnormalities Parameters： joint_id: int. joint id 1 - 6, 254-All joints restored. get_comm_error_counts(joint_id) function：Read the number of communication exceptions Parameters： joint_id: int. joint id 1 - 6 4.MDI Mode and Operation get_angles() function: get the degree of all joints Return value: lista float list of all degree send_angle(id, degree, speed) function: send one degree of joint to robot arm Parameters: id: Joint id(genre.Angle), range int 1-6 degree: degree value(float) | Joint Id | range | | ---- | ---- | | 1 | -165 ~ 165 | | 2 | -120 ~ 120 | | 3 | -158 ~ 158 | | 4 | -165 ~ 165 | | 5 | -165 ~ 165 | | 6 | -175 ~ 175 | speed：the speed and range of the robotic arm's movement 1~100 send_angles(angles, speed) function： Send all angles to all joints of the robotic arm Parameters: angles: a list of degree value(List[float]), length 6 speed: (int) 1 ~ 100 get_coords() function: Obtain robot arm coordinates from a base based coordinate system Return value: a float list of coord:[x, y, z, rx, ry, rz] send_coord(id, coord, speed) function: send one coord to robot arm Parameters: id:send one coord to robot arm, 1-6 corresponds to [x, y, z, rx, ry, rz] coord: coord value(float) | Coord Id | range | | ---- | ---- | | x | -466 ~ 466 | | y | -466 ~ 466 | | z | -230 ~ 614 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | speed: (int) 1-100 send_coords(coords, speed, mode) function:: Send overall coordinates and posture to move the head of the robotic arm from its original point to your specified point Parameters: coords: ： a list of coords value [x,y,z,rx,ry,rz],length6 speed(int): 1 ~ 100 stop(deceleration=False) function: stop all movements of robot Parameters: deceleration: ： Whether to slow down and stop. Defaults to False. Return value: 1 - stopped 0 - not stop -1 - error is_moving() function: judge whether the robot is moving Return value: 1 moving 0 not moving -1 error 5. Joint software limit operation get_joint_min_angle(joint_id) function: Read the minimum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value：float Angle value get_joint_max_angle(joint_id) function: Read the maximum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value: float Angle value set_joint_min(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be less than the minimum value set_joint_max(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be greater than the maximum value 6. Joint motor auxiliary control get_servo_encoders() function：Read the full joint encoder value Return value： A list of length 6 set_servo_calibration(servo_id) function: The current position of the calibration joint actuator is the angle zero point Parameters: servo_id: 1 - 6 set_break（joint_id, value） function: Set break point Parameters： joint_id: int. joint id 1 - 6 value: int. 0 - disable, 1 - enable Return value: 0 : faile; 1 : success set_motor_enabled(joint_id, state function: Set the robot torque state.(Release joint interface) Parameters： joint_id: int. joint id 1 - 6, 254-all joints state: int. 0 - disable, 1 - enable 7. Run auxiliary information get_zero_pos() function: Read the zero encoder value Return value: listThe value of the zero encoder for seven joints get_servo_speeds() function：Get the movement speed of all joints Return value： unit step/s get_servo_currents() function：Get the movement current of all joints Return value： 0 ~ 5000 mA get_servo_status() function：Get the movement status of all joints Return value： a value of 0 means no error 8. Robotic arm end IO control set_digital_output(pin_no, pin_signal) Function: Set terminal IO status Parameters pin_no (int): Pin number, range 1 to 2 pin_signal (int): 0 / 1, 0 - low level, 1 - high level Return Value: 1: Completed get_digital_input(pin_no) Function: Get terminal IO status Parameters: pin_no (int), range 1 to 2 Return Value: int 0 / 1, 0 - low level, 1 - high level 9. Bottom IO control set_base_io_output(pin_no, pin_signal) function：Set Base IO Output Parameters： pin_no (int) Pin port number, range 1 ~ 12 pin_signal (int): 0 - low. 1 - high get_base_io_output(pin_no) function: Read base IO input Parameters: pin_no (int) pin number, range 1 ~ 12 Return value: 0 - low. 1 - high 10. Set up 485 communication at the end of the robotic arm tool_serial_read_data(data_len) function: Read fixed length data. Before reading, read the buffer length first. After reading, the data will be cleared Parameters： data_len (int): The number of bytes to be read, range 1 ~ 45 Return value: 0 : not set 1 : Setup completed tool_serial_write_data() function: End 485 sends data， Data length range is 1 ~ 45 bytes Return value: 0-Normal 1-Robot triggered collision detection set_over_time(timeout=1000) function: Set the timeout (unit: ms), default is 1000ms (1 second) Parameters： timeout (int): Timeout period, in ms, range 0~65535 flash_tool_firmware() function: Burn tool firmware 11. Pro force-controlled gripper get_pro_gripper_firmware_version( gripper_id=14) Function: Read the major and minor versions of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (float) Version number, x.x get_pro_gripper_firmware_modified_version(gripper_id=14) Function: Read the modified version of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (int) Correction version number set_pro_gripper_id(target_id, gripper_id=14) Function: Set the force-controlled gripper ID. Parameter: target_id (int): Range: 1 to 254. gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_id(gripper_id=14) Function: Read the force-controlled gripper ID. Parameter: gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: int Range: 1 to 254. set_pro_gripper_angle(gripper_angle，gripper_id=14) Function: Set the force-controlled gripper angle. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_angle(gripper_id=14) Function: Read the angle of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: int 0 ~ 100 set_pro_gripper_open(gripper_id=14) Function: Open the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_close(gripper_id=14) Function: Close the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_calibration(gripper_id=14) Function: Set the zero position of the force-controlled gripper. (The zero position needs to be set first when using it for the first time) Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_status(gripper_id=14) Function: Read the gripping status of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Moving. 1 - Stopped moving, no object was detected. 2 - Stopped moving, object was detected. 3 - After the object was detected, it fell. set_pro_gripper_enabled(state, gripper_id=14) Function: Sets the force-controlled gripper enable state. Parameter: state (bool): 0 or 1, 0 - disable, 1 - enable gripper_id (int): Gripper ID, default 14, range 1 to 254. Return Value: 0 - Failure 1 - Success set_pro_gripper_torque(torque_value，gripper_id=14) Function: Set the torque of the force-controlled gripper. Parameter: torque_value (int): Torque value, value range 0 ~ 100. gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_torque(gripper_id=14) Function: Read the torque of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: (int) 0 ~ 100 set_pro_gripper_speed(speed，gripper_id=14) Function: Set the force-controlled gripper speed. Parameter: speed (int): Gripper movement speed, value range 1 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_speed(speed，gripper_id=14) Function: Read the speed of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: Gripper default movement speed, range 1 ~ 100. set_pro_gripper_abs_angle(gripper_angle，gripper_id=14) Function: Set the absolute angle of the force-controlled gripper. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_io_open_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper I/O opening angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return Value: 0 - Failure 1 - Success get_pro_gripper_io_open_angle(gripper_id=14) Function: Reads the force-controlled gripper I/O opening angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_io_close_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper IO closing angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_io_close_angle(gripper_id=14) Function: Read the force-controlled gripper IO closing angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_mini_pressure(pressure_value, gripper_id=14) Function: Set the minimum actuation force of the force-controlled gripper Parameter: pressure_value (int): Actuation force value, range 0 to 254. gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_mini_pressure(gripper_id=14) Function: Read the minimum actuation force of the force-controlled gripper Parameter: gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: (int) Starting force value, range 0 to 254. set_pro_gripper_protection_current(current_value, gripper_id=14) Function: Set the gripping current of the force-controlled gripper Parameter: current_value (int): Gripping current value, range 100 to 300. gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_protection_current(gripper_id=14) Function: Read the gripping current of the force-controlled gripper Parameter: gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: (int) Clamping current value, range 100 ~ 300. ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html","title":"6.1.4 Coordinate Control","keywords":"","body":"Coordinate control It is mainly used to realize intelligent route planning to let the robot arm move from one position to another specified position. It is divided into [x, y, z, rx, ry, rz], where [x, y, z] represents the position of the robot head in space (the coordinate system is the rectangular coordinate system), and [rx, ry, rz] represents the posture of the robot head at this point (the coordinate system is the Euler coordinate system). The implementation of the algorithm and the representation of Euler coordinates require certain academic knowledge. We will not explain it too much here. As long as we understand the rectangular coordinate system, we can use this function well. Note: When setting coordinates, different series of robot arm joint structures are different. For the same set of coordinates, different series of robot arms will show different postures. Example Use import time from pymycobot import Pro450Client pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication print(pro450.get_coords()) # Read coordinate attitude information pro450.send_angles([0, -10, -123, 45, 0, 0], 50) # Send angular motion to a certain attitude for coordinate control, speed is 50 time.sleep(3) pro450.send_coord(1, 200, 50) # Send single coordinate control, speed is 50, so that the X axis moves to the position of 200mm time.sleep(2) pro450.send_coords([300, 86.8, 256.9, -178.0, 0.0, -90.0], 50) # Send multi-coordinate control, speed is 50 time.sleep(3) ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html","title":"6.1.5 IO Control","keywords":"","body":"IO control IO stands for data input and output. Our robot arm's Basic and Atom pins have multiple pins. This section mainly explains how to use the end-point IO to control the gripper. Example Use import time from pymycobot import Pro450Client pro450 = Pro450Client('192.168.0.232', 4500) # Client connection and communication # Open the gripper def open_gripper(): pro450.set_digital_output(1, 0) # Set pin 1 to a low level pro450.set_digital_output(2, 1) # Set pin 2 to a high level time.sleep(0.05) # Close the gripper def close_gripper(): pro450.set_digital_output(1, 1) # Set pin 1 to a high level pro450.set_digital_output(2, 0) # Set pin 2 to a low level time.sleep(0.05) # Repeat the gripper opening and closing twice for i in range(2): open_gripper() time.sleep(3) close_gripper() ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html","title":"6.1.6 Gripper Control","keywords":"","body":"Gripper control Before using Python to control the gripper, you must first install and connect the gripper to the robotic arm. Different grippers are compatible with different robotic arms. Here, we use the myGripper F100 Pro force-controlled gripper. Note: Before use, ensure that the communication mode on the gripper's small screen is set to Modbus mode; otherwise, the gripper will not function properly. Refer to Gripper Screen Control Example Use import time from pymycobot import Pro450Client pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication print(pro450.get_pro_gripper_firmware_version()) # Read the major and minor version numbers of the gripper time.sleep(1) print(pro450.get_pro_gripper_angle()) # Read the gripper angle information time.sleep(1) pro450.set_pro_gripper_angle(50) # Set the gripper angle to 50 time.sleep(2) pro450.set_pro_gripper_speed(70) # Set the gripper speed to 70 time.sleep(1) pro450.set_pro_gripper_open() # Set the gripper to fully open time.sleep(2) pro450.set_pro_gripper_close() # Set the gripper to fully close time.sleep(2) ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html","title":"6.1.7 Robot exception handling","keywords":"","body":"Checking and Handling Robot Arm Exceptions When the robot arm fails to execute a motion command, you can query the corresponding exception information in the Python terminal, for example. Reading Robot Status Status Feedback Analysis Under normal circumstances, this interface returns all 0s. Reading the robot status is as follows: from pymycobot import Pro450Client pro450 = Pro450Client('192.168.0.232', 4500) pro450.get_robot_status() # Reading Robot Status Return: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] Indicates the robot is not moving, no joints are exceeding limits, no joint hardware errors, and no joint software errors. A complete explanation of each value is as follows: [Reserved, Whether Moving, Whether J1 Exceeds Limits, Whether J2 Exceeds Limits, Whether J3 Exceeds Limits, Whether J4 Exceeds Limits, Whether J5 Exceeds Limits, Whether J6 Exceeds Limits, Whether J1 Motor Hardware Error, Whether J2 Motor Hardware Error, Whether J3 Motor Hardware Error, Whether J4 Motor Hardware Error, Whether J5 Motor Hardware Error, Whether J6 Motor Hardware Error, Whether J1 Software Communication Error, Whether J2 Software Communication Error, Whether J3 Software Communication Error, Whether J4 Software Communication Error, Whether J5 Software Communication Error, Whether J6 Software Communication Error] The following example is as follows: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that the robot reported an error during movement, with J4 reporting a control error. [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that robot J2 exceeded the limit. [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0] Indicates that the robot's J5 line is abnormal - receiving an error Exception resolution Joint out of limit When a joint exceeds the limit, use one of the following solutions: Execute the over-limit return to zero interface: pro450.over_limit_return_zero() #The robot will return to the origin at a slower speed Execute joint relaxation and manually move the joint to within the limit pro450.set_motor_enable(254, 0) Joint Hardware Error Most hardware errors can be recovered using exception recovery. pro450.servo_restore(joint_id) If this problem persists after using exception recovery or restarting the robot, please contact our engineers. Detailed information about the hardware errors for each joint is shown in Figure 1: Joint Software Errors Software error feedback mainly includes: circuit abnormalities, CAN module abnormalities, encoder abnormalities, and enable failure. If the enable failure occurs, use pro450.set_motor_enable(254, 1) to enable motion again. For other abnormalities, please contact our engineers. Detailed joint software error information is shown in Figures 2 and 3: The robot is in motion and cannot move. The robot is in motion and does not respond when you send a motion point. Please stop the robot by executing pro450.stop() and pro450.resume(). If the robot still cannot move, please contact our engineers. ← Previous Page | Next Section → "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/","title":"6.2 Development and Use Based on ROS1","keywords":"","body":"ROS ROS is an open-source, post-operating system (ROS), or secondary operating system, for robotic control. It provides operating system-like functionality, including hardware abstraction, low-level driver management, execution of shared functions, inter-program messaging, and package management. It also provides tools and libraries for acquiring, building, writing, and running multi-machine integrated programs. The ROS runtime \"graph\" is a network of loosely coupled peer-to-peer processes based on the ROS communication infrastructure. ROS implements several different communication methods, including a service mechanism for synchronous RPC-style communication, a topic mechanism for asynchronous streaming data, and a parameter server for data storage. ROS is not a real-time framework, but it can be embedded in real-time programs. Willow Garage's PR2 robot uses a system called pr2_etherCAT to send and receive ROS messages in real time. ROS also integrates seamlessly with the Orocos Real-Time Toolkit. ROS Logo: 1 Design Goals and Features of ROS Many people ask, \"What's the difference between ROS and other robotics software platforms?\" This question is difficult to answer. ROS isn't a framework that integrates most functions or features. In fact, its primary goal is to support code reuse in robotics development. ROS is a framework for distributed processes (i.e., nodes), which are encapsulated in programs and function packages and can be easily shared and distributed. ROS also supports a federated system similar to a code repository, which facilitates collaboration and distribution of projects. This design allows for complete independence in project development and implementation, from file systems to user interfaces (ROS has no limitations). Furthermore, all projects can be integrated with ROS's basic tools. To support its primary goals of sharing and collaboration, the ROS framework also has several other features: Streamlined: ROS is designed to be as streamlined as possible, which makes it easier for ROS to The code written can be used with other robotics software frameworks. Consequently, ROS can be easily integrated into other robotics software platforms: ROS has already been integrated with OpenRAVE, Orocos, and Player. ROS-independent libraries: The preferred development model for ROS is to write concise library functions that do not depend on ROS. Language independence: The ROS framework can be easily implemented in any modern programming language. ROS has been implemented in Python, C++, and Lisp. Experimental libraries are also available in Java and Lua. Loose coupling: Functional modules in ROS are encapsulated in independent packages or metapackages, making them easy to share. Modules in a package run on a per-node basis. Using ROS standard IO as an interface, developers do not need to worry about the internal implementation of modules. As long as they understand the interface rules, they can reuse modules and achieve point-to-point loose coupling. Convenient testing: ROS has a built-in unit/integration testing framework called rostest, which makes it easy to install and uninstall test modules. Extensible: ROS Suitable for large-scale operating systems and development processes. Free and open source: It has many developers and feature packages. 2 Why use ROS? ROS allows us to simulate and control a robotic arm in a virtual environment. We will use rviz to visualize the robotic arm, manipulate it in various ways, and MoveIt to plan and execute its motion paths, achieving free control of the robotic arm. In the following chapters, we will learn how to control our product using the ROS platform. MoveIt MoveIt is currently the most advanced robotic arm motion manipulation software, used in over 100 robots. It integrates the latest advances in motion planning, control, 3D perception, motion control, control, and navigation, providing an easy-to-use platform for developing advanced robotic applications and an integrated software platform for the design, integration, and evaluation of new robotics products in industry, commerce, R&D, and other fields. MoveIt Logo : 1 Description MoveIt is a ROS integrated development platform consisting of various functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, collision detection, and more. The following figure shows the high-level structure of the main node move_group provided by MoveIt. It acts as a combiner: it brings together all the individual components to provide users with a range of operations and services. 2 User Interface Users can access the operations and services provided by move_group in three ways: In C++, using the move_group_interface package makes it easy to use move_group. In Python, using the moveit_commander package. Through a graphical user interface: using Rviz (a ROS visualization tool) with Motion-commander. move_group can be configured through the ROS parameter server and can also retrieve the robot's URDF and SRDF from the server. 3 Configuration move_group is a ROS node. It uses the ROS parameter server to obtain three types of information: URDF - move_group looks for the robot_description parameter in the ROS parameter server to obtain the robot's URDF. SRDF - move_group looks for the robot_description_semantic parameter in the ROS parameter server to obtain the robot's SRDF. The SRDF is typically created by the user using the MoveIt Setup Assistant. MoveIt configuration - move_group will look for additional MoveIt-specific configuration in the ROS parameter server, including information about joint constraints, kinematics, motion planning, perception, and more. Configuration files for these components are automatically generated by the MoveIt Setup Assistant and stored in the configuration directory of the robot's corresponding MoveIt configuration package. For more information on using the setup assistant, see: MoveIt Setup Assistant ← Previous Section | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html","title":"6.2.1 Environment Setup","keywords":"","body":"ROS1 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest way to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing a Virtual Machine Image Recommended: This is the quickest method and suitable for beginners. Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 20.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default user is u202, and the default password is 123). Built-in Environment: ROS1 + Moveit + Git + pymycobot + mycobot_ros 1 Install virtual machine Go to official website to download virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux system image Click to download: Linux ubuntu20.04 3 Import Linux system image In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import it, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the user name is u202, the default password is 123 4 Update pymycobot To use the latest robotics driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update mycobot_ros To ensure users have the latest official packages, navigate to the /home/u202/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/catkin_ws/src # Delete the original mycobot_ros package sudo rm -rf mycobot_ros git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables Method 2: Customize the Installation Environment 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Create a virtual machine Select New in the control Enter the virtual machine name and the location where the virtual machine is stored, select the virtual machine type as Linux, select Ubuntu 64-bit version, and proceed to the next step. Configure the memory size according to your needs and proceed to the next step. Select Create a virtual hard disk now and create it. Select the VDI type for the virtual hard disk type and proceed to the next step. Allocate the size of the virtual hard disk. Since you need to install the Ubuntu system and will also operate in the system, it is recommended that the size should not be less than 20G. 3 Download Ubuntu system. Please choose the Ubuntu version to install according to your needs, the default version is Ubuntu 20.04. Note: ROS2 needs to download 20.04 version. 20.04 version The installation method and process of each version are the same. Here we use the 18.04 version as an example After downloading, there is a file as shown in the figure: 4 Import Ubuntu into the virtual machine Find the previously installed virtual machine in Virtual Box, enter Settings, and assign the CD to the controller in Storage: Then open the virtual machine to install Ubuntu and click Start. 5 Ubuntu installation Wait for the system to start, enter the Welcome interface, select \"English\", and click the \"Install Ubuntu\" button; Click the \"Continue\" button; Select the \"Erase the entire disk and install Ubuntu\" option, and click the \"Install Now\" button; Click the \"Continue\" button in the pop-up dialog box; Set the geographic location and click the \"Continue\" button; Set the user name and password and click the \"Continue\" button; Enter the system installation interface, please wait patiently; After the installation is complete, in the pop-up dialog box, click the \"Restart Now\" button to complete the installation. 6 ROS installation The basic development environment setup requires the installation of the robot operating system ROS, MoveIt, and git version manager. The following describes their installation methods and processes. For myCobot Pro 450 devices, please refer to the installation methods and processes described below. Here we choose Ubuntu 20.04, and the corresponding ROS version is ROS Melodic NOTE: We currently do not provide any reference for installing ROS on Windows. If necessary, please refer to https://www.ros.org/install/ 6.1 Start installation 1 Add source There is no ROS software source in the software source list of Ubuntu itself, so you need to configure the ROS software source to the software list warehouse before you can download ROS. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Tsinghua University is: sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list' You will be asked to enter the user password here. Just enter the user password you set when installing Ubuntu. 2 Set up the secret key Configure the public network secret key. This step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 The execution results are shown below:： 3 Installation After adding a new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute Install ROS, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command according to your Ubuntu version: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full It is recommended to install the complete ROS to prevent missing libraries and dependencies. The installation process takes a long time, please be patient If the following error message appears in the console terminal during the installation, you need to change the software source list in /etc/apt/sources.list. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo gedit /etc/apt/sources.list Replace all official software sources in sources.list with the following Alibaba Cloud software sources: Ubuntu 20.04： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse After the configuration is complete, the contents of the sources.list file are as follows. Click Save and Exit. Update the software source list and enter in the console terminal: sudo apt-get update Enter the command to install ROS in the console terminal: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full The installation process takes a long time, please wait patiently 4 Configure ROS environment to the system rosdep allows you to easily install the source code you want to compile or the system dependencies required by some ROS core components. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T). If rosdep is not installed on your system, please use the command sudo apt install python-rosdep to install it. If your installed Ubuntu system is version 20.04, please use the command sudo apt install python3-rosdep to install it, and execute the rosdep initialization command after completion. --> Initialize rosdep: sudo rosdep init If the error message shown below appears: Solution: Modify the hosts file and enter the following command in the console terminal: sudo gedit /etc/hosts At the end of the file content, add the IP addresses of the following two websites to access: 199.232.28.133 raw.githubusercontent.com 151.101.228.133 raw.github.com After the modification is completed, execute in the console terminal: sudo rosdep init rosdep update After initialization is completed, in order to avoid the need to re-validate the ROS function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T): 6.2 Set up the ros environment Execute the following command: # Ubuntu 20.04 echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc 6.3 Install ROS additional dependencies Enter the following command in the terminal to install ROS additional dependencies and open a console terminal (shortcut key Ctrl+Alt+T): sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential # Ubuntu 20.04 sudo apt install ros-noetic-joint-state-publisher-gui 6.4 Verify the installation The startup of the ROS system requires a ROS Master, i.e., a node manager. We can start the ROS Master by entering the roscore command in the terminal. To verify whether ROS is successfully installed, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: roscore When the following interface is displayed, it means that ROS is installed successfully The roscore command starts a node manager, which is used for node management. In a ros system, there is only one node manager, which is the prerequisite for the operation of the ros node. Therefore, before starting the ros node, the first step is to execute roscore. For more detailed installation instructions, please refer to the official installation guide at: http://wiki.ros.org/ROS/Installation 7 MoveIt Installation MoveIt is a functional package of a series of mobile operations in ROS, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 7.1 Update the software source list Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 7.2 Install MoveIt Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window to execute MoveIt installation: # Ubuntu20.04 sudo apt-get install ros-noetic-moveit 8 git installation 8.1 Add software source Add the software source installed by git to the software source list of Ubuntu, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: sudo add-apt-repository ppa:git-core/ppa 8.2 Update the software source list Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 8.3 Install git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 8.4 Verify installation Read the git version, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, indicating a successful installation 8.5 Usage You will need to use git to download the ros package later. For details on how to use git, please refer to the following link: https://git-scm.com/book/zh/v2 https://www.runoob.com/git/git-tutorial.html 9 mycobot_ros installation mycobot_ros is a ROS package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. 项目地址：http://github.com/elephantrobotics/mycobot_ros 9.1 Prerequisites Before installing the package, please ensure that you have a ros workspace. Here we give a sample command for creating a workspace, the default is catkin_ws, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory as a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace. Add workspace environment The official default ROS1 workspace is catkin_ws. # Ubuntu 20.04 echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc 9.2 Installation NOTE: This package depends on ROS and MoveIT. Please make sure that ROS and MoveIT are installed successfully before use. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip3 install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. The official default ROS1 workspace is catkin_ws. cd ~/catkin_ws/src # Enter the src folder of the workspace git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git # Clone the code on github cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables This completes the ROS1 environment setup. For more information on using ROS1, please refer to ROS Basics or ROS Basic Function Examples. ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html","title":"6.2.2 ROS Basics","keywords":"","body":"1 ROS project structure 1.1 catkin workspace Catkin workspace is the directory where catkin software packages are created, modified, and compiled. Catkin's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory into a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace The structure of catkin is very clear. It includes three paths: src, build, and devel. It may also include others under some compilation options. But these three folders are the default for the catkin compilation system. Their specific functions are as follows: src/: ROS catkin software package (source code package) build/: cache information and intermediate files of catkin (CMake) devel/: Generated target files (including header files, dynamic link libraries, static link libraries, executable files, etc.), environment variables A simple workspace looks like this: workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 1.2 ROS software package Package is not only a software package on Linux, but also the basic unit of catkin compilation. The object we use catkin_make to compile is each ROS package. +--PACKAGE +-- CMakeLists.txt +-- package.xml +-- src/ +-- include/ +-- scripts/ +-- msg/ +-- srv/ +-- urdf/ +-- launch/ CMakeLists.txt: Defines the package name, dependencies, source files, target files and other compilation rules of the package. It is an essential component of the package. package.xml: Describes the package name, version number, author, dependencies and other information of the package, which is an indispensable component of the package. src/: stores ROS source code, including C++ source code (.cpp) and Python module (.py) include/: stores the header files corresponding to the C++ source code scripts/: stores executable scripts, such as shell scripts (.sh), Python scripts (.py) msg/: stores messages in custom format (.msg) srv/: stores services in custom formats (.srv) urdf/: stores the robot’s model description (.urdf or .xacro) and 3D model files (.sda, .stl, .dae, etc.) launch/: stores launch files (.launch or .xml) Create your own package: Command format: The catkin_create_pkg command will ask you to enter package_name. If necessary, you can also add some other dependent software packages later: catkin_create_pkg [depend1] [depend2] [depend3] For example: catkin_create_pkg beginner_tutorials std_msgs rospy roscpp 2 ROS communication architecture 2.1 Master and node 1 Master Node manager. Each node must register with the master before starting and manage the communication between nodes. 2 roscore Starting the master will also start rosout (log management) and parameter server (parameter manager) 3 nodes ROS processes and instances of running executable files in pkg. $rosrun [pkg_name] [node_name] #Start $rosnode list #List currently running node information $rosnode info [node_name] #Display detailed information of a node $rosnode kill [node_name] #End a node 4 launch Start the master and multiple nodes. $roslaunch [pkg_name] [file_name.launch] 2.2 Service and Topic We provide some services and topics for interacting with mycobot. 1 Service Enter in the command line: source ~/catkin_ws/devel/setup.bash # Add environment variables roslaunch mycobot_pro450_communication communication_service.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rosservice list #/get_joint_angles #/get_joint_coords #/set_joint_angles #/set_joint_coords #/switch_gripper_status #/switch_pump_status Related commands and instructions: command Detailed description rosservice list Display active service information rosservice info [service name] Display information about the specified service rosservice type [service name] Show service type rosservice find [service name] Find a service for a specified service type rosservice uri [service name] show ROSRPC URI service rosservice args [service name] show service parameters rosservice call [service name] [parameters] Request service with input parameters 2 Topic Enter in the command line: source ~/catkin_ws/devel/setup.bash roslaunch mycobot_pro450_communication communication_topic.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rostopic list #/mycobot/angles_goal #/mycobot/coords_goal #/mycobot/angles_real #/mycobot/coords_real #/mycobot/pump_status #/mycobot/gripper_status Related commands and instructions: Command Detailed description rostopic list Display active topic list rostopic echo [topic name] Display the message content of the specified topic in real time rostopic find [type name] Display threads with messages of the specified type rostopic type [topic name] Displays the message type of the specified topic rostopic bw [topic name] Display the message bandwidth of the specified topic（bandwidth） rostopic hz [topic name] Display the message data publishing cycle of the specified topic rostopic info [topic name Display information about the specified topic rostopic pub [topic name] [message type] [parameters] Post a message with the specified topic name The difference between service and topic: service topic Synchronization Asynchronous Synchronous communication model pub/sub server/client underlying protocol ROSTCP/ROSUDP ROSTCP/ROSUDP Feedback Mechanism No Yes buffer Yes No Real-time Weak Strong Node Relationship Many-to-Many One-to-Many Applicable Scenarios Data Transmission Logical Processing you can go to service and topic learn more about the use of these two features 2.3 Introduction to msg and srv msg：The msg file is a simple text file describing the fields of a ROS message. They are used to generate source code for messages in different languages (c++ or python, etc.). srv：srv files are used to describe services. It consists of two parts: the request (request) and the response (response). msg files are stored in the msg directory of the package, and srv files are stored in the srv directory. 1 rosmsg rosmsg is a command line tool for displaying information about ROS message types. rosmsg demo: rosmsg show # Show message description rosmsg info # Display message information rosmsg list # list all messages rosmsg md5 # Display md5 encrypted message rosmsg package # Display all messages under a feature pack rosmsg packages # List feature packs that contain messages rosmsg list will list all msgs in the current ROS rosmsg packages List all packages containing messages rosmsg package List all msgs under a package //rosmsg package # Package names rosmsg package turtlesim rosmsg show Show message description //rosmsg show # message name rosmsg show turtlesim/Pose # result: float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity rosmsg info Works the same as rosmsg show rosmsg md5 A check algorithm to ensure the consistency of data transmission 2 rossrv rossrv is a command-line tool for displaying information about ROS service types, and uses a syntax that is highly similar to rosmsg. rossrv show # Display service message details rossrv info # Display information about service messages rossrv list # List all service information rossrv md5 # Display md5 encrypted service messages rossrv package # Display all service messages under a package rossrv packages # Show all packages that contain service messages rossrv list Will list all srv messages in the current ROS rossrv packages List all packages that contain service messages rossrv package List all msgs under a package //rossrv package # Package names rossrv package turtlesim rossrv show Show message description //rossrv show # message name rossrv show turtlesim/Spawn # result: float32 x float32 y float32 theta string name --- string name rossrv info The effect is the same as rossrv show rossrv md5 Use md5 checksum (encryption) for service data 3 Introduction to URDF Unified Robot Description Format，Unified Robot Description Format, abbreviated as URDF. The urdf package in ROS contains a C++ parser for URDF, and URDF files describe robot models in XML format. *URDF cannot be used alone, it needs to be combined with Rviz or Gazebo. URDF is just a file that needs to be rendered into a graphical robot model in Rviz or Gazebo. 3.1 urdf file description Code example: Only part of the code is intercepted here for display: It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. 3.2 link section The link element describes a rigid body with inertial, visual features, and collision properties 3.2.1 Attributes name： The name used to describe the link itself 3.2.2 element (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view 3.3 joint part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint. 3.3.1 properties of joint: name： Specifies a unique name for the joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. 3.3.2 elements of joint (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. 4 Commonly used command tools In ROS, there are many commonly used command line tools, which can help you develop, debug, manage ROS nodes, etc. The following are some commonly used ROS command line tools: 4.1 Compile workspace caktin_make 4.2 roscore Start the ROS master node. Before running a ROS node, you usually need to start roscore first roscore 4.3 rosrun Run the specified ROS node. rosrun package_name node_name 4.4 roslaunch Use the Launch file to start one or more ROS nodes. roslaunch package_name launch_file.launch 4.5 rosnode View running ROS node information. rosnode list rosnode info node_name 4.6 rostopic View information about running ROS topics. rostopic list rostopic echo topic_name 4.7 rosservice View and call ROS services. rosservice list rosservice call service_name 4.8 rosparam Get and set ROS parameters. rosparam get parameter_name rosparam set parameter_name value 4.9 rosmsg View ROS message types. rosmsg show message_type 4.10 rosdep Install dependencies of ROS packages. rosdep install package_name 4.11 Environment variables View the ROS_PACKAGE_PATH environment variable echo $ROS_PACKAGE_PATH ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html","title":"6.2.3 Rivz Use","keywords":"","body":"Brief introduction and use of rviz rviz is a 3D visualization platform in ROS. On one hand, it can realize the graphical display of external information, and on the other hand, it can also release control information to an object through rviz, realizing the monitoring and control of a robot. 1 Installation of rviz and the introduction to its interface When installing ros, if you perform a complete installation, rviz is already installed, and you may try to run it directly; if it is not fully installed, you may install rviz separately: # Ubuntu16.04 sudo apt-get install ros-kinetic-rviz # Ubuntu18.04 sudo apt-get install ros-melodic-rviz # Ubuntu20.04 sudo apt-get install ros-noetic-rviz After the installation is complete, open a new terminal (shortcut key: Ctrl+Alt+T) and enter the following command: roscore Then open a new terminal (shortcut key: Ctrl+Alt+T) and input the following command to open rviz. rosrun rviz rviz # or rviz Open rviz, and the following interface will be displayed: Introduction of all areas There is a list of monitors on the left. The monitor is a device that draws something in a 3D world and may have some options available in the display list. On the top is a toolbar, which allows the user to use various function buttons to select tools with multiple functions. The middle part is the 3D view: It is a main screen where various data can be viewed in three dimensions. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area where different observation angles can be set. We only give a rough introduction in this part. If you want to know more details, go to User Guide. 2 Simple use Start using launch file This example is built on what you have already done Environment building and you have successfully copied the company's code from GitHub to your virtual machine. Open a new terminal (shortcut key: Ctrl+Alt+T) Input the command to configure the ROS environment. cd ~/catkin_ws/ source devel/setup.bash Input again: roslaunch mycobot_pro_450 test.launch Open rviz, and then you will obtain the following result: If you want to know more information about rviz, go to Official documents. ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html","title":"6.2.4 Basic Function Cases","keywords":"","body":"Robot Arm Control Note: The pymycobot driver library version must be greater than 4.0.0 1 Slider Control --> Open a command line and run: roslaunch mycobot_pro_450 slider_control.launch # If the end effector is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 slider_control_force_gripper.launch Open rviz and a slider component, and you will see the following interface: If the myGripper F100 force-controlled gripper is attached to the end, you will see the following interface: You can then control the model in rviz and move it by dragging the slider. If you want the actual mold robot to move along with the model, open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro_450 slider_control.py # If the end effector is equipped with a myGripper F100 force-controlled gripper, run the following command: rosrun mycobot_pro_450 slider_control_force_gripper.py Note: Since the robot arm will move to the model's current position when you enter the command, please ensure that the model in rviz does not clip before using the command. Avoid dragging the slider quickly after connecting the robot arm to prevent damage. 2 Model Following In addition to the above controls, we can also make the model follow the movement of the actual robot arm. --> Open a command line and start the ROS node: roscore Then open a new command line and run: rosrun mycobot_pro_450 follow_display.py After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: Trying to connect to real MyCobot Pro450... IP: 192.168.0.232, port: 4500 Please press the button at the end of the machine to drag the joint. 请按下机器末端按钮进行关节拖拽运动 Publishing... Finally, open another command line and run: roslaunch mycobot_pro_450 follow_display.launch This will open rviz and display the model following effect. At this point, dragging the real robot arm joints will cause the simulation model to follow the real robot arm's movements. 3 GUI Control Building on the above, this package also provides a simple graphical user interface (GUI). Connect to mycobot. --> Open the command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 simple_gui.launch After successful execution, the terminal output is as follows: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, allowing real-time synchronization within rviz. This functionality relies on the Python API, so ensure that the robot arm is connected. --> Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 teleop_keyboard.launch The following is the output: The following information about mycobot will be output in the command line: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then open another command line and run: rosrun mycobot_pro_450 teleop_keyboard.py You will see the following command line output: Mycobot Pro450 Teleop Keyboard Controller (ROS1 - Topic Version) --------------------------------------------------------- Movement (Cartesian): w (x+) a (y+) s (x-) d (y-) z (z-) x (z+) Rotation (Euler angles): u (rx+) i (ry+) o (rz+) j (rx-) k (ry-) l (rz-) Movement Step: + : Increase movement step size - : Decrease movement step size Gripper: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Save current pose as home q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. This script supports the following parameters: _speed: Robot's movement speed _change_percent: Movement distance percentage 5 Moveit Usage mycobot_ros integrates the MoveIt component. Open a command line and run: roslaunch mycobot_pro450_moveit demo.launch The result is as follows: The terminal will output the following information, indicating that moveit has been successfully started: [ INFO] [1757321505.678763337]: Loading robot model 'firefighter'... [ INFO] [1757321505.782983258]: Set joints of group 'arm_group' to pose 'init_pose'. [ INFO] [1757321505.783324504]: Fake controller 'fake_arm_group_controller' with joints [ joint1 joint2 joint3 joint4 joint5 joint6 ] [ INFO] [1757321505.783798265]: Returned 1 controllers in list [ INFO] [1757321505.792047465]: Trajectory execution is managing controllers [ INFO] [1757321505.792117958]: MoveGroup debug mode is ON Loading 'move_group/ApplyPlanningSceneService'... Loading 'move_group/ClearOctomapService'... Loading 'move_group/MoveGroupCartesianPathService'... Loading 'move_group/MoveGroupExecuteTrajectoryAction'... Loading 'move_group/MoveGroupGetPlanningSceneService'... Loading 'move_group/MoveGroupKinematicsService'... Loading 'move_group/MoveGroupMoveAction'... Loading 'move_group/MoveGroupPickPlaceAction'... Loading 'move_group/MoveGroupPlanService'... Loading 'move_group/MoveGroupQueryPlannersService'... Loading 'move_group/MoveGroupStateValidationService'... Loading 'pilz_industrial_motion_planner/MoveGroupSequenceAction'... [ INFO] [1757321505.848190702]: initialize move group sequence action [ INFO] [1757321505.853932419]: Reading limits from namespace /robot_description_planning Loading 'pilz_industrial_motion_planner/MoveGroupSequenceService'... [ INFO] [1757321505.867558584]: Reading limits from namespace /robot_description_planning [ INFO] [1757321505.884930897]: ******************************************************** * MoveGroup using: * - ApplyPlanningSceneService * - ClearOctomapService * - CartesianPathService * - ExecuteTrajectoryAction * - GetPlanningSceneService * - KinematicsService * - MoveAction * - PickPlaceAction * - MotionPlanService * - QueryPlannersService * - StateValidationService * - SequenceAction * - SequenceService ******************************************************** [ INFO] [1757321505.885485766]: MoveGroup context using planning plugin ompl_interface/OMPLPlanner [ INFO] [1757321505.885536833]: MoveGroup context initialization complete You can start planning now! [ INFO] [1757321508.935642298]: Loading robot model 'firefighter'... [ INFO] [1757321509.253483659]: Starting planning scene monitor [ INFO] [1757321509.257223628]: Listening to '/move_group/monitored_planning_scene' [ INFO] [1757321509.375270577]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [ INFO] [1757321510.628737935]: Ready to take commands for planning group arm_group. The basic path planning operation is as follows: If you want the actual robot arm to execute the plan synchronously, you need to open another command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro450_moveit sync_plan.py Modifying Movement Speed To prevent joint shaking during actual robot arm movement, reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robot arm's Python API. Here, change it to 25。 ... def callback(data: JointState): \"\"\"Callback function for ROS JointState subscription. This function converts incoming joint positions (radians) to angles in degrees and sends them to the Pro450 robotic arm. Args: data (JointState): Joint state message containing joint positions. \"\"\" data_list = [] for index, value in enumerate(data.position): radians_to_angles = round(math.degrees(value), 2) data_list.append(radians_to_angles) rospy.loginfo(data_list) mc.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. In this case, change it to 0.1 and save the current configuration. ← Previous Page | Next section → "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/","title":"6.3 Development and use based on ROS2","keywords":"","body":"ROS2 introduction The predecessor of ROS2 is ROS, and ROS is the Robot Operating System (Robot Operating System). But ROS itself is not an operating system, but a software library and toolset. The emergence of Ros solved the communication problem of each component of the robot. Later, more and more robot algorithms were integrated into ROS. ROS2 inherited ROS, which is more powerful and better than ROS. 1 Design goals and features of ROS2 ROS2 has the historical mission of changing the era of intelligent robots. At the beginning of the design, it was considered to meet the needs of various robot applications. Multi-Robot Systems: In the future, robots will not be independent individuals, and communication and collaboration between robots are also required. ROS2 provides standard methods and communication mechanisms for the application of multi-robot systems. Cross-platform: Robot application scenarios are different, and the control platforms used will also be very different. In order to allow all robots to run ROS2, ROS2 can run on Linux, Windows, MacOS, and RTOS across platforms. Real time: Robot motion control and many behavior strategies require the robot to be real-time. For example, the robot must reliably detect pedestrians in front of it within 100ms, or complete kinematics and dynamics calculations within 1ms. ROS2 is a real-time like this Basic requirements are provided. Productization: A large number of robots have entered our lives, and there will be more and more in the future，ROS2 can not only be used in the robot research and development stage, but also can be directly installed in the product and go to the consumer market. This also poses a huge challenge to the stability and robustness of ROS2. Project management: Robot development is a complex system engineering. The project management tools and mechanisms for the whole process of design, development, debugging, testing, and deployment will also be reflected in ROS2, making it easier for us to develop a robot. 2 Release Version The release version and maintenance cycle corresponding to ROS2 and Ubuntu. ROS2 version release date Maintenance deadline Ubuntu version Dashing 2019.5 2021.5 Ubuntu 18.04 (Bionic Beaver) Eloquent 2019.11 2020.11 Ubuntu 18.04 (Bionic Beaver) Foxy 2020.6 2023.5 Ubuntu 20.04(Focal Fossa) Galactic 2021.5 2022.11 Ubuntu 20.04(Focal Fossa) Humble 2022.5 2027.5 Ubuntu 22.04(Jammy Jellyfish) 3 Comparison of ROS and ROS2 ROS2 redesigned the system architecture. The architecture changes between the two generations of ROS are as follows: OS Layer: In ROS2, it can be built on linux or other systems, even bare metal without an operating system. Middleware Layer: The communication system of ROS1 is based on TCPROS/UDPROS, while the communication system of ROS2 is based on DDS. DDS is a standard solution for data publishing/subscribing in distributed real-time systems. Application Layer: ROS1 relies on ROS Master, while in ROS2, a discovery mechanism called \"Discovery\" is used between nodes to help establish connections with each other. ROS has designed a complete set of communication mechanisms (topics, services, parameters, actions) to simplify robot development. Through this mechanism, the various components of the robot can be connected. This mechanism has designed a node called Ros Master, and the communication of all other components must go through the master node. Once the master node hangs up, it will cause the communication of the entire robot system to collapse! Therefore, the instability of Ros cannot be used to make some high-risk robots such as automatic driving. In addition, there are the following disadvantages: Communication based on TCP has poor real-time performance and high system overhead Unfriendly to python3 support Messaging mechanism is not compatible No encryption mechanism, low security ROS2 first removes the master node that exists in ROS. After removing the master node, each node can discover each other through the DDS node, each node is equal, and can realize one-to-one, one-to-many, and many-to-many communication. After using DDS for communication, reliability and stability have been enhanced. Compared with ROS that only supports Linux systems, ROS2 also supports windows, mac, and even RTOS platforms 4 Moveit2 MoveIt2 Introduction MoveIt2 is an integrated development platform within ROS2. It consists of multiple functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, and collision detection. Core Features Motion Planning MoveIt 2 provides motion planning capabilities based on the Open Motion Planning Library (OMPL) and other third-party libraries, supporting a variety of planning algorithms and constraints. Inverse Kinematics (IK) MoveIt 2 uses a plugin mechanism to support different IK solvers, enabling rapid calculation of the target pose of the robotic arm. Collision Detection & Avoidance MoveIt 2 includes powerful built-in collision detection capabilities to ensure that the robot avoids collisions with its surroundings when planning and executing motions. Dynamic Scene Awareness MoveIt 2 supports dynamic updates of its environment model, enabling real-time perception of obstacle changes. Control & Execution MoveIt 2 provides a motion control interface that tightly integrates with the robot hardware, ensuring accurate execution of planned paths. Visualization Tools Integrated with RViz 2, it supports intuitive interaction and debugging, displaying the motion planning and execution process in real time. Advantages of MoveIt 2 Real-time Support Based on ROS 2 ROS 2's DDS communication architecture empowers MoveIt 2, significantly improving real-time performance and reliability. Modular Design MoveIt 2 utilizes a modular architecture, allowing users to load or replace modules as needed, providing tremendous flexibility. Cross-Platform Support MoveIt 2 supports running on a variety of operating systems (such as Ubuntu and Windows) and hardware platforms. Active Community Support MoveIt 2 has a global developer community that continuously provides updates, feature extensions, and technical support. Configuration URDF - Universal Robot Description Format. SRDF - Contains the robot's joint groups, virtual and passive joints, robot pose, and self-collision, typically created by the user using the MoveIt2 Setup Assistant. MoveIt2 Configuration - Contains joint limits, kinematics, motion planning, perception, and other information. Configuration files for these components are automatically generated by the MoveIt2 Setup Assistant (MoveIt2 Configuration Assistant) and stored in the configuration directory of the robot's corresponding MoveIt2 configuration package. ← Previous Section | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html","title":"6.3.1 Environment Setup","keywords":"","body":"ROS2 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04/22.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing a Virtual Machine Image Applicable Use Case: Using ROS2 or MoveIt2 Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 22.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default password is 123). Built-in Environment: ROS2 humble + MoveIt2 + Git + pymycobot + mycobot_ros2 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox Extension Pack: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux system image Click to download:Linux ubuntu22.04 3 Import Linux system image Note: For the import method, please refer to the import method of Ubuntu 20.04 system In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the default password is 123 4 Update pymycobot To use the latest robotic arm driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update mycobot_ros2 To ensure users have the latest official packages, navigate to the /home/u22/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/colcon_ws/src # Delete the original mycobot_ros2 package sudo rm -rf mycobot_ros2 git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd # Return to the workspace colcon build # Build the code in the workspace source install/setup.bash # Add environment variables To reduce compilation time, you can compile individual packages. package_name is the specific package name; please modify it accordingly. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash Method 2: Customizing the Installation Environment 1 Virtual Machine Installation Note: When installing the virtual machine system, please install the Ubuntu 20.04 version of the system. The installation method is the same as Ubuntu 18.04. If you want to use the moveIt2 function, you need to install Ubuntu 22.04 version system. To install different versions of Ubuntu systems in Linux, please refer to 6.2 ROS1 Environment Setup section. 2 ROS2 Installation The basic development environment construction requires the installation of the robot operating system ROS2 and the git version manager. The following describes their installation methods and processes respectively. 2.1 Version selection ROS2 has a one-to-one correspondence with Ubuntu. Different versions of Ubuntu correspond to different versions of ROS2. For reference, see the following website: http://docs.ros.org/en/foxy/Releases.html Here are the ROS2 versions supported by Ubuntu: ROS2 version Release date Maintenance deadline Ubuntu version Foxy June 5, 2020 May 2023 Ubuntu 20.04(Focal Fossa) Galactic May 23, 2021 November 2022 Ubuntu 20.04(Focal Fossa) Humble May 23, 2022 May 2027 Ubuntu 22.04(Jammy Jellyfish) Please install the corresponding ROS2 version according to the Ubuntu version you installed, moveIt2 only supports the humble version If the versions are different, the download will fail. Here we choose Ubuntu 20.04 (recommended), and the corresponding ROS2 version is ROS2 Foxy NOTE: Currently we do not provide any reference for installing ROS2 on Windows. If necessary, please refer to http://docs.ros.org/en/foxy/Installation/Alternatives/Windows-Development-Setup.html 2.2 Start installation 1 Add source There is no ROS2 in the software source list of Ubuntu itself Software source, so you need to first configure the ROS2 software source to the software list warehouse before you can download ROS2. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Huawei Cloud is: echo \"deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 2 Set the key Configure the public network key, this step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt install curl gnupg2 -y curl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add - 3 Installation After adding the new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute install ROS2, open a console terminal (shortcut key Ctrl+Alt+T), please enter the following command according to your Ubuntu version: # Ubuntu 20.04 foxy version sudo apt install ros-foxy-desktop # Ubuntu 20.04 galactic version sudo apt install ros-galactic-desktop # Ubuntu 22.04 humble version sudo apt install ros-humble-desktop The installation process takes a long time, please wait patiently After the installation is complete, refresh the environment variables: source /opt/ros/foxy/setup.bash 2.3 Set up the ros2 environment In order to avoid the need to re-validate the ROS2 function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS2 function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence, open a console terminal (shortcut key Ctrl+Alt+T) and execute the following commands: # Ubuntu 20.04 foxy version # Add the ros environment to the environment variables of the current console echo \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc # Ubuntu 20.04 galactic version echo \"source /opt/ros/galactic/setup.bash\" >> ~/.bashrc # Ubuntu 22.04 humble version echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc source ~/.bashrc 2.4 Install ROS2 additional dependencies Enter the following command in the terminal Install ROS2 additional dependencies, open a console terminal (shortcut Ctrl+Alt+T): sudo apt install python3-argcomplete -y sudo apt install ros-foxy-xacro sudo apt-get install python3-colcon-common-extensions # Ubuntu 20.04 foxy version sudo apt install ros-foxy-joint-state-publisher-gui # Ubuntu 20.04 galactic version sudo apt install ros-galactic-joint-state-publisher-gui # Ubuntu 22.04 humble version sudo apt install ros-humble-joint-state-publisher-gui sudo apt install ros-humble-xacro 2.5 Verify installation To verify ROS2 To check whether the installation is successful, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: ros2 When the following interface is displayed, it means that ROS2 is installed successfully 3 MoveIt2 installation Note: Only the installation method for Ubuntu 22.04 is provided here MoveIt2 is a functional package of a series of mobile operations in ros2, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 3.1 Update the software source list Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt update 3.2 Install MoveIt2 sudo apt-get install ros-humble-moveit sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-joint-trajectory-controller ros-humble-joint-state-broadcaster 4 git installation 4.1 Update the software source list Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 4.2 Installation git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 4.3 Verify installation Read git version, open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, which means the installation is successful. 5 mycobot_ros2 installation mycobot_ros2 is a ROS2 package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. Project address: http://github.com/elephantrobotics/mycobot_ros2 5.1 Prerequisites Before installing the package, please ensure that you have a ros2 workspace. Here we give sample commands for creating a workspace. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/colcon_ws/src # Create a folder Add workspace environment The official default ROS2 workspace is colcon_ws. echo \"source ~/colcon_ws/install/setup.bash\" >> ~/.bashrc source ~/.bashrc 5.2 Installation NOTE: This package depends on ROS2 and MoveIT2. Make sure to install ROS2 and MoveIT2 successfully before using it. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. Please download the code from different branches depending on your ROS2 version: Ubuntu 20.04 / ROS2 Foxy - branch foxy Ubuntu 20.04 / ROS2 Galactic - branch galactic Ubuntu 22.04 / ROS2 Humble - branch humble The official default ROS2 workspace is colcon_ws. cd colcon_ws/src # Enter the src folder in the workspace # For the humble branch git clone -b humble --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the foxy branch git clone -b foxy --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the galactic branch git clone -b galactic --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd .. # Return to the workspace colcon build --symlink-install # Build the code in the workspace. --symlink-install: Avoids recompiling every time you modify the Python script. source install/setup.bash # Add environment variables To reduce compilation time, you can compile a certain package separately, where package_name is the name of the specific package. Please modify it according to your actual situation. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash This completes the ROS2 environment setup. For more information on using ROS2, please refer to ROS2 Basics or ROS2 Basic Functions. ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html","title":"6.3.2 ROS2 Basics","keywords":"","body":"1 ROS2 project structure 1.1 colcon workspace The colocn workspace is the directory where software packages are created, modified, and compiled. Colcon's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/colcon_ws/src # Create folder cd ~/colcon_ws/ # Enter the folder colcon build # Build the code in the workspace. Note: colcon supports option --symlink-install. This allows for faster iteration by changing installed files by changing files in the source space (such as Python files or other uncompiled resources). Avoid the need to recompile every time you modify your python script. colcon build --symlink-install A ROS workspace is a directory with a particular structure. Commonly there is a src subdirectory. Inside that subdirectory is where the source code of ROS packages will be located. Typically the directory starts otherwise empty. colcon does out of source builds. By default it will create the following directories as peers of the src directory: src/: colcon package for ROS2 (source code package) build/: The location where intermediate files are stored. For each package, a subfolder is created in which CMake is called, for example. install/: The installation location of each package. By default, each package will be installed into a separate subdirectory. log/: Contains various logging information about each colcon call. The directory structure of a ROS2 workspace is as follows: WorkSpace --- Customized workspace. |--- build: The directory where intermediate files are stored. A separate subdirectory will be created for each function package in this directory. |--- install: Installation directory, a separate subdirectory will be created for each function package in this directory. |--- log: Log directory, used to store log files. |--- src: Directory used to store function package source code. |-- C++ function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- CMakeLists.txt: Configure compilation rules, such as source files, dependencies, and target files. |-- src: C++ source file directory. |-- include: header file directory. |-- msg: message interface file directory. |-- srv: Service interface file directory. |-- action: action interface file directory. |-- Python function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- setup.py: similar to CMakeLists.txt of C++ function package. |-- setup.cfg: Function package basic configuration file. |-- resource: resource directory. |-- test: stores test-related files. |-- Directory with the same name of the function package: Python source file directory. 1.2 ROS2 package Package is not only a software package on Linux, but also the basic unit of colcon compilation. The object we use colcon build to compile is each ROS2 package. Create your own package: The command syntax for creating a software package using Python is: ros2 pkg create --build-type ament_python For example: ros2 pkg create --build-type ament_python --node-name my_node my_package 2 Basic tool commands In this chapter, you will learn about the common command tools of ROS2. 2.1 Topics ROS 2 breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system. Specific reference: Official Tutorials topics help ros2 topics -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Node Relationship Diagram rqt_graph Learn about topic-related commands ros2 topics -h topics list ros2 topic list ros2 topic list -t # Display the corresponding message type View topic content ros2 topic echo ros2 topic echo /turtle1/cmd_vel Display topic-related information, type ros2 topic info # Output /turtle1/cmd_vel topic related information ros2 topic info /turtle1/cmd_vel Display interface related information ros2 interface show # Output geometry_msgs/msg/Twist interface related information ros2 interface show geometry_msgs/msg/Twist Issue an order ros2 topic pub '' # Issue speed command ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" # Issue speed commands at a certain frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" See how often topics are posted ros2 topic hz # Output /turtle1/cmd_vel publish frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 2.2 Nodes Each node in ROS should be responsible for a single, module purpose (e.g. one node for controlling wheel motors, one node for controlling a laser range-finder, etc). Each node can send and receive data to other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes. Specific reference: Official Tutorials nodes help ros2 nodes -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the node list ros2 node list View Node Relationship Diagram rqt_graph Remapping ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle ros2 node list View node information ros2 node info ros2 node info /my_turtle 2.3 Services Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model, versus topics’ publisher-subscriber model. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Specific reference: Official Tutorials services help ros2 service -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the service list ros2 service list # Display service list and message type ros2 service list -t View the message types received by the service ros2 service type ros2 service type /clear Find services that use a certain message type ros2 service find ros2 service find std_srvs/srv/Empty View Service Message Type Definitions ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv Call the service command to clear the walking track ros2 service call ros2 service call /clear std_srvs/srv/Empty Spawn a new turtle ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: 'turtle2'}\" 2.4 Parameters A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS 2, each node maintains its own parameters. For more background on parameters, please see the concept document. Specific reference: Official Tutorials parameters help ros2 param -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View service list ros2 param list Get the parameter value ros2 param get ros2 param get /turtlesim background_g Set parameter values ros2 param set ros2 param set /turtlesim background_r 150 Export parameter values ros2 param dump ros2 param dump /turtlesim Import parameters independently ros2 param load ros2 param load /turtlesim ./turtlesim.yaml Start the node and import parameters at the same time ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 2.5 Actions Actions are one of the communication types in ROS 2 and are intended for long running tasks. They consist of three parts: a goal, feedback, and a result. Actions are built on topics and services. Their functionality is similar to services, except actions are preemptable (you can cancel them while executing). They also provide steady feedback, as opposed to services which return a single response. Actions use a client-server model, similar to the publisher-subscriber model (described in the topics tutorial). An “action client” node sends a goal to an “action server” node that acknowledges the goal and returns a stream of feedback and a result. Specific reference: Official Tutorials action help ros2 action -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Press G|B|V|C|D|E|R|T to achieve rotation, press F to cancel View the server and client of the node action ros2 node info /turtlesim View action list ros2 action list ros2 action list -t # show action type view action info ros2 action info ros2 action info /turtle1/rotate_absolute View action message content ros2 interface show turtlesim/action/RotateAbsolute Send action target information ros2 action send_goal ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" # With feedback information ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" --feedback 2.6 RQt RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout. Specific reference: Official Tutorials You can run any RQt tools/plugins easily by: rqt rqt help rqt -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Action Type Browser: / Plugins -> Actions ->Action Type Browser parameter reconfiguration: / Plugins -> configuration ->Parameter Reconfigure Node grap: /Node Graph control steering: /Plugins -> Robot Tools -> Robot Steering service invocation: /Plugins -> Services -> Service Caller Service Type Browser: Plugins -> Services -> Service Type Browser message release: Plugins -> Topics -> Message Publisher Message Type Browser: Plugins -> Topics -> Message Type Browser topic list: Plugins -> Topics -> Topic Monitor draw a graph: Plugins -> Visualization -> Plot View logs: rqt_console ros2 run rqt_console rqt_console ros2 run turtlesim turtlesim_node ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}\" 2.7 TF2 tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time. Specific reference: Official Tutorials Let’s start by installing the demo package and its dependencies. sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations follow launch starts 2 little turtles, the first little turtle automatically follows the second one ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py Control the movement of the first little turtle through the keyboard ros2 run turtlesim turtle_teleop_key View TF tree ros2 run tf2_tools view_frames.py evince frames.pdf View the relationship between two coordinate systems ros2 run tf2_ros tf2_echo [reference_frame] [target_frame] ros2 run tf2_ros tf2_echo turtle2 turtle1 View TF relationships on rviz ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz 2.8 URDF URDF is the Unified Robot Description Format for specifying robot geometry and organization in ROS. Specific reference: Official Tutorials 部分代码示例 It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. link section The link element describes a rigid body with inertial, visual features, and collision properties, the name is used to describe the name of the link itself, as follows: (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view joint part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint.Name is a unique name for the specified joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. elements of joint: (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. Install dependent libraries sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher sudo apt install ros-foxy-xacro Download the source code cd ~/dev_ws git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial Compiling the source code colcon build --packages-select urdf_tutorial Running the example ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf 2.9 Launch The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described. The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration. It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes. Launch files written in Python, XML, or YAML can start and stop different nodes as well as trigger and act on various events. Specific reference: Official Tutorials Setup Create a new directory to store your launch files: mkdir launch Writer the launch file Let’s put together a ROS 2 launch file using the turtlesim package and its executables. As mentioned above. Copy and paste the complete code into the launch/turtlesim_mimic_launch.py file: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package='turtlesim', namespace='turtlesim1', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', namespace='turtlesim2', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', executable='mimic', name='mimic', remappings=[ ('/input/pose', '/turtlesim1/turtle1/pose'), ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) Run the ros2 launch file To run the launch file created above, enter into the directory you created earlier and run the following command: The syntax format is: ros2 launch cd launch ros2 launch turtlesim_mimic_launch.py launch help ros2 launch -h running node ros2 launch turtlesim multisim.launch.py Check the parameters of the launc file ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments ros2 launch turtlebot3_bringup robot.launch.launch.py -s Run the launch file with parameters ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr Run the node and debug ros2 launch turtlesim turtlesim_node.launch.py -d Only output node description ros2 launch turtlesim turtlesim_node.launch.py -p running components ros2 launch composition composition_demo.launch.py 2.10 Run run is used to run a single node, component program run help ros2 run -h running node ros2 run turtlesim turtlesim_node Run node with parameters ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2 Run component container ros2 run rclcpp_components component_container running components ros2 run composition manual_composition 2.11 Package A package can be considered a container for your ROS 2 code. If you want to be able to install your code or share it with others, then you’ll need it organized in a package. With packages, you can release your ROS 2 work and allow others to build and use it easily. Package creation in ROS 2 uses ament as its build system and colcon as its build tool. You can create a package using either CMake or Python, which are officially supported, though other build types do exist. Specific reference: Official Tutorials Creating a workspace Create a new directory for every new workspace. The name doesn’t matter, but it is helpful to have it indicate the purpose of the workspace. Let’s choose the directory name ros2_ws, for “development workspace”: mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src pkg help ros2 pkg -h List Feature Packs ros2 pkg executable turtlesim Output a function package executable program ros2 pkg executable turtlesim Create a Python package Make sure you are in the src folder before running the package creation command. cd ~/ros2_ws/src The command syntax for creating a new package in ROS 2 is: ros2 pkg create --build-type ament_python # you will use the optional argument --node-name which creates a simple Hello World type executable in the package. ros2 pkg create --build-type ament_python --node-name my_node my_package Build a package Putting packages in a workspace is especially valuable because you can build many packages at once by running colcon build in the workspace root. Otherwise, you would have to build each package individually. # Return to the root of your workspace: cd ~/ros2_ws # Now you can build your packages: colcon build Source the setup file To use your new package and executable, first open a new terminal and source your main ROS 2 installation. Then, from inside the ros2_ws directory, run the following command to source your workspace: source install/setup.bash Now that your workspace has been added to your path, you will be able to use your new package’s executables. Use the package To run the executable you created using the --node-name argument during package creation, enter the command: ros2 run my_package my_node ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html","title":"6.3.3 Rivz2 Use","keywords":"","body":"Brief introduction and use of rviz2 Rviz2 is a visualization tool for displaying messages in the robot environment, providing a 3D perspective to view the robot's status and activities. It can help developers better understand the current status and activities of the robot, as well as other visual messages. Rviz2 provides a series of visualization tools that can help developers better understand the status and activities of robots, such as visual coordinate systems, laser scanning messages, point cloud messages, robot models, etc. Using Rviz2, robotic systems can be easily viewed and debugged to better achieve robotic goals. 1 Introduction to rviz2 The successful installation of ros2 indicates that rviz2 is also successfully installed together, because the installation of ros2 includes rviz2. Open a new terminal (shortcutCtrl+Alt+T)enter the command to open rviz2 ros2 run rviz2 rviz2 # 或 rviz2 Open rviz2 and display the following interface: Introduction of each area On the left is the list of monitors, a monitor is something that draws something in the 3D world and may have some options available in the display list. Including functions such as adding, deleting, copying, renaming plug-ins, displaying plug-ins, and setting plug-in properties. Above is the toolbar, which allows users to use various function buttons to select tools with multiple functions The middle part is the 3D view: it is the main screen where various data can be viewed in 3D. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area, and different observation angles can be set. We only give a rough introduction in this part. If you want to know more detailed content, you can go to the user guide to view it. 2 Simple use Launch through launch file This example is based on the fact that you have completed Environment Setup and successfully copied the company's code from GitHub. Open a console terminal (shortcut key Ctrl+Alt+T) Enter the following command to configure ROS2 environment. cd ~/colcon_ws/ colcon build --symlink-install source install/setup.bash Enter again: ros2 launch mycobot_pro_450 test.launch.py Open rviz2 and get the following result: If you want to know more information about rviz, you can go to the official documentation to view it. ← Previous Page | Next Page → "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html","title":"6.3.4 Basic Function Cases","keywords":"","body":"Controlling the Robotic Arm Note: The pymycobot driver library version must be greater than 4.0.0. Moveit2 only supports the ROS2 Humble version. Please use the code from the corresponding branch. 1 Slider Control --> Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 slider_control.launch.py # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 slider_control_force_gripper.launch.py This will open rviz2 and a slider component, and you will see something like the following: If the end-user is equipped with a myGripper F100 force-controlled gripper, you will see the following interface: You can then control the model's movement in rviz2 by dragging the slider. The real mycobot will also move accordingly. Note: Since the robot arm will move to the model's current position as you enter commands, please ensure that the model in rviz does not clip before using these commands. Avoid dragging the slider quickly after connecting the robot arm to prevent damage to the arm. 2 Model Following In addition to the above controls, we can also make the model follow the movements of the real robot arm. --> Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 mycobot_follow.launch.py After running successfully, all joints of the robot arm are released. It will also open rviz to display the model following effect. Now, drag the real robot arm joints, and the simulation model will follow the real robot arm's movements. After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [12048] [INFO] [follow_display-2]: process started with pid [12050] [INFO] [rviz2-3]: process started with pid [12052] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757408024.256520696] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757408024.256679159] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757408024.256692374] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757408024.256697373] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757408024.256701681] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757408024.256705999] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757408024.256710327] [robot_state_publisher]: got segment link6 [rviz2-3] [INFO] [1757408024.565241287] [rviz2]: Stereo is NOT SUPPORTED [rviz2-3] [INFO] [1757408024.565493504] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-3] [INFO] [1757408024.647227371] [rviz2]: Stereo is NOT SUPPORTED [follow_display-2] [INFO] [1757408024.783281010] [follow_display]: ip:192.168.0.232, port:4500 [rviz2-3] Parsing robot urdf xml string. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]: Please press the button at the end of the machine to drag the joint. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]:请按下机器末端按钮进行关节拖拽运动 [follow_display-2] [INFO] [1757408024.937815658] [follow_display]: Publishing ... 3 GUI Control Building on the previous functionality, this package also provides a simple graphical user interface. This approach requires that the actual robotic arm be connected to each other; please connect to mycobot. --> Open a command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 simple_gui.launch.py After successful execution, the terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [17196] [INFO] [rviz2-2]: process started with pid [17198] [INFO] [listen_real_service-3]: process started with pid [17200] [INFO] [simple_gui-4]: process started with pid [17202] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757414162.529535554] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757414162.530006477] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757414162.530445098] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757414162.530788098] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757414162.531159021] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757414162.531476222] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757414162.531788353] [robot_state_publisher]: got segment link6 [listen_real_service-3] [INFO] [1757414163.139592125] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] [INFO] [1757414163.306409248] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757414163.306709577] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757414163.372621603] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] Parsing robot urdf xml string. Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, and is synchronized in real time within rviz2. This functionality relies on the Python API, so ensure that it is connected to the real robot arm. --> Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 teleop_keyboard.launch.py The following is the output: The command line will output the following information about mycobot: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [13684] [INFO] [rviz2-2]: process started with pid [13686] [INFO] [listen_real_service-3]: process started with pid [13688] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757409378.488848950] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757409378.489029099] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757409378.489038676] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757409378.489043355] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757409378.489047552] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757409378.489051760] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757409378.489055988] [robot_state_publisher]: got segment link6 [rviz2-2] [INFO] [1757409378.801155196] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757409378.801390966] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757409378.860460962] [rviz2]: Stereo is NOT SUPPORTED [listen_real_service-3] [INFO] [1757409379.155013599] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] Parsing robot urdf xml string. Next, open another command line: ros2 run mycobot_pro_450 teleop_keyboard You will see the following output in the terminal: Mycobot Teleop Keyboard Controller --------------------------- Movimg options(control coordinations [x,y,z,rx,ry,rz]): w(x+) a(y-) s(x-) d(y+) z(z-) x(z+) u(rx+) i(ry+) o(rz+) j(rx-) k(ry-) l(rz-) +/- : Increase/decrease movement step size Force Gripper control: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Resave home pose q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot arm's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. 5 Moveit2 Use Note: Moveit2 only supports the ROS2 Humble version. Please use the corresponding branch to run the code. mycobot_ros2 integrates the MoveIt component. Open a command line and run: ros2 launch pro450_moveit2 demol.launch.py The result is as follows: The terminal will output the following message, indicating that Moveit has been successfully launched: [move_group-3] You can start planning now! [move_group-3] [ros2_control_node-5] [INFO] [1757486383.454753341] [controller_manager]: Loading controller 'joint_state_broadcaster' [rviz2-4] [INFO] [1757486383.456108372] [rviz2]: Stereo is NOT SUPPORTED [spawner-7] [INFO] [1757486383.502228729] [spawner_joint_state_broadcaster]: Loaded joint_state_broadcaster [spawner-6] [INFO] [1757486383.564310311] [spawner_arm_group_controller]: Configured and activated arm_group_controller [rviz2-4] Warning: class_loader.impl: SEVERE WARNING!!! A namespace collision has occurred with plugin factory for class rviz_default_plugins::displays::InteractiveMarkerDisplay. New factory will OVERWRITE existing one. This situation occurs when libraries containing plugins are directly linked against an executable (the one running right now generating this message). Please separate plugins out into their own library or just don't link against the library and use either class_loader::ClassLoader/MultiLibraryClassLoader to open. [rviz2-4] at line 253 in /opt/ros/humble/include/class_loader/class_loader/class_loader_core.hpp [ros2_control_node-5] [INFO] [1757486383.610227041] [controller_manager]: Configuring controller 'joint_state_broadcaster' [ros2_control_node-5] [INFO] [1757486383.610628892] [joint_state_broadcaster]: 'joints' or 'interfaces' parameter is empty. All available state interfaces will be published [spawner-7] [INFO] [1757486383.736878229] [spawner_joint_state_broadcaster]: Configured and activated joint_state_broadcaster [INFO] [spawner-6]: process has finished cleanly [pid 100700] [INFO] [spawner-7]: process has finished cleanly [pid 100703] [rviz2-4] [ERROR] [1757486386.668318057] [moveit_ros_visualization.motion_planning_frame]: Action server: /recognize_objects not available [rviz2-4] [INFO] [1757486386.684028956] [moveit_ros_visualization.motion_planning_frame]: MoveGroup namespace changed: / -> . Reloading params. [rviz2-4] [INFO] [1757486386.975209646] [moveit_rdf_loader.rdf_loader]: Loaded robot model in 0.105952 seconds [rviz2-4] [INFO] [1757486386.975348906] [moveit_robot_model.robot_model]: Loading robot model 'firefighter'... [rviz2-4] [INFO] [1757486387.253639370] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Starting planning scene monitor [rviz2-4] [INFO] [1757486387.255326862] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Listening to '/monitored_planning_scene' [rviz2-4] [INFO] [1757486387.353487213] [interactive_marker_display_104041531794736]: Connected on namespace: /rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic [rviz2-4] [INFO] [1757486387.358813947] [moveit_ros_visualization.motion_planning_frame]: group arm_group [rviz2-4] [INFO] [1757486387.358844123] [moveit_ros_visualization.motion_planning_frame]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [rviz2-4] [INFO] [1757486387.372219842] [move_group_interface]: Ready to take commands for planning group arm_group. [rviz2-4] [INFO] [1757486387.404744042] [interactive_marker_display_104041531794736]: Sending request for interactive markers [rviz2-4] [INFO] [1757486387.463143847] [interactive_marker_display_104041531794736]: Service response received for initialization Basic path planning operations are as follows: If you want to synchronize the plan with the actual robot arm, you need to open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 run pro450_moveit2_control sync_plan Modifying the Movement Speed To prevent joints from shaking during actual robot arm movement, you need to reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robotic arm Python API to 25. Note: After changing the speed, you need to recompile for it to take effect: cd ~/colcon_ws source install/setup.bash ... def listener_callback(self, msg): \"\"\"Callback to process received joint states. Converts joint positions from radians to degrees, rearranges them according to the RViz order, and sends them to the robot. Args: msg (JointState): The message containing joint names and positions. \"\"\" # Create a mapping of joint names to their position values joint_state_dict = {name: msg.position[i] for i, name in enumerate(msg.name)} # Rearrange joint angles according to RViz order data_list = [] for joint in self.rviz_order: if joint in joint_state_dict: radians_to_angles = round( math.degrees(joint_state_dict[joint]), 2) data_list.append(radians_to_angles) self.get_logger().info(f'joint_angles: {data_list}') self.mycobot_450.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. Here, change it to 0.1 and save the current configuration. ← Previous Page | Next section → "},"3-FunctionsAndApplications/7.SuccessfulCase/7-SuccessfulCases.html":{"url":"3-FunctionsAndApplications/7.SuccessfulCase/7-SuccessfulCases.html","title":"7. Successful Cases","keywords":"","body":"Chapter 7 Successful Cases myCobot 280 series robot arms support more than ten kinds of accessories, including bases, end extensions, peripheral products, etc. Multiple accessories can be stacked to complete complex project applications and meet the needs of commercial exhibitions, such as robot application model display, educational teaching package display, and industrial 4.0 application scenario display. Supports multiple mainstream programming languages ​​such as python and C++ to meet the diverse needs of developers. User case display video 【Application Case】Elephant Robot myCobot Elephant Robot Arm Creative Video Collection 280 PLC IO Interactive Control Case 1. Functional Effect Description After receiving the IO signal from the PLC, the robot arm will perform an action to return each joint to zero position 2. Principle Description Since the input and output of the robot arm is 3.3V and the input and output of the PLC is 24V, a 5V relay and a 24V relay are required. The output end of the robot arm will first output a signal to energize the 5V relay coil, connect the normally open contacts, and pass the 24V signal to the input end of the PLC. After the PLC collects the input signal, the PLC output end will output a signal to energize the 24V relay coil, connect the normally open contacts, and pass the 3.3V signal to the input end of the robot arm. After the robot arm collects the input signal, it will perform an action of returning each joint to zero position 3. Hardware Link Overall connection diagram Wiring of the input of the robot arm and the output of the PLC First connect the PLC to a 24V power supply Then connect the PLC output to the 24V relay coil Connect the robot's GPIO2 and 3.3V to the normally open contact of the 24V relay Connect the robot's output to the PLC's input Connect the 5v, GND and GPIO5 of the robot to the coil of the 5V relay Then connect the positive pole of 24V to the COM terminal of the 5V relay, the negative pole of 24V to the 1M terminal of the PLC, and NO to the input of the PLC 4 Software Programming Robot Program import time mc=MyCobot(\"COM6\") mc.set_basic_output(5,1) while 1: if mc.get_basic_input(2)==1: mc.sync_send_angles([0,0,0,0,0,0],50) break else: pass mc.set_basic_output(5,0) PLC program 5. Effect display ← Previous chapter | Next chapter → "},"demo-en/280m5_gripper.html":{"url":"demo-en/280m5_gripper.html","title":"Robot gripper carrying wooden block example","keywords":"","body":"Robot gripper carrying wooden block example 1 Functional description The robot will use the gripper to carry the wooden block from point A to point B 2 Hardware installation Insert the Lego connector into the reserved socket of the gripper Align the gripper with the connector inserted into the socket at the end of the robot arm and insert it Connect the extension cable to the gripper Insert the robot arm control interface 3 Gripper test Run the following program, the gripper will repeat the closing and opening action twice from pymycobot import MyCobot280,utils import time arm=MyCobot280(utils.get_port_list()[0]) for i in range(2): arm.set_gripper_state(1,100) time.sleep(1) arm.set_gripper_state(1,100) time.sleep(1) 4 Software Usage Use the fast movement function of myblockly to teach the grabbing point and placement point of the wooden block, and record the position information. After teaching, you need to disconnect the serial port connection, otherwise the serial port will be reported when running the python script. The error is that the serial port is occupied. 5 Composite application from pymycobot import MyCobot280,utils import time init_angles=[-3.25, -2.46, -95.09, 9.22, 86.39, 93.33]#6 joint angles at the initial position grab_point=[214.5, -189.9, 185.5, -177.5, 1.91, 173.49]#Coordinates of the gripping point place_point=[214.5, -50.9, 185.5, -177.5, 1.91, 173.49]#Coordinates of the placement point arm=MyCobot280(utils.get_port_list()[0]) if __name__==\"__main__\": arm.set_gripper_state(0,100)#Open the gripper first time.sleep(1) arm.send_angles(init_angles,100)#Initial position of movement time.sleep(2) arm.send_coords([grab_point[0],grab_point[1],grab_point[2]+70,grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to 70mm above the grab point time.sleep(2) arm.send_coords([grab_point[0],grab_point[1],grab_point[2],grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to the grab point time.sleep(2) arm.set_gripper_state(1,100)#Clamp the gripper time.sleep(1) arm.send_coords([grab_point[0],grab_point[1],grab_point[2]+70,grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to 70mm above the grab point time.sleep(2) arm.send_coords([place_point[0],place_point[1],place_point[2]+70,place_point[3],place_point[4],place_point[5]],100,1)#Move to 70mm above the placement point time.sleep(2) arm.send_coords([place_point[0],place_point[1],place_point[2],place_point[3],place_point[4],place_point[5]],100,1)#Move to the placement point time.sleep(2) arm.set_gripper_state(0,100)#Open the gripper time.sleep(1) arm.send_coords([place_point[0],place_point[1],place_point[2]+70,place_point[3],place_point[4],place_point[5]],100,1)#Move to 70mm above the placement point time.sleep(2) 6 Effect display "},"demo-en/280m5_pump.html":{"url":"demo-en/280m5_pump.html","title":"Robot suction pump to carry wooden blocks","keywords":"","body":"Robot suction pump to carry wooden blocks 1 Functional description The robot will use the suction pump to carry wooden blocks from point A to point B 2 Hardware installation Insert the Lego connector into the reserved socket on the suction pump Align the suction pump with the connector inserted into the socket at the end of the robot arm Select the male-female DuPont wire, and insert the female end into the socket marked with pins on the suction pump box Then connect the wire to the base IO of the robot arm The left side is the suction pump pin, and the right side is the robot arm pin GND -> GND 5V -> 5V G2 -> 2 G5 -> 5 3 Pump test Run the following program, the pump will repeat the opening and closing action twice from pymycobot import MyCobot280,utils import time arm = MyCobot280(utils.get_port_list()[0]) # Turn on the pump def pump_on(): arm.set_basic_output(5, 0) time.sleep(0.05) # Stop the pump def pump_off(): arm.set_basic_output(5, 1) time.sleep(0.05) arm.set_basic_output(2, 0) time.sleep(1) arm.set_basic_output(2, 1) time.sleep(0.05) for i in range(2): pump_on() time.sleep(2) pump_off() time.sleep(2) 4 Software Usage Use the fast movement function of myblockly to teach the grab and place points of the wooden block, and record the position information. After teaching, you need to disconnect the serial port, otherwise the serial port will be reported when running the python script. 5 Composite Application from pymycobot import MyCobot280,utils import time init_angles=[-3.25, -2.46, -95.09, 9.22, 86.39, 93.33]#6 joint angles at the initial position grab_point=[196.9, -197.1, 124.5, -178.8, 1.25, 173.32]#Coordinates of the grab point place_point=[196.9, -97.1, 124.5, -178.8, 1.25, 173.32]# Coordinates of the placement point arm = MyCobot280(utils.get_port_list()[0]) # Turn on the suction pump def pump_on(): arm.set_basic_output(5, 0) time.sleep(0.05) def pump_off(): arm.set_basic_output(5, 1) time.sleep(0.05) arm.set_basic_output(2, 0) time.sleep(1) arm.set_basic_output(2, 1) time.sleep(0.05) if __name__==\"__main__\": pump_off()#Turn off the suction pump first time.sleep(1) arm.send_angles(init_angles,100)#Move to the initial position time.sleep(2) arm.send_coords([grab_point[0],grab_point[1],grab_point[2]+70,grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to 70mm above the grab point time.sleep(2) arm.send_coords([grab_point[0],grab_point[1],grab_point[2],grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to the grab point time.sleep(2) pump_on() #Turn on the suction pump time.sleep(1) arm.send_coords([grab_point[0],grab_point[1],grab_point[2]+70,grab_point[3],grab_point[4],grab_point[5]],100,1)#Move to 70mm above the grab point time.sleep(2) arm.send_coords([place_point[0],place_point[1],place_point[2]+70,place_point[3],place_point[4],place_point[5]],100,1)#Move to 70mm above the placement point time.sleep(2) arm.send_coords([place_point[0],place_point[1],place_point[2],place_point[3],place_point[4],place_point[5]],100,1)#Move to the placement point time.sleep(2) pump_off() #Turn off the pump time.sleep(1) arm.send_coords([place_point[0],place_point[1],place_point[2]+70,place_point[3],place_point[4],place_point[5]],100,1)#Move to 70mm above the placement point time.sleep(2) 6 Effect display "},"3-FunctionsAndApplications/8.SupportingResources/":{"url":"3-FunctionsAndApplications/8.SupportingResources/","title":" 8. Supporting Resources","keywords":"","body":"Chapter 8 Supporting Resources This chapter will introduce various supporting resources of the product in detail, aiming to help users fully understand and use our products efficiently. Whether it is product information, drawings, software information and source code, or system information and promotional materials, we provide detailed information and download links to ensure that users can make full use of these resources for product development, operation and promotion Download Product Information The product information includes detailed specifications, technical parameters and instructions for use of the 280 M5 robot arm. This section aims to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Product Drawings The product drawings section provides detailed 3D and 2D drawings of the 280 M5 robot arm. These drawings are particularly important for engineers who need to perform customized designs or maintenance, and can help them better understand the structure of the robot arm. Software Information and Source Code The software information and source code section contains the software installation package, driver and related open source code that are compatible with the 280 M5 robot. Users can use these materials to install, upgrade and perform secondary development of the software to enhance the functions and application scenarios of the robot System Information The system information provides the system architecture and working principle of the 280 M5 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system Promotional Materials The promotional materials section contains the product brochure, demonstration video and customer cases of the 280 M5 robot. These materials not only show the core advantages and application scenarios of the robot, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. "},"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/","title":"8.1 Product Information","keywords":"","body":"Product Information Download The product information includes detailed specifications, technical parameters and instructions for use of the 280 M5 robot arm. This section is designed to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Download Link You can download all relevant product information through the following link: Product Information Download "},"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/","title":"8.2 Product Drawings","keywords":"","body":"Product Drawings The product drawings section provides detailed 3D and 2D drawings of the 280 M5 robot. These drawings are particularly important for engineers who need to make customized designs or perform maintenance, and can help them better understand the structure of the robot. Machine 3D Model Machine 3D Model File myCobot 280 M5 Download Machine 2D Drawings Machine Machine 2D Drawings myCobot 280 Atom Download myCobot 280 M5 Base Download Accessories 3D Models myCobot Series Accessories 3D Model Files Adaptive Gripper Download Parallel Gripper Download Flexible Gripper Download G-type base Download Large suction cup base Download Flat base Download Vertical Suction Pump Download Double-head suction pump Download Camera flange Download Spring bamboo shoots flange Download Dexterous Hand Download Pen holder Download Mobile Phone Gripper Download "},"3-FunctionsAndApplications/8.SupportingResources/8.3-SoftwareInformationAndSourceCode/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.3-SoftwareInformationAndSourceCode/","title":"8.3 Software Information and Source Code ","keywords":"","body":"Software information and source code The software information and source code section includes the software installation package, driver and related open source code for the 280 M5 robot arm. Users can use these materials to install, upgrade and perform secondary development of the software to enhance the functions and application scenarios of the robot arm You can download all relevant product information through the following link: Software Information Download The software download link includes the following commonly used software myStudio 2.0 The one-stop service platform myStudio integrates myCobot software resources and various materials. Main functions: Support firmware download and update; Provide product use video tutorials; Maintenance/repair information; RoboFlow RoboFlow is a human-computer interactive operation software developed by our company to facilitate users to quickly master the operation and use of the robot arm. Through simple operation procedures, it helps users to efficiently complete robot arm control and programming work. myBlockly myBlockly is a fully visual modular programming software, a graphical programming language, suitable for beginners to get familiar with programming. Users can create simple and complex functions by dragging and dropping puzzles to develop applications. Meta Care Meta Care is an interesting pet simulation game that combines elements such as pet raising, story and achievement collection. The game requires full Internet access. You need to own Meta Dog and connect to your device via Bluetooth. The game is only supported on Android devices. Elephant Luban Elephant Luban is a G-Code trajectory generation and use platform that provides user-based use cases, selects writing and painting, laser engraving use scenarios, and quickly opens up DIY creative space. MyCobot Controllerle MyCobot Controller is an APP that controls the MyCobot series of robotic arms via Bluetooth. You can use your phone to move the robotic arm. If you are an Android user, please go to [Google Play Store] If you are an IOS user, please wait for the software to be released before searching and downloading. "},"3-FunctionsAndApplications/8.SupportingResources/8.4-SystemInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.4-SystemInformation/","title":"8.4 System Information","keywords":"","body":"System Information The system information provides the system architecture and working principle of the 280 M5 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system (Information to be updated) "},"3-FunctionsAndApplications/8.SupportingResources/8.5-PromotionalMaterials/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.5-PromotionalMaterials/","title":"8.5 Promotional Materials","keywords":"","body":"Promotional Materials The promotional materials section includes the product brochure, demonstration video and customer cases of the 280 M5 robot arm. These materials not only show the core advantages and application scenarios of the robot arm, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. Machine Product Brochure myCobot 280 M5 Download Product unboxing video Product unboxing video Product promotion video Product promotion video User Case User Case "},"4-SupportAndService/11.AboutUs/11.AboutUs.html":{"url":"4-SupportAndService/11.AboutUs/11.AboutUs.html","title":" Contact Us","keywords":"","body":"Elephant Robotics 1. Company Introduction Based in Shenzhen, China, Elephant Robotics is a high-tech enterprise focusing on robot R&D, design and automation solutions. We are committed to providing highly flexible collaborative robots, easy-to-learn operating systems and intelligent automation solutions for robot education and scientific research institutions, commercial scenarios and industrial production. Its product quality and smart solutions have been unanimously recognized and praised by several factories from the world's top 500 companies in South Korea, Japan, the United States, Germany, Italy, Greece and other countries. Elephant Robotics adheres to the vision of \"Enjoy Robots World\" and advocates the collaborative work of people and robots, making robots a good helper for human work and life, helping people to be liberated from simple, repetitive and boring work, giving full play to the advantages of human-machine collaboration, thereby improving work efficiency and helping humans create a better new life. In the future, Elephant Robotics hopes to promote the development of the robot industry through a new generation of cutting-edge technology, and work with customers and partners to open a new era of automation and intelligence. 2. Development History 2016.08 -----Elephant Robotics Co., Ltd. was officially established 2016.08 -----Entered HAX incubator and received seed round investment from SOSV 2016.08 -----Started research and development of Elephant S industrial collaborative robot 2017.01 -----Rated as \"Top 10 Most Innovative Companies in China at CES\" 2017.04 -----Attended Hannover Industrial Fair and Korea Automation Exhibition 2017.07 -----Two founders were selected as \"30 Business Elites Under 30\" by Forbes Asia 2017.10 -----The fifth-generation single-arm industrial collaborative robot Elephant S was launched 2018.04 -----Received angel round investment from \"Yun Angel Fund\" 2018.06 -----First public appearance 2018 Hannover World Industrial Fair 2018.06 -----Won the \"Smart Manufacturing Entrepreneurship MBA Award\" from Cheung Kong Graduate School of Business 2018.06 -----Won the \"Entrepreneurship Accelerator X-elerator Award\" from Tsinghua School of Economics and Management 2018.11 -----Won the second place in the Shenzhen Division of the Asian Smart Hardware Competition 2018.11 -----Won the \"Most Investment Enterprise Award\" of the Gaogong Golden Globe Award 2019.03 -----Won the \"Leadership Award\" of the Gaogong Golden Globe Award 2019.04 -----In March 2019, Catbot won the \"Industrial Robot Innovation Award\" 2019.09 -----Attended the Huawei European Ecosystem Conference (HCE) and officially became a member of Huawei's ecological partner 2019.11 -----Elephant Robotics and Harbin Institute of Technology attended the IROS International Intelligent Robots and Systems Conference 2019.12 -----Elephant Robotics-South China University of Technology \"Intelligent Robot Joint Development Laboratory\" was officially unveiled 2019.12 -----Won the \"Innovation Technology Award\" of Gaogong in 2019 2019.12 -----Won the \"Top Ten Fast-Growing Enterprises\" of Gaogong in 2019 2019.12 -----Won the \"New Enterprise Award\" in the Industrial Robot Segment of Shenzhen Equipment Industry 2019.12 -----The world's first bionic robot cat MarsCat was launched 2020.05 -----The founder won the 2019 Shenzhen Robotics Newcomer Award 2020.10 -----The world's lightest and smallest six-axis collaborative robot myCobot was launched 2021.03 -----The smallest collaborative robot for scientific research myCobotPro 320 was launched 2021.05 -----Mars bionic cat MarsCat Received coverage from Xinhua Finance, China Daily, Nanjing Daily, Harbin Daily and other media 2021.07 -----Released the smallest composite robot chassis - Elephant Mobile Robot myAGV 2021.09 -----The world's first fully enclosed four-axis robotic arm - Elephant palletizing robotic arm myPalletizer was launched 3. Related links Purchase link Taobao: https://shop504055678.taobao.com Shopify: https://shop.elephantrobotics.com/ AliExpress: https://elephantrobotics.aliexpress.com/store/1101941423Other information Official website: https://www.elephantrobotics.com Video Bilibili: https://space.bilibili.com/2126215657 Youtube: https://www.youtube.com/c/Elephantrobotics Facebook: https://www.facebook.com/mycobotcreator/ Linkedin: https://www.linkedin.com/company/18319865 X (Twitter): https://twitter.com/CobotMy Discord: https://discord.gg/2MAherp7nt Hackster: https://www.hackster.io/elephant-robotics 4. Contact Us Our working hours are China working days, 10 am to 6 pm Beijing time. If you have any other questions, please contact us via the following methods. E-mail : support@elephantrobotics.com - If you have any purchase intention or any parameter questions, please send an email to this mailbox. [E-mail](sales@elephantrobotics.com) : sales@elephantrobotics.com If you encounter any problems in the use of this product, please read Chapter 9 of the manual first. If the problems listed cannot help you solve them, and you have more after-sales problems, please send an email to this mailbox. E-mail : support@elephantrobotics.com We will respond within 1-2 working days; WeChat: We only provide one-to-one service for users who purchase mycobot products through WeChat. ← Previous Chapter | Next Chapter → "},"4-SupportAndService/Accessories/accessories.html":{"url":"4-SupportAndService/Accessories/accessories.html","title":"Robot Arm Accessories","keywords":"","body":"Product Accessories In the real world, different accessories can enhance the capabilities of robots in various ways. For example, accessories such as grippers, sensors, and tools can help robots perform various tasks, thereby increasing their versatility and flexibility. Elephant Robotics is committed to making robots and these accessories easy for everyone to use, freeing users from the complexity of choosing the right accessories and enabling them to quickly start using robots. Accessory Types In order to meet the needs of customers in different scenarios, we have designed various types of accessories, including grippers, suction cups, camera modules, and other gripping devices, so that users can directly choose the right end effector Base Flat Base Suitable for fixing the robot arm on a flat and smooth surface. G-Base Suitable for fixing the robot arm on the edge of a table. Gripper Adaptive Gripper The gripper is a robot component that can achieve functions similar to human hands. It has the advantages of complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper accessories and Lego technology parts. The end effector of the robot arm is controlled by a programmable system to achieve functions such as object grasping and multi-point positioning. Parallel Gripper Driven by a motor, the finger surface of the gripper makes a linear reciprocating motion to achieve the opening or closing action. The acceleration and deceleration of the electric gripper can be controlled, the impact on the workpiece can be minimized, the positioning point can be controlled, and the clamping can be controlled Flexible Gripper-Open Foot Type The fingertips are made of rubber and rely on air pressure deformation to grasp objects. Pneumatic manipulators are widely used and are favored for their softness, adaptability and efficiency. These advantages make them powerful tools in automation and robotic applications, capable of effectively handling a wide range of objects and tasks Suction Pumps Vertical Suction Pumps With one suction nozzle and one exhaust nozzle, the suction pump kit is controlled as the end effector of the robot arm to perform the function of sucking objects. Double-head Suction Pumps Compared with single-head suction pumps, it is more stable, with simple structure, small size, easy to use, low noise, and good self-priming ability. Integrated Suction Pumps The integrated suction pump has the advantages of simple structure, small size, easy to use, low noise, and good self-priming ability. Holder Pen Holder The overall solid color design can be used for writing, drawing and other applications. Phone Holder Suitable for devices that require physical clamping, such as photography, and can clamp a variety of mobile phones. It has a simple structure and is easy to install and disassemble. Other functional accessories Dexterous Hand A robot component that can achieve functions similar to human hands. It has the advantages of a complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper accessories and Lego technology parts. The end effector of the robot arm is controlled by a programmable system to achieve functions such as object grasping and multi-point positioning. USB Camera The USB high-definition camera can be used with suction pumps, adaptive grippers, artificial intelligence kits, etc., and eye in hand can achieve precise positioning and calibration. Bamboo Flange Suitable for devices with physical travel such as click buttons and keyboards. The overall solid color design, simple structure, and easy installation and disassembly. "},"4-SupportAndService/Accessories/Flatbase.html":{"url":"4-SupportAndService/Accessories/Flatbase.html","title":"Flat Base","keywords":"","body":"Flat base Applicable models: myCobot 280 Specifications: Name Flat base Model myCobot_Fstand_grey Color Gray, black Process ABS compression molding Size 145×145×13 Weight 60g Fixed Lego connector/screw fixation Environment requirements Normal temperature and pressure Applicable equipment Fit ER myCobot 280 M5, ER myCobot 280 Pi Instructions for use: Applicable to flat and smooth surfaces Install the suction cups at the four corners of the base and tighten them. Use the included Lego tech parts to connect the flat base and the bottom of the robot arm. Fix the four suction cups on a flat and smooth surface before starting to use. Remove the nut: Tighten through the holes at the four corners: Adjust the number of Lego connectors as needed. It is recommended to use a sufficient number of connectors to ensure the stability of the machine: Tips You can add a small amount of non-conductive liquid under the suction cup to fill the gap between the suction cup and the desktop to obtain the best adsorption effect. --- "},"4-SupportAndService/Accessories/Gstands_2.0.html":{"url":"4-SupportAndService/Accessories/Gstands_2.0.html","title":"G-Stand","keywords":"","body":"G-type stand 2.0 Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Specifications: Name G-type stand 2.0 Model myCobot_Gstand_grey_V2 Color Gray, black Process ABS compression molding Size 174.8x166x31 Fixed Lego connector/screw fixation Environment requirements Normal temperature and pressure Applicable equipment Fit ER myCobot 280 series, ER myPalletizer 260 series, mecharm 270 series, myBuddy 280 series Instructions: G-type base - fixed to the edge of the table Use the G-shaped clamp to fix the base to the edge of the table Use the included Lego connector to connect the base and the bottom of the robot arm Make sure it is stable before starting to use Insert the Lego connector as needed "},"4-SupportAndService/Accessories/AdaptiveGripper.html":{"url":"4-SupportAndService/Accessories/AdaptiveGripper.html","title":"Adaptive Gripper","keywords":"","body":"Adaptive gripper Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product image Specifications: Name mycobot280 Adaptive Gripper Model model myCobot_gripperAg_white Process ABS injection molding Color White Gripping range 20-45mm Maximum gripping force 150g Repeatability 1mm Service life One year Drive mode Electric Transmission mode Gear + connecting rod Dimensions 112×94×50mm Weight 110g Fixing method Lego connector Environment requirements Normal temperature and pressure Control interface Serial control Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Adaptive gripper: Used to grip objects Introduction The gripper is a robot component that can achieve functions similar to human hands. It has the advantages of complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper accessories and Lego technology parts. The end effector of the robot arm is controlled by a programmable system to realize functions such as object gripping and multi-point positioning. The gripper can be used in all development environments, such as ROS, Arduino, Roboflow, etc. Working Principle Driven by a motor, the gripper's finger surface makes linear reciprocating motion to achieve opening or closing. The acceleration and deceleration of the electric gripper are controllable, the impact on the workpiece can be minimized, the positioning point is controllable, and the clamping is controllable. Applicable objects Small cubes Small balls Long objects Installation and use Check whether the accessories package is complete: Lego connectors, grippers with connecting wires, and connecting wire extension wires Gripper installation: Structural installation: Insert the Lego connector into the socket reserved for the gripper. You can choose two different directions for installation as needed: Align the gripper with the connector inserted into the socket at the end of the robot arm and insert it: Electrical connection Connect the extension cord to the gripper: Insert the robot control interface: Programming development: Use python to program the gripper M5 version: from pymycobot import MyCobot280 import time # Initialize a MyCobot object mc = MyCobot280(\"COM3\", 115200) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method three: # mc.set_encoder(7, 2048, 20) # time.sleep(3) # mc.set_encoder(7, 1500, 20) # time.sleep(3) # mc.set_encoder(7, 2048, 20) # time.sleep(3) Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot import time # Initialize a MyCobot object mc = MyCobot280(PI_PORT, PI_BAUD) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method 3: # mc.set_encoder(7, 2048, 20) # time.sleep(3) # mc.set_encoder(7, 1500, 20) # time.sleep(3) # mc.set_encoder(7, 2048, 20) # time.sleep(3) Save the file and close it. Return to the command line terminal and enter: python grip.py You can see the gripper open-close-open "},"4-SupportAndService/Accessories/ParallelGripper.html":{"url":"4-SupportAndService/Accessories/ParallelGripper.html","title":"Parallel Gripper","keywords":"","body":"Parallel gripper Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product image Specifications: Name mycobot280 parallel gripper Model model myCobot_gripper_parallel Process ABS injection molding Color White Gripping range Maximum gripping force 150g Repeatability 1mm Service life One year Drive mode Electric Transmission mode Gear + connecting rod Dimensions 66×78×46mm Weight 84g Fixing method Lego connector Environment requirements Normal temperature and pressure Control interface Serial control Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Parallel gripper: Used to grip objects Introduction The gripper is a robot component that can achieve functions similar to human hands. It has the advantages of complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper accessories and Lego technology parts. The end effector of the robot arm is controlled by a programmable system to realize functions such as object gripping and multi-point positioning. The gripper can be used in all development environments, such as ROS, Arduino, Roboflow, etc. Working Principle Driven by a motor, the gripper's finger surface makes linear reciprocating motion to achieve opening or closing. The acceleration and deceleration of the electric gripper are controllable, the impact on the workpiece can be minimized, the positioning point is controllable, and the clamping is controllable. Applicable objects Small cubes Small balls Long objects Installation and use Check whether the accessories package is complete: Lego connectors, grippers with connecting wires Gripper installation: Structural installation: Insert the Lego connector into the reserved socket of the gripper: Align the gripper with the connector inserted into the socket at the end of the robot arm and insert it: Electrical connection: Insert the robot arm control interface: Programming and development: Use python to program the gripper M5 version: from pymycobot import MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(\"COM3\", 115200) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method three: # mc.set_encoder(7, 2048, 20) # time.sleep(3) # mc.set_encoder(7, 1500, 20) # time.sleep(3) # mc.set_encoder(7, 2048, 20) # time.sleep(3) Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(PI_PORT, PI_BAUD) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method 3: # mc.set_encoder(7, 2048, 20) # time.sleep(3) # mc.set_encoder(7, 1500, 20) # time.sleep(3) # mc.set_encoder(7, 2048, 20) # time.sleep(3) Save the file and close it, return to the command line terminal, and enter: python grip.py You can see the gripper open-close-open "},"4-SupportAndService/Accessories/flexible_gripper_2.html":{"url":"4-SupportAndService/Accessories/flexible_gripper_2.html","title":"Flexible Gripper - Open Leg Type","keywords":"","body":"Flexible Gripper - Open-leg Type Applicable models: myCobot 280, myPalletizer 260, mechArm 270, myBuddy 280 Product Image Specifications: Name mycobot280 Open-leg Gripper Model model myCobot Open-leg Gripper Process Photosensitive resin Color White Repeatability ±1mm Service life One year Drive mode Electric Fixing mode Lego connector Environmental requirements Normal temperature and pressure Control interface Serial control Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Flexible gripper: Used to grip objects Introduction Traditional industrial suction cups need to suck the flat surface of the material. In more and more working conditions, the suction surface is easy to damage the panel or components. The soft-touch gripper grabs the edge and easily transports the panel without marks or damage, ensuring that the product surface is flawless and improving the yield rate. The modular design of the soft-touch gripper is light in weight and can be freely arranged and combined according to the size of the panel. The clamping force of traditional cylinders is generally large, and the force is difficult to control. The edge of the clamped panel is easy to be clamped and warped. The single-finger clamping force of the flexible gripper is precisely controllable and will not clamp fragile workpieces. Working Principle The flexible gripper is an innovative bionic flexible gripper developed by researchers imitating the shape of the arms and legs of a starfish. The \"fingers\" of the soft gripper are made of flexible polymer silicone material, which can bend and deform by inflation. It can adaptively wrap around the target object like a starfish, and can complete the flexible and non-destructive grasping of irregular and fragile objects. Applicable objects Any object of any shape within a reasonable size Installation and use Check whether the accessories package is complete: Lego connector, gripper with connecting wire, extension wire Gripper installation: Structural installation: Insert the Lego connector into the reserved socket of the gripper. You can choose two different directions for installation as needed: Align the gripper with the connector inserted into the socket at the end of the robot arm and insert it: Electrical connection: Connect the extension wire to the gripper: Insert the robot control interface: Programming development M5 version: from pymycobot import MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(\"COM3\", 115200) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method three: # mc.set_encoder(7, 2048, 20) # time.sleep(3) # mc.set_encoder(7, 1500, 20) # time.sleep(3) # mc.set_encoder(7, 2048, 20) # time.sleep(3) Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(PI_PORT, PI_BAUD) # The following three methods can control the gripper to open-close-open # Method 1: mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(1, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) mc.set_gripper_state(0, 80) time.sleep(3) # Method 2: # mc.set_gripper_value(100, 80) # time.sleep(3) # mc.set_gripper_value(0, 80) # time.sleep(3) # mc.set_gripper_value(100, 80) # time.sleep(3) # Method 3: # mc.set_encoder(7, 2048) # time.sleep(3) # mc.set_encoder(7, 1500) # time.sleep(3) # mc.set_encoder(7, 2048) # time.sleep(3) Save the file and close it, return to the command line terminal, and enter: python grip.py You can see the gripper open-close-open "},"4-SupportAndService/Accessories/pump.html":{"url":"4-SupportAndService/Accessories/pump.html","title":"Vertical Suction Pump","keywords":"","body":"Vertical Suction Pump V2.0 Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product Image Specifications Name myCobot Vertical Suction Pump V2.0 Model myCobot_suctionPump_V2.0_grey Material ABS injection molding Color White Dimensions Suction Pump Box: 72x52x37 Suction Pump End: 63x24.5x26.7 Number of Suction Cups 1 Suction Cup Size Diameter 20mm Suction Weight 150g Power Source Equipment Suction pump box Service life One year Fixing method Lego connector Control interface IO control Use environment requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Suction pump: Used for adsorbing objects Introduction Suction pump, that is, vacuum adsorption pump, has one suction nozzle and one exhaust nozzle. It has the advantages of simple structure, small size, easy use, low noise, and good self-priming ability. By controlling the suction pump kit as the end effector of the robot arm, the function of adsorbing objects is performed. Suction pump accessories: power cord x1, Dupont wire x10, one-input and two-output connection wire x1, several Lego tech parts Working principle When sucking objects: the air pump starts to suck air and adsorbs the objects and then stops, and there will be no air leakage in a short time. When putting down the objects: the electronic valve starts, the air release valve opens, and air enters the vacuum suction cup to separate from the sucked objects. Applicable objects Paper/plastic sheets Flat and smooth objects Cards, etc. Installation and use Check whether the accessories package is complete: Lego connectors, Dupont wires, double-head suction pump Double-head suction pump installation: Structural installation: Insert the Lego connector into the reserved socket on the suction pump: Align the suction pump with the connector plugged in with the socket at the end of the robotic arm and insert it: Electrical connection: Select the male-female DuPont wire and insert the female end into the socket marked with pins on the suction pump box: Male-female DuPont wire: Note the correspondence between the DuPont wire colors and pins in the figure: Insert the male end into the robot base pin according to the given correspondence: The left side is the suction pump pin and the right side is the robot pin GND -> GND 5V -> 5V G2 -> 21 G5 -> 20 Programming development: Use python to program the suction pump The code is as follows: 280-M5 version: from pymycobot import MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(\"COM3\", 115200) # Turn on the suction pump def pump_on(): # Open the solenoid valve mc.set_basic_output(5, 0) time.sleep(0.05) # Stop the suction pump def pump_off(): # Close the solenoid valve mc.set_basic_output(5, 1) time.sleep(0.05) # The deflation valve starts working mc.set_basic_output(2, 0) time.sleep(1) mc.set_basic_output(2, 1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release pin channel 280-Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot import time import RPi.GPIO as GPIO # Initialize a MyCobot object mc = MyCobot280(PI_PORT, PI_BAUD) # Initialize GPIO.setmode(GPIO.BCM) # Pins 20/21 control the solenoid valve and the deflation valve respectively GPIO.setup(20, GPIO.OUT) GPIO.setup(21, GPIO.OUT) # Turn on the suction pump def pump_on(): # Open the solenoid valve GPIO.output(20, 0) # Stop the suction pump def pump_off(): # Close the solenoid valve GPIO.output(20, 1) time.sleep(0.05) # Open the deflation valve GPIO.output(21, 0) time.sleep(1) GPIO.output(21, 1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release the pin channel "},"4-SupportAndService/Accessories/doublepump.html":{"url":"4-SupportAndService/Accessories/doublepump.html","title":"Double-head suction pump","keywords":"","body":"Dual-head suction pump Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product image Specifications Name Dual-head suction pump Model myCobot_DualPump_grey Material Photosensitive resin/nylon 7100 Color White+black Size Pump end: 63x24.5x26.7 Number of suction cups 2 Suction cup size Diameter 20mm Suction weight 150g Power source equipment Pump box Service life One year Fixing method Lego connector Control interface IO control Environment requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Suction pump: Used for adsorbing objects Introduction Suction pump, that is, vacuum adsorption pump, has two suction nozzles and two exhaust nozzles for one inlet and one outlet. It is more stable than single-head suction pump. It has the advantages of simple structure, small size, easy use, low noise, and good self-priming ability. By controlling the suction pump kit as the end effector of the robot arm, the function of adsorbing objects is performed. Suction pump accessories: power cord x1, DuPont line x10, one-input and two-output connection line x1, Lego technology parts x several Working principle When sucking objects: the air pump starts to suck air and adsorb objects and then stops, and there will be no leakage in a short time. When putting down the object: the electronic valve starts, the air release valve opens, and air enters the vacuum suction cup to separate from the sucked object. Applicable objects Paper/plastic sheets Flat and smooth objects Cards, etc. Installation and use Check whether the accessories package is complete: Lego connectors, Dupont wires, double-head suction pump Double-head suction pump installation: Structural installation: Insert the Lego connector into the reserved socket on the suction pump: Align the suction pump with the connector plugged in with the socket at the end of the robotic arm and insert it: Electrical connection: Select the male-female DuPont wire, and insert the female end into the socket marked with pins on the suction pump box: Note the correspondence between the DuPont wire colors and pins in the figure: Insert the male end into the robot base pin according to the given correspondence: The left side is the suction pump pin, and the right side is the robot arm pin GND -> GND 5V -> 5V G2 -> 21 G5 -> 20 Programming development: The code is as follows: 280-M5 version: from pymycobot import MyCobot280 import time # Initialize a MyCobot object mc = MyCobot280(\"COM3\", 115200) # Turn on the suction pump def pump_on(): # Open the solenoid valve mc.set_basic_output(5, 0) time.sleep(0.05) # Stop the suction pump def pump_off(): # Close the solenoid valve mc.set_basic_output(5, 1) time.sleep(0.05) # The exhaust valve starts working mc.set_basic_output(2, 0) time.sleep(1) mc.set_basic_output(2, 1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release pin channel 280-Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot import time import RPi.GPIO as GPIO # Initialize a MyCobot280 object mc = MyCobot280(PI_PORT, PI_BAUD) # Initialization GPIO.setmode(GPIO.BCM) # Pins 20/21 control the solenoid valve and the exhaust valve respectively GPIO.setup(20, GPIO.OUT) GPIO.setup(21, GPIO.OUT) # Turn on the suction pump def pump_on(): # Open the solenoid valve GPIO.output(20,0) # Stop the suction pump def pump_off(): # Close the solenoid valve GPIO.output(20,1) time.sleep(0.05) # Open the vent valve GPIO.output(21,0) time.sleep(1) GPIO.output(21,1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release the pin channel Save the file and close it, return to the command line terminal, and enter: python pump_double.py You can see that the suction pump opens after 3 seconds and closes after working for 3 seconds "},"4-SupportAndService/Accessories/IntegratedPump.html":{"url":"4-SupportAndService/Accessories/IntegratedPump.html","title":"Integrated suction pump","keywords":"","body":"Integrated suction pump Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Specifications Name myCobot integrated suction pump Model myCobot integrated suction pump Material ABS injection molding Color White Size Diameter 20mm Number of suction cups 1 Suction weight 50g Power source equipment Suction pump box Service life One year Fixing method Lego connector Control interface IO control Use environment requirements Normal temperature and pressure Applicable equipment ER myCobot 280 Series, ER myPalletizer 260 Series, ER mechArm 270 Series, ER myBuddy 280 Series Suction pump: Used for adsorbing objects Introduction Suction pump, that is, vacuum adsorption pump, has one suction nozzle and one exhaust nozzle. It has the advantages of simple structure, small size, easy use, low noise, and good self-priming ability. By controlling the suction pump kit as the end effector of the robot arm, the function of adsorbing objects is performed. Suction pump accessories: power cord x1, DuPont line x10, one-input and two-output connection line x1, Lego technology parts x several Working principle When sucking objects: the air pump starts to suck air and adsorb objects and then stops, and there will be no air leakage in a short time. When putting down objects: the electronic valve starts, the air release valve opens, and air enters the vacuum suction cup to separate from the sucked objects. Applicable objects Paper/plastic sheets Flat and smooth objects Cards, etc. Installation and use Check whether the accessories package is complete: Lego connectors, Dupont wires, double-head suction pump Suction pump installation Structural installation: Insert the Lego connector into the reserved socket on the suction pump: Align the suction pump with the connector plugged in with the socket at the end of the robot arm and insert it: > Electrical connection: Select the male-female DuPont wire, and insert the female end into the socket marked with pins on the suction pump box: Male-female DuPont wire: Note the correspondence between the DuPont wire colors and pins in the figure: Insert the male end into the robot base pin according to the given correspondence: The left side is the suction pump pin, and the right side is the robot arm pin GND -> GND 5V -> 5V G2 -> 21 G5 -> 20 Programming development: 280-M5 Version: from pymycobot import MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(\"COM3\", 115200) # Turn on the suction pump def pump_on(): # Open the solenoid valve mc.set_basic_output(5, 0) time.sleep(0.05) # Stop the suction pump def pump_off(): # Close the solenoid valve mc.set_basic_output(5, 1) time.sleep(0.05) # The exhaust valve starts working mc.set_basic_output(2, 0) time.sleep(1) mc.set_basic_output(2, 1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release pin channel 280-Pi version: from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot import time import RPi.GPIO as GPIO # Initialize a MyCobot280 object mc = MyCobot280(PI_PORT, PI_BAUD) # Initialization GPIO.setmode(GPIO.BCM) # Pins 20/21 control the solenoid valve and the bleed valve respectively GPIO.setup(20, GPIO.OUT) GPIO.setup(21, GPIO.OUT) # Turn on the suction pump def pump_on(): # Open the solenoid valve GPIO.output(20,0) # Stop the suction pump def pump_off(): # Close the solenoid valve GPIO.output(20,1) time.sleep(0.05) # Open the exhaust valve GPIO.output(21,0) time.sleep(1) GPIO.output(21,1) time.sleep(0.05) pump_off() time.sleep(3) pump_on() time.sleep(3) pump_off() time.sleep(3) GPIO.cleanup() # Release the pin channel "},"4-SupportAndService/Accessories/penHolder.html":{"url":"4-SupportAndService/Accessories/penHolder.html","title":"Pen holder","keywords":"","body":"myCobot Pen Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Product image Specifications: Name myCobotPro Pen Holder Model myCobot_penHolder_J6 Material Photosensitive resin (painted white) Dimensions 47.5 x 25.0 x 45.5 mm Weight Approx. 35g (excluding pen weight) Pen tip clearance ±1 mm Service life One year Fixing method Lego connector Environment requirements Normal temperature and pressure Applicable equipment Support ER myCobot 280 series ER myPalletizer 260 series ER mechArm 270 series ER myBuddy 280 series myCobot pen holder: Used when writing and drawing with a robotic arm Introduction Overall solid color design, supports 15mm large stroke extension and retraction, effectively reduces errors, and can be used for writing, drawing and other applications. Applicable objects Whiteboard pen Installation and use Installation Insert the Lego connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Insert the pen into the round hole and tighten the four screws to fix it. "},"4-SupportAndService/Accessories/phoneHolder.html":{"url":"4-SupportAndService/Accessories/phoneHolder.html","title":"Phone holder","keywords":"","body":"myCobot Phone Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series Product image Specifications: Name myCobot Phone Holder Model myCobot_PhoneHolder_J6 Material ABS injection molding Size Diameter 34*10 Color White+Black Clamping weight 50g Service life Two years Fixing method LEGO connector Environmental requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series ER mechArm 270 series ER myPalletizer 260 series myCobot mobile phone holder: Used to hold mobile phones or objects Introduction Suitable for devices that require physical clamping, such as photography, and can hold a variety of mobile phones. It has a simple structure and is easy to install and disassemble. Applicable objects Camera equipment Installation Insert the LEGO connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Pull the holder open, put the camera in, and let go. After confirming that the device is fixed, it can be used. "},"4-SupportAndService/Accessories/Robothand.html":{"url":"4-SupportAndService/Accessories/Robothand.html","title":"Dexterous hand","keywords":"","body":"Dexterous Hand Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product Image Specifications: Name mycobot Dexterous Claw Model Dexterous Hand Material 3D Printing Size 112×94×50mm Color White Transmission Mode Gear + Connecting Rod Clamping Range 20-45mm Maximum Clamping Force 100g Fixing Mode Screw Fixing Environment Requirements Normal Temperature and Pressure Control Interface Serial Control Applicable Equipment ER myCobot 280 Series, ER mechArm 270 Series, ER myPalletizer 260 Series Dexterous Hand: Used when gripping objects Introduction The gripper is a robot component that can achieve functions similar to human hands. It has the advantages of a complex structure, firm gripping of objects, not easy to drop, and easy operation. The gripper kit includes gripper accessories and LEGO technology parts. The end effector of the robot arm is controlled by a programmable system to achieve functions such as object gripping and multi-point positioning. Working principle Driven by a motor, the gripper's finger surface makes linear reciprocating motion to achieve opening or closing. The acceleration and deceleration of the electric gripper can be controlled, the impact on the workpiece can be minimized, the positioning point can be controlled, and the clamping can be controlled Applicable objects Small cubes Small balls Long objects Gripper installation: Insert the Lego connector into the gripper hole: Electrical connection Insert the gripper with the connector installed into the end of the robot arm Python programming control M5 Version from pymycobot import MyCobot280 import time # Initialize a MyCobot280 object mc = MyCobot280(\"COM3\", 115200) mc.set_encoder(7,2048,40)#Open time.sleep(2) mc.set_encoder(7,2300,40)#Hold time.sleep(2) mc.set_encoder(7,2048,40)#Hold Pi version ```python from pymycobot import MyCobot280 from pymycobot import PI_PORT, PI_BAUD # When using the Raspberry Pi version of mycobot, you can reference these two variables to initialize MyCobot280 import time Initialize a MyCobot280 object mc = MyCobot280(PI_PORT, PI_BAUD) mc.set_encoder(7,2048,40)#Open time.sleep(2) mc.set_encoder(7,2300,40)#Hold tight time.sleep(2) mc.set_encoder(7,2048,40)#Hold tight ``` "},"4-SupportAndService/Accessories/USBcamera.html":{"url":"4-SupportAndService/Accessories/USBcamera.html","title":"USB camera","keywords":"","body":"myCobot camera module v2.0 Applicable models: myCobot 280, myPalletizer 260, mechArm 270 Product image Specifications: Name myCobot camera module v2.0 Model myCobot_cameraHolder_J6 Color White (default) Material ABS injection molding Size 836416 USB protocol USB2.0 HS/FS Lens focal length Standard 1.7mm Field of view About 60° Supported systems Win7/8/10, Linux, MAC Supported resolutions 2592x1944, 2560x1440, 2048x1536, 1920x1080, 1280x72, 1024x768, 800x600, 640x480, 640x360, 352x288, 320x240, 176x144 Service life Two years Fixing method Lego connector Environment requirements Normal temperature and pressure Applicable equipment support ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series Camera flange: Machine vision Introduction USB high-definition camera can be used with suction pump, adaptive gripper, artificial intelligence kit, etc., to achieve precise positioning and calibration with eye in hand. Installation and Use Check if the accessories package is complete: Lego connector, camera module with USB cable Camera installation: Structural installation: Insert the Lego connector into the reserved socket of the camera module: Align the camera module with the connector into the socket at the end of the robot arm: Electrical connection: Insert the USB cable into the USB port of the base: Programming development: The code is as follows: python import cv2 import numpy as np cap = cv2.VideoCapture(0) # \"0\", determined by the camera device number queried while(True): ret, frame = cap.read() # gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.show('frame', frame) if cv2.waitKey(1) & 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() "},"4-SupportAndService/Accessories/bamboo.html":{"url":"4-SupportAndService/Accessories/bamboo.html","title":"Bamboo flange","keywords":"","body":"Spring Bamboo Shoot Flange Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series Product image Specifications: Name myCobot Spring Bamboo Shoot Flange Material Nylon Hardness Fragile Service life Two years Fixing method Lego connector Environmental requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series myCobot Spring Bamboo Shoot Flange: Used for clicking buttons Introduction Suitable for devices with physical travel such as click buttons and keyboards. The overall solid color design, simple structure, easy to install and disassemble. Applicable objects Keyboard Button "},"5-Acknowledgments/5-Acknowledgments.html":{"url":"5-Acknowledgments/5-Acknowledgments.html","title":"Acknowledgments","keywords":"","body":"Acknowledgements We would like to express our deep gratitude to all the people who have participated in the development, testing and improvement of the myCobot series of products (including myCobot 280 pi, myCobot 280 M5, myCobot 280 JN, myCobot 280 For Arduino and kits). Every detail polished and every feature innovative is inseparable from the hard work and dedication of the team behind it. Special thanks: R&D Team: Thank you for your innovative thinking and countless days and nights of hard work to transform complex technology into user-friendly products. QA & Testing Team: Your strict control of every detail ensures the reliability of our products and the ultimate experience of users. Customer Support Team: Thank you for providing professional support to our users to help them solve every problem during use. Partners & Suppliers: Your support and service are crucial to the success of the product. Thank you for your high-quality raw materials and components, and your attitude of being ready to support. Investors and Advisors: Without your trust and financial support, we would not be able to bring these innovations to the market. Your insights and guidance have always been our driving force. User Thanks: We are especially grateful to every user who has chosen and trusted the myCobot series of products. Your feedback and suggestions are the driving force for our continuous progress and improvement. We promise to continue to listen to your voice and continuously optimize our products and services. Future Outlook: We look forward to continuing to explore and progress on the road of robotics with all stakeholders. Let us work together to create more possibilities and bring greater convenience and innovation to the world. ← Previous Chapter "}}