{"./":{"url":"./","title":"Introduction","keywords":"","body":"myCobot Pro 450 The first choice for getting started with the full harmonic collaborative robot arm Core Document This document contains comprehensive information from product introduction, detailed technical parameters to user instructions and product development guidance. The document will introduce the basic functions of the myCobot Pro 450 robot arm in depth, provide software development guidelines, and show successful application cases to help you understand how to effectively integrate myCobot Pro 450 into various applications. In addition, we also provide a wealth of support and service information to ensure that you can get the necessary help when you encounter any technical challenges. Document Description Depending on your needs and your level of expertise in myCobot Pro 450 application development, you can choose to follow this order from beginning to end or use it as a standalone reference. You can always use the sidebar navigation on the left to jump to any part of this document. The full text is divided into the following five sections: Product Information The product information section will provide you with a basic overview of the robot arm, including detailed technical specifications such as main functions, product parameters and electrical characteristics, to help you quickly understand the basic characteristics and usage environment of the product. In addition, this section will detail the application examples and supported extended development of the product, providing you with the necessary development guides and resources. At the end of the article, relevant purchase links and channels will be provided for your convenience. Basic Settings This section is an important section that every user of this product must read carefully. It covers key information about the use, transportation, storage and maintenance of the product, aiming to ensure the safety and efficiency of users when operating the product. In addition, this section also details the division of responsibilities for product failure or damage that may occur due to failure to follow these guidelines. Functions and Applications The Functions and Applications section details the basic functions of the robotic arm and how to use the software, including instructions for using myBlockly and system and firmware updates. The Software Development Guide provides guidance based on different development environments, such as Python and ROS2, to support technical developers in expanding their applications. By showcasing successful application cases and providing supporting resources, we provide practical references and essential support materials for a deeper understanding and use of the product. Support and Services The Support and Services section will provide you with comprehensive troubleshooting guides and post-purchase service information, such as warranty and service terms, to help you quickly resolve problems when you encounter them, and ensure that you understand your rights and obligations after purchase. In addition, the 'About Us' section reinforces the user's understanding of the myCobot series product design and manufacturer, aiming to build trust and brand loyalty. Acknowledgements We appreciate your taking the time to read the myCobot Pro 450 User Manual. We hope that this document will help you better understand and effectively use this robot, thereby inspiring your creativity. If you have any questions or need further assistance, please feel free to contact our customer support team. We look forward to seeing the innovative projects you complete with myCobot Pro 450 and welcome you to join our fast-growing developer community. Document Directory "},"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html":{"url":"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html","title":"1. IntroductionProduct ","keywords":"","body":"Product Introduction 1. Product Description myCobot Pro 450 The first choice for getting started with the full harmonic collaborative robot arm 1.1 Product Introduction The myCobot Pro 450 is a compact, fully harmonic, six-axis collaborative robot arm designed for use in education, scientific experiments, commercial demonstrations, and light industrial automation. It boasts a wide range of core functions and precise manipulation capabilities, including a working radius of up to 450 mm, a payload capacity of 1 kg, and positioning repeatability up to ±0.1 mm. It excels at a wide range of light-load, high-precision tasks. In terms of control, it relies on a built-in industrial-grade core control board and self-developed control system, which can be easily connected to terminal devices such as computers, tablets, and mobile phones. The pre-installed drag-and-drop programming software and quick debugging interface make it easy for users with no basic knowledge to get started. At the same time, the integrated interface design on the tool side eliminates the trouble of cables when connecting the grippers, and the newly added CAN and RS485 interfaces on the base provide ample space for secondary development and function expansion. Its core value lies in providing users in different fields with a high-performance, easy-to-use and highly scalable collaborative robot arm solution, helping to improve work efficiency and innovation capabilities. 1.2 Design Concept The myCobot Pro 450 was designed to meet the growing demand for diverse applications. In education, it aims to help students more intuitively engage with and learn robotics, cultivating practical skills and innovative thinking. In scientific research, it aims to provide researchers with stable and precise experimental tools, accelerating their research progress. In commercial displays, it aims to create engaging interactive experiences and enhance presentations. 1.3 Design Goals Design goals description Application scenarios and features Meet diverse high-precision operation needs The 450mm working radius covers a standard tabletop, the 1kg payload supports multiple end effectors, and the repeatability accuracy is controlled to ±0.1mm. - Educational and scientific research scenarios: can be used for experimental data collection, and its high precision can ensure the accuracy and reliability of the data；- Light industrial automation scenarios: It can perform fine material processing, such as the installation and sorting of electronic components, to improve production efficiency and product quality. Lowering usage thresholds and technical barriers Multi-terminal connection, pre-installed drag-and-drop programming software, 4 industrial-grade connections and multi-standard protocols, easy to use even with zero basic knowledge. - Educational teaching scenario: Students can easily connect and operate the robotic arm through terminal devices, learn robot programming knowledge with the help of programming software, and improve practical skills；- Business scenarios: Enterprise personnel can use this robotic arm to conduct preliminary research and verification of solutions without complex technical training, reducing the cost of using technology. Promote innovative application and expansion It integrates multimodal and embodied intelligent large models, features visual and voice control, provides four out-of-the-box solutions, and supports secondary development through its interfaces. - Research scenarios: Researchers can conduct cutting-edge research on robot intelligent decision-making, autonomous motion strategies, and other topics based on large models and embodied intelligence capabilities.；- Commercial display scenarios: Leverage multimodal interaction and unique application solutions to create a novel interactive display experience, attract customer attention, and enhance brand image. 1.4 Feature Features Feature description Ultra-long standby Laboratory-verified lifespan > 10,000 hours (Note: actual operating conditions may affect this), long-lasting stability, making teaching and research less stressful. Commercial-grade safety joints The integrated harmonic reducer + servo motor + joint brake + controller self-locks upon power failure, ensuring safety and reliability, and greater peace of mind for human-machine collaboration. Integrated precision, solid and reliable The all-metal integrated high-temperature die-cast body has uniform structural strength and a built-in controller, eliminating the need for external electrical boxes and complex cables, making it simple and efficient. The Internet of Things Support for four industrial-grade connections (WLAN/EtherNet/RS485/CAN) and a variety of protocols (Socket-TCP/Modbus/CANOpen) allows for easy integration into existing systems and worry-free Industry 4.0 integration. Precise and efficient, lightweight choice Working radius: 450mm, load: 1kg, accuracy: ±0.1mm, weight: Zero threshold control myCobot Pro cross-platform control center - connect directly from your browser (just enter the IP address), no installation required! Integrated: Blockly graphical programming & drag-to-teach: turn novice programmers into programming experts in seconds. Fast mobile control & status monitoring. Supports multiple connection configurations including Modbus, VNC, and Socket. One-stop firmware upgrades and management. Open source ecosystem, unlimited possibilities Provides a complete URDF model and exposes low-level interfaces for joint motors (including queryable position, velocity, acceleration, and current), facilitating kinematic and dynamic simulation modeling (ROS2, Isaac Sim, and MuJoCo). Over 90 standard control interface libraries (Python and C++) are available, covering status query and joint and Cartesian motion control. This is developer-friendly and efficiently enables secondary development. Infusion of \"soul\" into large models Supports integration with large multimodal models (such as DeepSeek and ChatGPT) to enable intelligent grasping using voice commands and visual recognition, making interaction more intuitive. Supports integration with large embodied intelligence models (such as Lerobot) to enable autonomous motion strategy learning and deployment, exploring the frontiers of intelligent agents. Cool App Suite Provides three out-of-the-box solutions: 3D visual disordered sorting, high-precision writing and painting, and mobile composite robots, allowing you to quickly build teaching/experimental/display scenarios. 2. Product Application 2.1 Client Educators and students It is suitable for course teaching, experimental training and skills competitions in robotics engineering, artificial intelligence, automation control, mechatronics and other majors in colleges and vocational schools, providing teachers and students with an ideal platform from theory to practice. Researchers and developers It provides a stable hardware platform and deep software open interfaces for scientific research institutes, corporate R&D departments and a large number of robotics enthusiasts to assist in algorithm verification, prototype development and cutting-edge technology exploration. Commercial and industrial users It is suitable for interactive product display in commercial showrooms, small-batch precision production in light industrial environments, sample sorting, quality inspection and other tasks, providing efficient and reliable automation solutions. 2.2 Application Scenario user group Core application scenarios (out-of-the-box) Expand application scenarios (unlimited possibilities) Teachers and students in the field of education - Basic teaching of robotics: mechanical structure, kinematics, and trajectory planning principle experiments.- Drag-and-drop programming: manual craftsmanship imitation, action recording and reproduction.- Introduction to graphical programming: Use Blockly for basic training in logical thinking and programming. - Advanced algorithm development: Research on machine vision, path planning, force control and other algorithms based on Python/C++/ROS2.- Artificial intelligence integration: Develop AI comprehensive application projects such as voice control and intelligent visual recognition and grasping. Makers and technology developers - Rapid Prototyping (PoC): Verify the feasibility of automated processes or gripping solutions.- High-precision simulation: Provides accurate URDF models and seamlessly integrates with simulation environments such as Isaac Sim and MuJoCo. - Exploration of cutting-edge fields: As a physical platform, it is used for research on cutting-edge topics such as embodied intelligence, reinforcement learning, and human-machine collaboration.- Composite system development: Integrate with AGV/AMR mobile chassis to build mobile manipulation robots. Commercial demonstrations and light industry - Automated commercial display: 24/7 automated product display and fun interaction with the audience.- Precision operations: high-precision writing and drawing, circuit board point detection, and sample sorting.- 3D visual sorting: Combined with 3D cameras, it can realize the grasping and sorting of disordered workpieces in cluttered environments. - Production line automation integration: Communicate with PLCs via Modbus/TCP/IP and other protocols, and integrate into small production lines to perform tasks such as loading and unloading, and precision assembly.- Laboratory automation: Replace manual labor to perform repetitive experimental operations, such as sample pipetting and culture dish transportation. 3. Supported Extension Development The mycobot series of robotic arms are extremely valuable in the fields of education and scientific research, especially in Python and ROS (Robot Operating System), two widely used development environments. These environments provide strong support, allowing the mycobot series of products to be widely used in machine learning, artificial intelligence research, complex motion control, and visual processing tasks. At the same time, with dozens of accessories such as adaptive grippers, camera flanges, suction pumps, etc., you can give full play to myCobot's creative ideas. Python The robot supports Python and has a complete Python API library. The robot's joint angles, coordinates, grippers, etc. can be controlled through Python. ROS The myCobot Pro 450 supports ROS 2 and the RVIZ2 simulation environment. It allows users to display the robot arm and collect robot status information in real time, making it suitable for ROS beginners and educational purposes. Hardware interface Including IO, USB, etc., to facilitate the connection of various sensors and actuators. Software library Provides a wealth of open source libraries and APIs to simplify the development process. System compatibility Compatible with Windows, Linux, MacOS, and adaptable to a variety of development environments. C++ Using the C++ language, you can freely develop (coordinate control, angle control, IO control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. myBlockly It is both a graphical programming software and a visualization tool. Users can drag and drop modules to create programs. This process is very similar to building blocks, which is convenient, fast and easy to use. 4. Purchase Address If you are interested in purchasing this device, please click on the link below Taobao：https://shop504055678.taobao.comShopify：https://shop.elephantrobotics.com/AliExpress：https://elephantrobotics.aliexpress.com/store/1101941423 ← Previous Chapter | Next Chapter→ "},"1-ProductInformation/2.ProductParameter/2-ProductParameters.html":{"url":"1-ProductInformation/2.ProductParameter/2-ProductParameters.html","title":"2. ProductParameters","keywords":"","body":"Robot Parameters In the first chapter, we discussed the selling points of the product and its design concept, providing you with a panoramic perspective of the high-level understanding of the product. Now, let's move on to the second chapter - Robot Parameters. This chapter will be the key to your understanding of the product's technical details. A detailed understanding of these technical parameters will not only help you fully realize the advancement and practicality of our products, but also ensure that you can use these technologies more effectively to meet your specific needs. 1. Robot Specifications Index Parameters Name Full harmonic collaborative robotic arm Model myCobot Pro 450 Degrees of Freedom 6 Payload 1 Kg Working Radius 450mm Repeatability ±0.1mm Weight Power Input 24V，9.2A Operating Temperature 0-45℃ Communication TCP/IP-SocketMODBUSEthernet IP 2. Structural Dimension Parameters ！This chapter uses millimeters as distance units and degrees as angle units. 2.1 Product Dimensions And Working Space 2.2 Joint Range Of Motion Hardware joint range of motion Joints Range J1 -165 ~ +165 J2 -117 ~ +117 J3 -157 ~ +157 J4 -165 ~ +165 J5 -165 ~ +165 J6 -168 ~ +168 Software joint range of motion Joints Range J1 -165 ~ +165 J2 -120 ~ +120 J3 -158 ~ +158 J4 -165 ~ +165 J5 -165 ~ +165 J6 -175 ~ +175 2.3 Hole Installation The robot base is mounted with flanges. The base is compatible with both LEGO technology and M4 screw installation. The robot end is equipped with a flange, and the end of the robotic arm is compatible with both LEGO technology holes and screw thread holes. 3. Electrical Characteristic Parameters 3.1 Electrical Interface Of The Robotic Arm Base 3.1.1 Base Introduction Base front view： ① RJ45：Dual network ports, used for connecting the device to the Internet or other network devices. ② USB3：High-speed USB interface for connecting to computers or peripheral devices. ③ RS485：Industrial serial communication, connecting PLC, sensors, etc. ④ CAN：CAN bus communication, connecting drives, I/O modules, etc. ⑤ Function IO: digital signal input/output. ⑥ Power switch: Press and hold to turn on the power, press and hold again to turn off the power. ⑦ 24V power supply: Connect the power adapter. ⑧ Emergency stop interface: Connect an external emergency stop button to cut off the power supply in an emergency to ensure safety. 3.1.2 Base Interface Description The definition of each interface is shown in the following table: Label Signal Name Type Function 2 1-12 I/O 24V 3.2 Electrical Interface At The End Of The Robotic Arm 3.2.1 Introduction To The End Of The Robotic Arm Side View Of The End Of The Robotic Arm: Number Interface Definition Function 12 M8 aviation socket End-of-line tool IO interface 24V/2A output, supports short-circuit, reverse polarity, lightning strike, overcurrent, and overvoltage protection M8 aviation socket RS485 interface Supports configurable baud rates of 9600 and 115200 3.2.2 Robotic Arm End Interface Description The definition of each interface is shown in the following table: The definitions of the various tool I/O ports are shown in the table below. Note that the tool I/O output is PNP type and the input is NPN type. The wiring method is the same as the bottom output interface. Number Signal Explanation Matching M8 line color 1 GND DC24V negative pole white 2 OUT1 Tool output interface 1 brown 3 OUT2 Tool output interface 2 green 4 485A 485 standard interface A yellow 5 24V DC24V positive pole gray 6 IN1 Tool input interface 1 pink 7 IN2 Tool input interface 2 blue 8 485B 485 standard interface B purple 4. Cartesian Coordinate Parameters ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/":{"url":"2-BasicSettings/3.UserNotice/","title":"3. UserNotice","keywords":"","body":"User Notes This section is crucial for every user of this product and must be read carefully. It includes essential information on product use, transportation, storage, and maintenance to ensure safety and efficiency during operation. Additionally, it outlines liability for product failure or damage resulting from non-compliance with these guidelines. The User Notice is divided into subsections, each providing detailed guidance on different topics: Chapter Summary 3.1-Safety Information Includes liability, safety warning signs, general safety rules, personal safety, and emergency response. 3.2-Transportation and Storage Describes packaging, transport, and long-term storage requirements, along with liability. 3.3-Maintenance and Care Offers guidance on routine maintenance to extend product lifespan. 3.4-FAQs and Solutions Provides a navigable guide for quickly resolving common issues. By thoroughly reading this section, users will better understand how to use the product safely and efficiently, maximizing performance and lifespan. If you have already read all the content in this chapter, please proceed to the next chapter. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.1-SafetyInstruction.html":{"url":"2-BasicSettings/3.UserNotice/3.1-SafetyInstruction.html","title":"3.1 SafetyInstruction","keywords":"","body":"Safety Instructions 1. Introduction This chapter details general safety information for personnel who perform installation, maintenance and repair work on the Elephant Robot. Please fully read and understand the contents and precautions of this chapter before handling, installing and using it. 2. Hazard Identification The safety of collaborative robots is based on the premise of correctly configuring and using the robots. Moreover, even if all safety instructions are followed, injuries or damage to the operator may still occur. Therefore, it is very important to understand the safety hazards of robot use, which is conducive to preventing them before they happen. Tables 1-1 to 3 below are common safety hazards that may exist when using robots: Table 1-1 Dangerous safety hazards 1 Personal injury or robot damage caused by incorrect operation during robot handling. 2 Failure to fix the robot as required, such as lack of screws or screws not tightened, insufficient base locking capacity to stably support the robot for high-speed movement, etc., causing the robot to fall over, resulting in personal injury or robot damage. 3 Failure to correctly configure the robot's safety functions, or insufficient installation of safety protection tools, etc., causing the robot's safety functions to fail to function, thus causing danger. Table 1-2 Warning-level safety hazards 1 Do not stay in the robot's motion range when debugging the program. Improper safety configuration may not be able to avoid collisions that may cause personal injury. 2 The connection between the robot and other equipment may cause new hazards, and a comprehensive risk assessment needs to be re-performed. 3 Scratches and punctures caused by sharp surfaces such as other equipment or the robot's end effector in the working environment. 4 The robot is a precision machine and trampling may cause damage to the robot. 5 Failure to clamp in place or not removing the clamped object before turning off the robot's power or air source (not confirming whether the end effector is secure and the clamped object falls due to power loss) may cause dangers, such as damage to the end effector and injuries to people. 6 The robot may move unexpectedly. Do not stand under any axis of the robot under any circumstances! 7 The robot is a precision machine. If it is not placed stably during transportation, it may cause vibration, which may cause damage to the robot's internal components. 8 Compared with ordinary mechanical equipment, the robot has more degrees of freedom and a larger range of motion. Failure to meet the range of motion may cause unexpected collisions. Table 1-3 Safety hazards that may cause electric shock 1 Using non-original cables may cause unknown dangers. 2 Electrical equipment in contact with liquid may cause leakage. 3 There may be a risk of electric shock when the electrical connection is incorrect. 4 Always turn off the power of the controller and related devices and unplug the power plug before replacing. If the work is carried out in the power-on state, it may cause electric shock or malfunction. 3. Safety Precautions The following safety rules should be followed when using the robot arm: The robot arm is a live device. Non-professionals are not allowed to change the circuit at will, otherwise it is easy to cause damage to the equipment or personal injury. When operating the robot arm, local laws and regulations should be strictly observed. The safety precautions and \"Danger\", \"Warning\" and \"Caution\" items described in the manual are only used as supplements to local safety regulations. Please use the robot arm within the specified environmental range. Exceeding the robot arm specifications and load conditions will shorten the product life or even damage the equipment. Personnel responsible for installing, operating and maintaining the myCobot robot arm must first undergo rigorous training, understand various safety precautions, and master the correct operation and maintenance methods before operating and maintaining the robot. Do not use this product in a humid environment for a long time. This product is a precision electronic component. Long-term operation in a humid environment will damage the device. Do not use this device in a high temperature environment. The outer surface of this device is made of photosensitive resin as raw material. Higher temperatures will damage the outer shell of the device and cause equipment failure. Highly corrosive cleaning is not suitable for cleaning the robot arm, and anodized parts are not suitable for immersion cleaning. Do not use this product without a base installed to avoid damage to the device or accidents. This product should be used in a fixed environment with no obstacles around. Do not use other power adapters for power supply. If the device is damaged due to the use of an adapter that does not meet the standards, it will not be covered by after-sales service. Do not disassemble, disassemble, or unscrew the screws or casing of the robot arm. If disassembled, warranty service cannot be provided. Personnel who have not received professional training are not allowed to repair faulty products or disassemble the robot arm without authorization. If the product fails, please contact myCobot technical support engineers in time. If the product is scrapped, please comply with relevant laws to properly dispose of industrial waste and protect the environment. Children must be monitored by someone during use, and the device must be turned off in time when the operation is completed. When the robot is in motion, do not put your hand into the range of motion of the robot arm to avoid injury. It is strictly forbidden to change or remove and modify the nameplate, instructions, icons and markings of the robot arm and related equipment. Please be careful during transportation and installation. Please place the robot gently and correctly in the direction of the arrow according to the instructions on the packaging box, otherwise it is easy to damage the machine. Do not burn other product drivers without authorization, or use unofficial recommended methods to burn firmware. If the device is damaged due to the user's personal burning of other firmware, it will not be covered by after-sales service. If you have any questions or suggestions about the contents of this manual, please log in to the official website of Elephant Robotics to submit relevant information: https://www.elephantrobotics.com Do not use the robot arm for the following purposes: Medical and life-critical applications. In an environment that may cause an explosion. Direct use without risk assessment. Use with insufficient safety function level. Use that does not meet the robot performance parameters. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.2-TransportandStorage.html":{"url":"2-BasicSettings/3.UserNotice/3.2-TransportandStorage.html","title":"3.2 TransportandStorage","keywords":"","body":"Transportation And Storage Packing And Packaging   When packing and packaging the robot product, please make sure to use packaging materials and boxes designed for it. These materials can provide sufficient cushioning and support to prevent impact and vibration during transportation. Be sure to check that all parts are properly fixed to avoid looseness and damage. For fragile or sensitive parts, additional anti-vibration protection materials should be used for reinforcement. Finally, make sure that the outside of the packaging box is marked with clear handling and warning labels to indicate the correct handling method and storage direction. Logistics And Transportation   During transportation, the robot product should be transported in the original packaging. During transportation, it should be ensured that the robot product is stable as a whole in the packaging box and protected by appropriate measures. During transportation and long-term storage, the ambient temperature should be maintained in the range of -20 to +55°C, and the humidity should be ≤95% without condensation.   Because the robot is a precision machine, the robot product should be handled with care when it is removed from the packaging. During transportation, if it is not placed stably, it may cause vibration and damage the internal parts of the robot. Equipment Storage   After transportation, the original packaging should be properly stored in a dry place, the ambient temperature should be kept within the range of -20 to +55°C, the humidity should be ≤95% and there should be no condensation, in preparation for future repackaging and transportation needs. Do not stack other items on the original packaging box of the robot arm to prevent deformation of the packaging box and damage to the robot arm. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.3-MaintenanceandCare.html":{"url":"2-BasicSettings/3.UserNotice/3.3-MaintenanceandCare.html","title":"3.3 MaintenanceandCare","keywords":"","body":"Maintenance And Care As a robot manufacturer, we value ensuring that our customers can properly and safely maintain and upgrade their robot equipment. To this end, we provide the following detailed maintenance and care guide, including common maintenance items and parts for repairing or upgrading hardware. Please read carefully: 1. Common Maintenance Items And Recommended Cycles Maintenance items Description Recommended cycle Visual inspection Inspect the robot for obvious damage, foreign material accumulation or wear. Daily Structural cleaning Clean the robot structural parts with a clean, dry cloth. Avoid moisture and aggressive cleaning agents. Daily Fastener inspection Inspect and tighten all bolts and connectors. Daily Lubrication Lubricate joints and moving parts with the lubricant recommended by the manufacturer. Every 3 months Cable and wiring inspection Inspect the cables and wiring to ensure that there is no damage or wear. Monthly Electrical connection check Ensure that all electrical connections are secure and free of corrosion or damage. Monthly Software update Check and update the control software and application. Every update Software data backup Regularly back up key software configuration and data. Quarterly Firmware update Regularly check and update the firmware to obtain the latest features and security patches. Every update Sensor and device check Check sensors and other key devices to ensure normal operation. Monthly Emergency stop function test Regularly test the emergency stop function to ensure its reliability. Monthly Environmental condition monitoring Monitor the temperature, humidity, dust, etc. of the working environment to ensure that it meets the operating specifications of the robot. Continuous monitoring Safety configuration review Regularly check and confirm the safety configuration of the robot, such as speed limit and working range settings. Monthly Preventive maintenance plan execution Perform regular inspections and maintenance according to the manufacturer's maintenance plan. By Manufacturer's Guide 2. Guide To Independently Changing Robot Hardware We understand that customers may have the need to upgrade or repair robot hardware by themselves. Before performing any upgrade operations, please be sure to read the relevant parameters of the product in detail and confirm with our official personnel whether such operations are allowed. Operations without official permission may cause product failure and are not covered by the warranty. Material Requirements Officially manufactured or recommended materials: All accessories and components required for repairs and upgrades must be officially manufactured or explicitly recommended by us. This includes but is not limited to electronic components, sensors, motors, connectors, and any other replaceable parts. Material Acquisition: Customers can purchase the required repair and upgrade materials through our official channels. This ensures the quality and compatibility of the accessories. Repair or Upgrade Process Customer Self-Repair: Customers are responsible for completing the repair work. We will provide detailed repair instructions and manuals to guide customers through the repair steps. Follow official instructions: Repair operations should strictly follow the official instructions provided by us. Any deviation from the official instructions may cause damage to the equipment. Liability and Warranty Policy Division of Responsibilities: Manufacturer: Provide official instructions for repairs and upgrades, officially manufactured or recommended materials, and handle problems caused by manufacturing defects. Customer: Responsible for completing repairs in accordance with official instructions and using official accessories. Warranty Policy: Warranty Valid: Warranty is valid only if the repair operation fully follows our instructions and uses official accessories. Warranty Void: If the customer does not follow the official instructions or uses unofficial accessories for repairs or upgrades, any damage caused will not be covered by the warranty. Notes Safety First: Before performing any repair or upgrade operations, please make sure to follow all safety guidelines, including powering off and using appropriate protective equipment. Technical Support: If you encounter problems during the repair process, it is recommended to stop the operation and contact our technical support team for assistance. We strongly recommend that customers strictly follow these guidelines to ensure the safe and effective operation of the robot equipment. Improper repair operations may cause damage to the equipment and affect the warranty status. For further guidance or support, please contact our professional technical team in a timely manner. If you have read all of this chapter, please continue to the next chapter. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4-FAQs.html":{"url":"2-BasicSettings/3.UserNotice/3.4-FAQs.html","title":"3.4 FAQs","keywords":"","body":"FAQ This section lists some frequently asked questions, covering both hardware and software aspects. 1 software problem 2 Hardware problem 3 other ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.1-software.html":{"url":"2-BasicSettings/3.UserNotice/3.4.1-software.html","title":"3.4.1 Software","keywords":"","body":"Software Issues 1. myBlockly Related Issue 1: ​​When running myBlockly, I get the error message ModuleNotFoundError: No module named 'pymycobot' Solution: This is because the pymycobot library was not installed when setting up the Python environment. To install the pymycobot library, open Terminal (Win + R), enter pip install pymycobot --upgrade --user, and press Enter. You should see \"Successfully installed pymycobot.\" Issue 2: The robot arm is unresponsive because the sleep method module is not added Solution: The program that operates the robot arm takes a certain amount of time to complete. Therefore, after completing each movement, you need to connect a sleep module to allow the robot arm sufficient time before performing the next movement. (The required time depends on the specific situation and machine. The default setting for the robot arm is to sleep for at least 0.5 seconds when running myBlockly.) Otherwise, the robot arm will not be able to perform the desired movement. Issue 3: SSH cannot connect Solution: This situation is usually caused by a poor network cable connection. You can first unplug the network cable on the PC and then reconnect it. When the control panel detects a connection (usually Ethernet)，then open the Windows Command Prompt and use the ping command to check. When the output information is normal, try the SSH connection. If the above steps fail to solve the problem, try restarting the machine and then operate again. Issue 4: Can't open after entering the IP address? Solution: Make sure the PC and the robot arm are on the same local area network. Try changing the browser (Chrome or Edge is recommended). Refresh the cache (Ctrl+F5). 2. ROS1 Related 2.1 Environment-Related Issues Issue 1: Running roslaunch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/catkin_ws catkin_make source devel/setup.bash 2.2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 2.3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 2.4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the roslaunch command is complete In the terminal, enter: rosparam list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz] rviz at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control 3. ROS2 Related 3.1 Environment-Related Issues Issue 1: Running ros2 launch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/colcon_ws colcon build source install/setup.bash 3.2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 3.3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 3.4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the ros2 launch command is complete In the terminal, enter: ros2 param list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz2-2] rviz2-2 at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.2-hardware.html":{"url":"2-BasicSettings/3.UserNotice/3.4.2-hardware.html","title":"3.4.2 Hardware","keywords":"","body":"Hardware Issues Under preparation ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.3-other.html":{"url":"2-BasicSettings/3.UserNotice/3.4.3-other.html","title":"3.4.3 Other","keywords":"","body":"Other Issue Q: How to reset to factory settings when the machine is abnormal? Restoring to factory settings mainly involves resetting the image, PID, and zero position. The following is the reset method: About resetting the image: When resetting the image, all contents in the original system will be cleared. If there are important files, please save them in advance. For the method of resetting the image, please refer to the system usage chapter of gitbook About resetting pid: Generally, when the machine has severe joint shaking, abnormal joint movement speed, and joints curled up, the pid can be reset. For the reset method, refer to: https://drive.google.com/file/d/1UWhaaSTuwLFImuEGY1J2tvgxTQDwWxK_/view?usp=sharing About resetting zero position: Generally, when the machine has an incorrect zero position or the joint limit is abnormal, the zero position can be recalibrated. For the reset method, refer to: https://drive.google.com/file/d/1XtKH-ykKWPH0q9Z_YHwzkgwNKRhstHhi/view?usp=sharing Q: Where is the download path for the urdf file? A: Please refer to the following path. The urdf of all mycobot models is in this path: https://github.com/elephantrobotics/mycobot_ros/tree/noetic/mycobot_description/urdf Q: How long is the command transmission delay when controlling the motor through the robot's controller via serial port or socket communication? Is there a communication timing diagram? How about real-time performance? There is no delay test data for serial or socket communication. According to the feedback from our development and use, the real-time performance is still quite high and there will be no lag. Q: What is the base coordinate system of the mycobot pro 450 robot? Q: Are the joints of 450 controlled by the serial bus? A: Yes Q: Is there more explanation about the understanding of coordinates? A: The API for controlling coordinate movement is send_coords([x,y,z,rx,ry,rz], speed) x, y, z coordinates: Control the position of the end effector of the robot in space. Changing these coordinate values ​​will move the robot to different spatial positions, thereby achieving positioning in three-dimensional space. rx, ry, rz attitude angles: Control the attitude or orientation of the end effector of the robot. These values ​​are usually given in the form of Euler angles, describing the rotation of the end effector of the robot relative to the base coordinate system, and the order of Euler angles is zyx. Changing these values ​​will rotate the end effector of the robot to different angles or directions. For example: When you adjust +X, this means that the position of the end effector of the current robot arm moves a certain distance along the positive direction of the X axis of the current end effector. This action will cause the robot to move in a certain direction as a whole. And when you adjust RX, this means that the attitude of the end effector of the current robot arm rotates a certain angle around the X axis of the current end effector. This action will cause the robot to rotate as a whole and the direction of the end effector will change. In general, the adjustment of +X and RX will directly affect the motion state of the robot arm. +X controls the movement of the position, while RX controls the change of attitude. If you want to see the changes more intuitively, we recommend that you use myblockly's serial control tool to adjust a parameter at a time and observe its changes in the coordinate system. Please note that when observing rx, ry, and rz, if you want to be more intuitive, please pay attention to adjusting x and ry when the J1 joint is 0, and adjusting y and rx when the joint is 90. You can refer to the coordinate system diagram below: Q: Is there more explanation about the Offset of the DH parameter? Is the Offset rotated around z? A: The DH parameter describes the geometric and kinematic relationship between adjacent links in the robot arm. In the DH parameter table, the Offset parameter indicates the effect of the previous link rotating around its z-axis on the position of the next link, that is, the offset when connecting two links. For the Offset parameter in the robot arm, it generally indicates the effect of the previous link rotating around its own z-axis on the position of the next link, rather than rotating around the z-axis of the next link. Therefore, Offset is not a rotation around z, but a displacement when connecting two links. Q: What is the voltage range of the 450 robot arm power supply? How much is the instantaneous current? A: 24V ，9.2A Q: If the servos of each axis are controlled and feedback is obtained, what is the shortest communication cycle? A: This needs to be determined according to the speed. The minimum response time is 50ms Q: Does the mycobot series machine have collision detection? A: 450 has algorithmic collision self-interference, which has been integrated into the API for setting joint angles and coordinates Q: How to deal with the VNC dragging jam? A: If the jam is caused by dragging any window in VNC, you can make some configurations according to the picture below. The options need to be consistent with the picture below. After successful setting, the problem of VNC disconnection caused by dragging the window will be solved. Q: When replacing the second joint of 450, I found that 4 screws were stripped. How to remove them? Regarding the replacement of joints, the 4 screws do not need to be removed. Please remove the large screw in the middle, then fix the J2 joint body back, and then use force to pull out the entire coupling. I recorded a video for you to refer to for specific operations Q: Is the joint torque information provided? A: Our machines only provide the overall information of the entire joint, and do not provide the internal torque, voltage and current of the servo and motor actuator. The overall parameters of the robot arm are disclosed, such as repeatability, power supply voltage, etc. Q: How do you understand the relationship between the two coordinates in the following figure? A: If you want to view the transformation relationship between the coordinate system named \"turtle1\" and the coordinate system named \"turtle2\", you can use this command. In layman's terms, when you run this command, it will tell you the position and direction information of an object (\"turtle1\") relative to another object (\"turtle2\"). Just like you can know the position of a city relative to another city on a map Q: The environment of ROS2 has been accidentally changed. Can I just delete the ROS and reinstall it myself? A: Regarding the issue of reinstalling ROS, we do not recommend users to reinstall it themselves, because the construction of the ROS environment is relatively complex and prone to errors. If you need to reset the ROS environment, we recommend users to re-write the system image. For specific methods, please refer to Development and Use Based on ROS2 Q: How to transfer files from the host to the virtual machine A: Set up a shared folder as shown below to transfer files from the PC to the virtual machine Q: What is the difference between API and serial port instructions to directly control joints? API provides a simplified and abstract interface to make development more efficient and easy, suitable for rapid development and integration. Serial port commands provide direct, low-level control, suitable for scenarios that require fine-tuning or development of custom functions, but are usually more complex to develop and debug. In general: Using serial port commands to directly control the robot arm is more flexible, but also more complex, requiring a deep understanding of the communication protocol; while using API control is simpler and more convenient, but may be limited by the functions and performance provided by the API. Q: Windows runs git commands and reports errors A: This is caused by not installing git. You need to install git first and then use git commands Q: What is the difference between MDI and JOG? A: MDI (Manual Data Input) is called the set value direct given operation mode. That is, after the upper controller directly sets the target position, speed, acceleration and deceleration, the axis automatically moves to the target position. MDI is also the most commonly used positioning function in practical applications. JOG moves continuously in a certain direction. Q: Overseas maintenance policy form Q: End zero position abnormality A: After using the adaptive gripper to grip objects for a long time, the gripper and end zero position abnormality will occur, and the gripper needs to be stationary. Q: What is forward kinematics and inverse kinematics? A: Forward kinematics refers to solving the position and posture of the robot's end effector (such as the gripper of the robot arm) in Cartesian space when the angles (or displacements) of each joint of the robot are known. It is implemented in the get_coords() API, but the specific algorithm is not public. Inverse kinematics is the opposite of forward kinematics. It refers to solving the angles (or displacements) of each joint of the robot when the position and posture of the robot's end effector in Cartesian space are known. write_coords(), send_coords() ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/":{"url":"2-BasicSettings/4.FirstTimeInstallation/","title":"4. FirstTimeInstallation","keywords":"","body":"First Installation And Use Thank you for choosing our product Before we begin, we would like to sincerely thank you for choosing our product. We are committed to providing you with an excellent user experience. First time use and problem handling This chapter will introduce in detail the initial use of the product after receiving it, and provide relevant information for solving problems to ensure that you have no worries during use. Jump to each section 4.1 Product Standard List 4.2 Product Unboxing Guide 4.3 Power-on Test Guide ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.1-ProductStandardList.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.1-ProductStandardList.html","title":"4.1 ProductStandardList","keywords":"","body":"Product Standard List 1. Product List Image Thank you for choosing the Elephant Robot myCobot 280 M5 robot arm. This chapter is designed to help you easily get started with Elephant Robot products and enjoy every wonderful moment brought by the product. 2. Product Standard List Comparison Table Serial Number Product 1 myCobot Pro 450 Robotic Arm 2 24V Power Adapter 3 Mounting Base Plate 4 Emergency Stop Switch 5 Fixed base plate G-clamp 6 M8 Air Plug Cable 7 Back head M6 screws 8 M5 Wrench 9 M2 Wrench 10 14-pin pluggable terminal blocks 11 3Pin pluggable terminal blocks 12 myGripper F100 13 Gigabit network cable 2m Note: After the packing box arrives, please confirm that the robot packaging is intact. If there is any damage, please contact the logistics company and the supplier in your area in time. After unpacking, please check the actual items in the box according to the item list. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.2-ProductUnboxingGuide.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.2-ProductUnboxingGuide.html","title":"4.2 ProductUnboxingGuide","keywords":"","body":"Product Unpacking Guide 1. Product Unpacking Graphic Guide Why do you need to follow the steps to disassemble the product In this section, we strongly recommend that you follow the specified steps to disassemble the product. This will not only help ensure that the product is not damaged during transportation, but also minimize the risk of unexpected failures. Please read the following graphic guide carefully to ensure the safety of your product during the unpacking process. 1 Check the packaging box for damage. If there is damage or missing accessories, please contact the logistics company and the supplier in your area in time. 2 Open the box and take out the product brochure, sponge packaging cover, myCobot robot arm, matching power supply, flat base and accessory bag. 3 Make sure each step is completed before proceeding to the next step to prevent unnecessary damage or omissions. Note: After taking out the product, please carefully check the appearance of each item. Please check the actual items in the box against the item list. 2. Product Unboxing Video Guide ！Product unboxing video is in production --> ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.3-PowerOnDetectionGuide.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.3-PowerOnDetectionGuide.html","title":"4.3 PowerOnDetectionGuide","keywords":"","body":"Power-on Inspection Guide 1. First Use Self-check-machine Joint Function Test Note: When starting the robotic arm, please be careful not to let the robotic arm be in a curled-up position or the joints touching each other. It is recommended that the robotic arm posture should be as shown in Figure 1 below when starting. Figures 2 and 3 are both incorrect starting postures: Figure 1 (Correct posture) Figure 2 (Wrong Posture) Figure 3 (Wrong Posture) 2. Structural Installation And Fixing During the movement of the robotic arm, if the bottom surface of myCobot is not connected to a table or other bottom surface, myCobot may still sway or overturn. Before starting assembly, please clean the workbench and prepare the necessary tools. Working Environment: No smaller than the robot's working range, with ample space for installation, use, maintenance, and repair. Tool List: Mycobot Pro 450 robot, accessory kit, user guide, etc. Place the robot arm flat on the table and place it forward to the edge of the table, and secure it with a G-clamp. After the structure is installed, the next step of power connection can be carried out. Note: myCobot Base Screw Connection The robot must be secured to a secure base for proper operation. Base weight requirements: Fixed or mobile. Please ensure the base has corresponding threaded holes before installation. The installation related tools are ready, such as screws, wrenches, etc. After confirming the above content, please move the robot to the base installation table, adjust the robot position, and align the robot base fixing holes with the holes on the base installation table. After aligning the holes, align the screws with the holes and tighten them. Note: When adjusting the robot position on the base installation table, please try to avoid pushing and pulling the robot directly on the base installation table to avoid scratches. When manually moving the robot, please try to avoid applying external force to the fragile parts of the robot body to avoid unnecessary damage to the robot. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/":{"url":"3-FunctionsAndApplications/5-BasicApplication/","title":"5. BasicFunctions","keywords":"","body":"First-time Use Guide For The Robot Arm Installation Method 1.Before you begin assembly, clean your work surface and gather the necessary tools. Working Environment: Place the robot horizontally on a table capable of supporting at least three times the robot's own weight and within the robot's working range, with ample space for installation, use, maintenance, and repair. Tool List: mycobot pro 450 robot, accessory kit, user guide, etc. 2.Place the robot arm flat on the table and position it towards the edge of the table, securing it with a G-clamp. 3.After the structure is installed, the next step of power connection can be carried out. Note: When adjusting the robot's position on the base mounting platform, do not push or pull the robot directly on the base mounting platform to avoid scratches. When manually moving the robot, do not apply external force to vulnerable parts of the robot to avoid unnecessary damage. Connect Power Tools required: mycobot pro 450 robotic arm with a pre-installed base mounting platform, 24V DC power supply, emergency stop button, etc. Note: Please ensure that you have completed the above structural installation and secure the base of the robotic arm to the desktop to ensure safe operation. Please follow the steps below to connect the power adapter to the corresponding port on the robotic arm: Step 1： Connect a DC power supply (make sure to use the official adapter, or a DC power supply with a DC24V 15A or higher) to the corresponding DC round connector on the mycobot pro 450 robot arm. Connect the other end of the adapter to a 110-220V power outlet. Step 2： Connect the emergency stop button to the corresponding interface on the mycobot pro 450 robot arm. Step 3： Connect the corresponding LAN1 interface on the mycobot pro 450 robot arm to the host computer. Step 4： Press the power button to turn on the device. Note: The mycobot pro 450 must be powered by an external power supply to provide sufficient power. Rated voltage: 24V Rated current: 10A Connector type: DC24V MIC4 (NEUTRIK XLR NC4FX equivalent) Gripper Installation And Use You can refer to the following links: Clamp installation Gripper use ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.1-myStudioFirstUse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-myStudioFirstUse.html","title":"5.1 MyStudioFirstUse","keywords":"","body":"What is myStudio Pro? myStudio Pro is a one-stop robot programming and control software that supports visual programming interaction, quick motion control, drag-based tutorials, and robot status query and configuration. myStudio Pro includes the myBlockly module. myBlockly is similar in function and design to MIT's children's programming language, Scratch. With myBlockly, users can construct code logic by dragging blocks, much like building blocks. From a user's perspective, myBlockly is a simple and easy-to-use visual code generation tool. From a developer's perspective, myBlockly is a text box containing user-entered code. Generating code in the text box is similar to dragging code into myBlockly in myStudio Pro. myStudio Pro supports the following operating systems ： Windows macOS Linux arm64 myStudio Pro supports the following modern browsers : Chrome Edge Safari ... Preparations Before Using myStudio Pro Hardware configuration Before using myStudio Pro, please make sure the machine is powered on. The following are the steps on how to start a server program (taking the Windows operating system as an example) : Static IP Configuration First, you need to prepare a functioning network cable. Connect one end of the cable to the network port of the machine base and the other end to the network port of your PC device. After the network cable is connected, it is necessary to manually configure the machine's \"static IP\" for the subsequent \"ssh connection\". The configuration steps are as follows: Open the Control panel, select Network and Internet, and then click View network status and tasks. At this point, enter the Network and Sharing Center panel, select Change adapter settings from the left menu bar, and click to open the Network Connections panel. Select \"Ethernet\" and right-click on the Properties panel. After it opens successfully, left-click on \"Internet Protocol Version 4 (TCP/IPv4)\", and finally click the Properties button underground Go to the Properties panel, click on 'Use the following IP address:' with the mouse, and configure the static IP address '192.168.0.x' and the Subnet mask '255.255.255.0'. Finally, click \"OK\" and close the corresponding configuration panel. To verify whether the static IP configuration is successful, press the 'Win+R' key combination to bring up the run window. Then, in the run window, type 'cmd' to open the 'Windows Command Prompt', type 'ping 192.168.0.232' and press the Enter key. If the following content is output, it indicates that the static IP configuration is successful. And the network cable connection is normal. Start The Server Program You can log in to the machine system via sshconnection to perform operations and control. This chapter takes the MobaXterm graphical tool as an example for operation. Open the application, click on Session in the upper left corner to pop up the panel, then select SSH to connect and enter the corresponding 'Remote host'. After entering, click OK. After a successful connection, the panel requires you to enter your \"username\" and \"password\", both of which are set to \"root\" by default, and press Enter to log in to the system. The MyCobotPro 450 server program is by default in the following path /root/MyCobot450/bin directory. Then use the command View Current directory Files to check if there is a corresponding 'executable file'. The name of the executable file is generally MyCobotPro. cd /root/MyCobot450/bin ls If the server file is executed and the terminal does not report an error message and outputs the following information, the file is successfully run. ./MyCobotPro Of course, you can also log in using the 'cmd' panel to operate. The specific operation steps are as follows (taking the Windows system as an example) : Use 'win + r' to open the 'cmd' panel and enter the following command. Enter ssh-keygen-R 192.168.0.232 Enter ssh root@192.168.0.232 Then enter the login password 'root' Next, you can run the server program by following the above steps. Software Configuration Before using myStudio Pro, please make sure that a browser, such as modern browsers like Chrome/Edge/Safari, has been installed on your computer. myStudio Pro Access myStudio Pro is a Web application that does not require installation and can be used in a browser via IP. In the ssh connection terminal, enter the command ifconfig to view, configure and manage network interface parameters, and confirm the IP. ifconfig Then enter this IP And port number (default deployment to port 8000) into the URL address of the browser. Note: the http protocol needs to be added. The complete address is as follows; http://: When the browser renders the page, it indicates successful access to myStudio Pro. ← Previous page | Next page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-install_uninstall.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-install_uninstall.html","title":"5.2 InstallUninstall","keywords":"","body":"Download And Install myStudio Pro Download myStudio Pro does not require downloading or installation. You only need to connect your PC and the machine to the same network segment or use a network cable to access it through the browser. Install Since myStudio Pro is a web application, traditional installation is not required. You must confirm the following: The robotic arm system is running properly and the web service is enabled. The correct access IP and port are obtained. Use a modern browser such as Chrome, Edge, or Safari to access the system. It is recommended to use the latest version of the browser for the best compatibility and performance experience Renew The browser will automatically load the latest web front-end page when accessing it. If the page doesn't update, try clearing the cache and refreshing (shortcut: Ctrl + F5). Uninstall Since the system is a web application, there is no client-side uninstallation step. If you no longer need to use it, simply stop the robotic arm system's web service or delete the relevant bookmarks/cache in your browser. Access method Ensure the device and the robotic arm are on the same local area network. Enter the following in the browser address bar: http://: Once the page is loaded successfully, you can use the system without installing an additional client. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.3-interface_description.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-interface_description.html","title":"5.3 InterfaceDescription","keywords":"","body":"myStudio Pro Interface Display And Basic Function Usage Open the software, the main interface is as shown below The interface is divided into two areas: Return to Zero Function Implementation Return To Zero This button controls all joints of the robot to return to their zero position. Note: This button requires a successful communication connection with the robot. Pressing and holding the left mouse button on this button initiates the robot's home return command. Pressing and releasing the left mouse button stops the home return command. After the home return is complete, a pop-up window will appear indicating the completion. Functionality Select the features you want to use here. These features are as follows: Blockly Graphical Programming Quick Move Firmware and Applications Settings myBlockly myBlockly is a fully visual, modular programming interface, a graphical programming language suitable for beginners to familiarize themselves with programming. Users can develop applications by dragging and dropping puzzle pieces, creating both simple and complex functions. It supports saving and loading graphical code, single-stepping debugging, and executing specific blocks. Note: To use myBlockly, you must first connect to a device. This is a clickable button. Clicking it will redirect to the myBlockly graphical programming interface Open File This is a clickable button that automatically loads Blockly blocks by importing a JSON file. After clicking the left button of the mouse, a pop-up window will pop up where you can select a file. Select the JSON file saved by blockly to load the file, open myBlockly, and automatically load the corresponding building block in the programming interface. New File This button has the same function as myBlockly\". Quickly Load A Previously Saved Blockly File If you have used myBlockly to program and saved Blockly files, the saved file names and save times will be displayed as shown below. A maximum of four files will be displayed. If more than four files are saved, only the most recent four will be displayed. Left-clicking will open myBlockly and automatically load the selected Blockly file. Common Tools Quick Move Function: Provides quick control of robot I/O, joint angles, and coordinates QuickMove Feature Details Firmware And Applications Function: Provides updates and upgrades for the robot's embedded firmware, product manuals, official videos, an official GitHub repository, and feedback. Firmware and Applications Function Details Settings Function: Displays and modifies basic application and robot information. Setting Function Details ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.4-Q&A.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.4-Q&A.html","title":"5.4 Q&A","keywords":"","body":"Q&A This chapter lists common issues when using myBlockly to control a robotic arm for your reference. Q1: ​​When running myBlockly, I get the error message ModuleNotFoundError: No module named 'pymycobot' A: This is because the pymycobot library was not installed when setting up the Python environment. To install the pymycobot library, open Terminal (Win + R), enter pip install pymycobot --upgrade --user, and press Enter. You should see \"Successfully installed pymycobot.\" Q2: The robot arm is unresponsive because the sleep method module is not added A: The program that operates the robot arm takes a certain amount of time to complete. Therefore, after completing each movement, you need to connect a sleep module to allow the robot arm sufficient time before performing the next movement. (The required time depends on the specific situation and machine. The default setting for the robot arm is to sleep for at least 0.5 seconds when running myBlockly.) Otherwise, the robot arm will not be able to perform the desired movement. Q3: SSH cannot connect A: This situation is usually caused by a poor network cable connection. You can first unplug the network cable on the PC and then reconnect it. When the control panel detects a connection (usually Ethernet)，then open the Windows Command Prompt and use the ping command to check. When the output information is normal, try the SSH connection. If the above steps fail to solve the problem, try restarting the machine and then operate again. Q4: Can't open after entering the IP address? A: Make sure the PC and the robot arm are on the same local area network. Try changing the browser (Chrome or Edge is recommended). Refresh the cache (Ctrl+F5). ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.1-blocklyFirstUse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.1-blocklyFirstUse.html","title":"5.5.1 BlocklyFirstUse","keywords":"","body":"First Time Use myStudio software has been configured in the machine system. You can use a PC to open a browser and access it through ip. After the homepage is loaded, the system will automatically establish a connection with the machine. You can access the Blockly programming page by clicking the Blockly icon or the New Document button. Of course, you can also load a saved workspace by clicking the Open File button (for information on saving a workspace, click here). Accessing the Blockly programming page by clicking the Blockly icon or the New Document button is equivalent to creating a new workspace. The blockly homepage is shown below: ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.2-interfaceDescription.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.2-interfaceDescription.html","title":"5.5.2 BlocklyInterfaceDescription","keywords":"","body":"Introduction To The Blockly Main Interface Serial Number Function Introduction 1 File: Load, save, and create new workspaces; 2 Quick Power On: Release/clamp the robot's joints; 3 Waypoint: Quickly create teach points and run; 4 Quick Move & Trajectory: Used to quickly control the robot's movement; 5 Return: Exit the Blockly main interface. 6 Single-Step Execution: Select a block and click this button to execute only the currently selected block. 7 Run Panel: Opens the Run panel, where you can run and debug your workspace code. 8 Pose: Opens the Pose page to view the real-time simulated motion of the 3D model. 9 Toolbox: Provides pre-built blocks for user use. 10 Workspace Calibration: Click this button to return the workspace to its original position. 11 Zoom in: Enlarges the workspace. 12 Zoom out: Reduces the workspace. 13 Trashcan: You can drag blocks from the workspace here to delete them, and you can also remove deleted blocks from here. 14 Workspace: You can drag blocks from the toolbox here to start programming. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.3-littleCase.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.3-littleCase.html","title":"5.5.3 LittleCase","keywords":"","body":"Small Case Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position Let's write a small example to introduce the basics of 'Blockly'. Example Description: Control a robotic arm to return to zero, then move a joint to a 20-degree position, and then return to zero. Step 1: First, click the Pose button to open the Pose view, where you can see the current pose of the simulated robotic arm. 1: Toggle the Posture Panel: Click to display it if it's hidden, or to hide it if it's hidden. 2: The robotic arm simulation model simulates movement in real time based on the current real-world angle. Step 2: Start programming Open the toolbox's first-level category Motion Control, select the second-level category Angle & Coordinate, and drag the Set Full Angle block to the workspace. This block is used to control the movement of each joint of the robotic arm to a given angle, and the default movement speed is 20. Open the toolbox's first-level category Basic Programming, select the second-level category Time, drag the Sleep block to the workspace, and set the sleep time to 3 seconds. The 3-second sleep time means the program waits for 3 seconds before continuing. Why does it wait for 3 seconds? Because the team needs to ensure that the robot arm completes the first command action before executing subsequent actions. Copy the Set Full Angle block and change the Joint 1 angle to 20 degrees: Click and select the Set Full Angle block in the workspace; Press Ctrl + C on your keyboard to copy the Set Full Angle block; Press Ctrl + V on your keyboard to paste the Set Full Angle block; Change the Joint 1 value of the new block to 20 degrees; Drag this block to connect it to the Sleep block; Similar to the above operation, copy the Sleep block and set the sleep time to 3 seconds; Duplicate the first Set Full Angle block in the workspace again; The complete code is as follows: This code means: Control the robot arm to return to zero position Wait 3 seconds (for the machine to return to zero position) Move one joint (J1) to the 20-degree position Wait 3 seconds Control the robot arm to return to zero position Finally, click the Run Panel button. After the panel opens, click the Run button to start executing the code. After the code is finished running, click the panel X to close the panel. Step 3: Save and load files (or save and load workspaces) blockly supports saving and loading of workspaces. Click the File button, a drop-down menu will appear. Click the Save button, a file naming modal window will be displayed, enter a name and click OK to save. The saved result will be displayed as a message prompt in the lower left corner. Step 4: Create a new workspace (this will clear all code in the workspace) Click the File button. A drop-down menu will appear. Click the New Workspace button. A prompt will appear. Click the Confirm button. New workspace completed Step 5: Load the workspace file we saved previously. Click the File button to display a drop-down menu. Click the Open File button in this menu to display a list of saved files. Select the workspace file you want to load and click the Open button to load it. Click the Delete button to delete the file. Loading completed ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.4-autofill.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.4-autofill.html","title":"5.5.4 Autofill","keywords":"","body":"Quickly Fill Data Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position This chapter introduces the Quick Fill feature in building blocks. When a building block has too many data items, filling them in one by one becomes cumbersome. Therefore, we can use the Quick Fill feature for blocks with too many data items. Currently, the following building blocks support Quick Fill: How To Use Quick Fill Using the Set Full Angle block as an example, first select the block, then click the Quick Fill button within the block. When the following prompt box appears on the page, the entry is successful. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.5-quickMove.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.5-quickMove.html","title":"5.5.5 QuickMove","keywords":"","body":"Quick Move Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position What is Quick Move? Simply put, it allows you to quickly control robot movement with mouse clicks, without programming. Note: There are two Quick Move control panels in myStudio, and their functions are similar. Step 1: Click the Quick Move button to open the Quick Move panel and wait for the robot data to be returned. If all data is zero, please check that the robotic arm is connected and functioning properly. Step 2: Try clicking the - / + buttons to control different joints of the robotic arm. Supports single-point, long-press continuous movement, and direct modification of angles and coordinates by pressing Enter for control. Step 3: Control the coordinates. First, move Joint 3 to approximately -90 degrees, as shown below. Then, click the - / + buttons for different coordinate axes to control the coordinates. For other functions, please refer to Quick Move ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.6-useCoords.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.6-useCoords.html","title":"5.5.6 UseCoords","keywords":"","body":"Learning To Use Coordinate Control Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position This chapter describes how to use coordinates to control the robotic arm. Mainly Covered APIs: Set Coordinates Prototype: send_coords(values,speed) Interface Description: Set multiple coordinates for the robotic arm Parameters: values: [X, Y, Z, RX, RY, RZ] speed: Speed, range: 1-100 Small Case Before using coordinate movement for the first time, some steps are required: Return the robotic arm to its zero position. For details, refer to Controlling the Robotic Arm to Return to Zero Set the initial pose for the robotic arm's coordinate movement (J3 of the robot must be parallel to the ground) As shown in the code below: Open the Run Panel and run the code. Coordinate Movement Drag a Set Coordinates block onto the workspace and click the Quick Fill button to fill in the data. Change the Z axis data to 300. The complete code is as follows: Execute the code and observe the robot arm moving up and down. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.7-singleStep.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.7-singleStep.html","title":"5.5.7 SingleStep","keywords":"","body":"Single-Step Execution Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position Single-step execution refers to executing a single block. When there are many blocks in the workspace, I want to execute just one to see the effect. This is where single-step execution comes in handy. The Single-Step button is disabled by default and unclickable. Step 1: Drag a few joint setting blocks into the workspace. Step 2: Select the Set Joint block and observe that the Single Step button is unlocked (its color becomes darker) Step 3: Click the Single Step button to open the Run panel. Click the Run button in the panel to start executing the code. Meanwhile, observe the changes in the robot arm's movement. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.8-program.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.8-program.html","title":"5.5.8 ProgramControl","keywords":"","body":"Program Control Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot server is running 3. Ensure the robot is at zero position This chapter introduces how to debug block code through the Run Panel and implement Pause, Resume, Single Step, and Stop of the program. Edit a program to control the movement of joint 1 of the robot arm Click the Run Panel button. When the Run Panel pops up, click Run All and then immediately click the Pause button. The program will pause after executing the first instruction mc.send_angle(1,0,20). The program is paused. The next instruction to be executed, time.sleep(3), appears. At this point: If you click the Resume button, the program will automatically continue execution. If you click the Step Into button, the program will execute the next instruction, mc.send_angle(1,-90,20). If you click the Stop button, the program will terminate. As for what to do next, it’s up to you! ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.9-waypoint.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.9-waypoint.html","title":"5.5.9 Waypoint","keywords":"","body":"Waypoints Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot is properly connected 3. The server is enabled This chapter describes how to use the waypoint function to control the robotic arm. Function Description: By entering multiple waypoint data (robot arm joints and coordinates), you can quickly control the robot arm to reach each waypoint. Open the waypoint list page, enable free movement, relax the robot arm, manually adjust the robot arm posture, and click Add Point to add a waypoint data. Serial Number Description 1 Click the \"Import\" button to import a previously saved JSON file containing waypoint information. 2 Click the \"Export\" button to export all waypoint information into a single JSON file. 3 Click the \"Delete\" button to delete all selected waypoints in the current waypoint list. 4 Click the \"Copy\" button to copy the coordinate information of all selected waypoints. 5 Click the \"Rename\" button to rename all selected waypoints. 6 Click the \"Overwrite Current Point\" button to quickly overwrite the coordinates of all selected waypoints with the current robot arm coordinates. 7 Check the \"List Data\" column. Functions 3-6 rely on this function. 8 Click the \"Run\" button, and the robot arm will move to the currently recorded waypoint. 9 Click the \"Free Move\" button, and a second confirmation window will pop up. Clicking \"Confirm\" will turn the button yellow. The robot arm will relax, and you can adjust its posture. 10 Click the \"Add Point\" button to enter the current robot arm coordinates. 11 Clicking the \"Generate Code\" button will quickly generate waypoint blocks into the Blockly program coding area. Select a waypoint block in blockly and add it to the program coding area. Alternatively, use the Generate Code button in the waypoint list to attach the generated waypoint block to the last block in the workspace. The waypoint block associates the data in the waypoint list. Select any waypoint in the waypoint list to associate. Add point information to the waypoint block. Select the new point and click the edit icon to open the new waypoint pop-up window. The custom waypoint name will be set by default. Use the + or - keys to adjust the waypoint information. Click the Save Waypoint button to add the waypoint data. In addition, the waypoint building block can modify the movement mode. Joint movement mode: movement is based on the joint information of the current waypoint. Linear movement mode: movement is based on the coordinate information of the current waypoint. No. Description 1 Select a waypoint. Click the edit icon to open the waypoint editing dialog. 2 Enter the waypoint name. 3 Display the robot's joint and coordinate data. Use the left (-) and right (+) buttons to adjust the waypoint data. 4 Click Save Waypoint to add or modify waypoint data. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.10-gripperUse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.10-gripperUse.html","title":"5.5.10 GripperUse","keywords":"","body":"Using The Gripper Before You Begin 1. Ensure the machine is powered on 2. Ensure the machine is properly connected 3. Enable the server This chapter describes how to use Blockly to control the Pro Force Gripper connected to a robotic arm. API Display We will use the following blocks. 1: Set Pro Force Control Gripper Angle: Sets the gripper to a specific state (open or closed) at a specified angle. Parameter Description: This block has two adjustable parameters: Gripper ID parameter: Default is 14 Gripper Angle parameter: Indicates the desired angle, with a range of 0 to 100. 2: Read Pro Force Control Gripper Angle: Reads the current gripper angle. This block has one adjustable parameter: Gripper ID parameter: Default is 14 Small Example The graphic code is as follows: Code execution results: Controls the Pro force-controlled gripper to a value of 80 degrees Waits for 3 seconds Controls the Pro force-controlled gripper to a value of 20 degrees Waits for 3 seconds Reads the current angle of the Pro force-controlled gripper Waits for 3 seconds Controls the Pro force-controlled gripper to a value of 0degrees Note: If you are unable to control the gripper from the example above, please ensure that your Pro Force Control Gripper is using the Modbus protocol. After completing this configuration, run the example code again. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.11-dragTeach.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.5-blockly/5.5.11-dragTeach.html","title":"5.5.11 DragTeach","keywords":"","body":"The Use Of Drag-and-drop Teaching Before You Begin 1. Ensure the robot is powered on 2. Ensure the robot is properly connected 3. The server is enabled This chapter introduces how to use the drag-and-drop teaching function in blockly. It refers to the movement of the operating arm along the direction of the human force under the traction of the operator (the traction end or a certain operating arm). API Display Case We will achieve such an effect: randomly drag the mechanical arm to perform some actions. After the dragging is completed, the mechanical arm will execute the actions just performed. It is equivalent to the recording and playback of trajectories. The complete code is as follows: Code explanation: Wait for 2 seconds Start recording and drag teaching points: After executing this block, the brake of the robotic arm joint is released, and the robotic arm can now be dragged Wait for 10 seconds (equivalent to recording for 10 seconds) Pause drag teaching: The joint brake of the mechanical arm is locked and it must not be pulled by hand Wait for 5 seconds Start drag teaching points: The robotic arm began to execute the trajectory just recorded Wait for 10 seconds (equivalent to playing the 10-second trajectory just recorded) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.6-quickmove/5.6.1-quickmovefirstuse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.6-quickmove/5.6.1-quickmovefirstuse.html","title":"5.6 QuickMoveFirstuse","keywords":"","body":"Quick Move Before You Begin 1.Ensure the machine is powered on 2.Ensure the machine is properly connected and communicating 3.Ensure the machine is in zero position 4.The machine server is enabled 1 Interface Introduction Serial Number Description 1 MyCobotPro450 3D simulation model 2 The bottom IO pin numbers 1-12 are input and belong to the security module detection items 3 The bottom IO pin numbers 1 to 12 are for output. You can click the switch button to set the output 4 Terminal IO pins 1 and 2, input 5 Terminal IO pins 1 and 2, output, used to control the Pro force-controlled gripper 6 Enable free movement mode 7 Exit the fast movement interface 8 Angle Control: Click the + or - buttons to control the joint angles of the robot arm. The values ​​represent the current joint angle information of the robot arm, and you can also directly modify the values ​​to control the joints. 9 Coordinate Control: Click the + or - buttons to control the coordinates of the robot arm. The values ​​represent the current coordinate posture information of the robot arm, and you can also directly modify the values ​​to control the coordinates. 10 Set the movement speed of the robot arm. The default is 10 mm/s. 11 Angle Step: The angle value to increase or decrease each time when adjusting the angle. 12 Coordinate Step: The coordinate value to increase or decrease each time when adjusting the coordinate posture. 2 Angle Control In the Angle Control area, click the + and - buttons to control the joint angles of the robotic arm. The values ​​represent the current joint angles of the robotic arm. You can also directly modify the values ​​to control the joints. 3 Coordinate Control Before using coordinate control, move Joint 3 to an angle of approximately -90 degrees. In the coordinate control area, click the + and - buttons to control the robot arm's coordinates. The values ​​represent the current robot arm's coordinate position information. You can also directly modify the values ​​to control the coordinates. 4 Free Movement By clicking the Free Move button, the free move mode is turned on. The interface button turns orange, indicating that the machine is in free move mode and can be dragged and moved. Note: After clicking, a secondary confirmation pop-up window will appear first to prevent the mechanical arm joint from loosening due to accidental clicking and causing a fall. Click the OK button to release the joint, and the machine can move freely. The button turns yellow: When the free movement button is yellow, clicking it again turns free movement mode off. 5 Keep Moving By long-pressing the + - buttons in the corresponding area, you can control the robot to move continuously at the specified Angle. Note: After holding down the + - buttons for 3 seconds each time, you need to release the buttons, hold them down again, and then continue the operation to keep moving. 6 IO Control 6.1 Base IO Set the output of the bottom IO pin numbers 1-12, and users can customize the control actuator. For example, the control grippers and suction pumps can be customized. Click the on/off button to make Settings. 6.2 END IO Set terminal IO pins 1-2 as output to control the Pro force-controlled gripper. Turn on the Pro force-controlled gripper by clicking the On/Off button. Turn off the Pro Force Control Gripper by clicking the Off On button. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.7-firmware/5.7.1-firmware_main.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.7-firmware/5.7.1-firmware_main.html","title":"5.7 Firmware_main","keywords":"","body":"Firmware And Applications 1 Interface Introduction The homepage is as follows: myCobotPro450 supports users to remotely upgrade and burn the latest version of the terminal firmware. The machine uses the latest version of the firmware by default when it leaves the factory. If a new version of the firmware is released later, you only need to keep the network connection open when using myStudio, and myStudio will automatically download the latest version of the firmware. 2 General Firmware Function Description: AtomMain Terminal Firmware Name Version Number The default is the latest released firmware version, but you can also select another version for flashing. Description This describes the firmware version, typically including update information for that version. Delete Delete button: This button is used to delete the specified firmware version stored locally. Click this button and a prompt will pop up, prompting you to confirm whether to delete the firmware. Click the Confirm button to confirm the deletion; click the \" Cancel \" button to cancel the deletion. When there is firmware that has not been downloaded or the firmware has been deleted, the \"Flash\" button will become the \"Download\" button, and the \"Delete\" button will disappear. Clicking \"Download\" will automatically download the firmware. After the download is complete, the Flash and Delete buttons will be restored. 3 Documentation Manual This function is a web page link. Clicking it will open the product's GitBook page in the current browser. 4 Video Tutorials This feature redirects to a webpage. Clicking it will open the official video account in your current browser. The English version will redirect to YouTube, while the Chinese version will redirect to Bilibili. The corresponding link will be accessed inline. 5 Github This function is a web redirect link. Clicking it will open the official Github website in your current browser. 6 Online Store This function is a web link. Clicking it will open the purchase interface for the corresponding product in the current browser. The Chinese version will redirect to Taobao, while the English version will redirect to [website name] and access the corresponding link in an embedded manner. 7 Contact Us If you have any questions or comments, please contact us here. Functional Description: Name Enter your nickname here. This is a required field. If you submit without filling it in, you will be prompted with a corresponding text. Email Enter your email address here. This is a required field. Enter your email address to facilitate further responses from our staff. If you submit without filling it in, you will be prompted with a corresponding text. Your Comments Enter your comments here. This is a required field. Enter your questions or thoughts. If you submit without filling it in, you will be prompted with a corresponding text. Upload Click this button to upload a file. You can upload up to three files, and each file must not exceed 50MB. Click and a window will pop up for you to select a file. If the file you selected is larger than 50MB, it will fail to open after clicking \"Open\" and a window will pop up to remind you that the file is too large. When the number of files you want to upload exceeds 3, a pop-up window will appear to remind you. Submit Click the Submit button to submit all your information. This step may take some time, so please be patient. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/5-BasicApplication/5.8-setting/5.8.1-setting_main.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.8-setting/5.8.1-setting_main.html","title":"5.8 Setting_main","keywords":"","body":"Settings 1 Interface Introduction Serial Number Function Description 1 General Settings Module, mainly for language settings 2 Limit Settings Module 3 Check Update Module 4 Initial Posture Module 5 Test Module 6 Language Selection Module 7 Save Settings Button 8 Exit Settings 2 General Settings Clicking the General icon will take you to the language settings page. You can choose between Chinese and English. After selecting the corresponding language, click the Save button. A second confirmation prompt window will appear. Click Confirm to successfully set the language. 3 Limit Settings Note: Limit parameter modification only supports the minimum and maximum joint angles. Other parameters cannot be modified. Click the Limit icon button to enter the joint limit settings page. The Limit Settings interface displays the parameters related to the current robot arm's joint limits and coordinate limits by default. The Parameter Lock button is in the locked state by default, and the button color is blue, indicating that the limit parameters cannot be modified. When the parameters are locked, click the Parameter Lock button and the button will turn gray, indicating that the parameters are unlocked, which means that the limit parameters can be modified (only the minimum and maximum angle values ​​can be modified). Click the Save button and define a file name according to the prompts in the pop-up window to save the parameters of the current limit page to a local file (json file) and set the joint limits of the robot arm. 4 Check For Updates Clicking the Update icon will take you to the Check Update Status page. The Update page primarily checks the Atom firmware version status of the robotic arm. If the robotic arm's Atom firmware is not the latest version, a prompt will appear indicating that a firmware update is required. 5 Initial Posture Click the Initial Posture icon to enter the Initial Posture page. Initial Pose Page: Displays the robot arm's initial pose model, joint angle information, and coordinate pose information. 6 Testing Click the Test button to enter the test page. Test page: mainly tests the communication connection, firmware, servo and other status of the robot arm. Click the Start Detection button to start the test. After the test is completed, click the Save Test Log button and follow the pop-up window to save the test results to a local log file. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/":{"url":"3-FunctionsAndApplications/6.developmentGuide/","title":"6. SoftwareDevelopmentGuide","keywords":"","body":"Chapter 6 Software Development Guide Usage Environment myCobot Pro 450 is developed and used based on PC. Since there is no built-in system in the robot arm, the robot arm and PC need to be combined during use. Please prepare the PC before use. Development Environment In order to meet the diverse application needs of robots in different scenarios, we have adapted the robot to multiple programming languages. So far, we have adapted the following mainstream programming languages, and we think you can use any of the following languages ​​for development. Please be sure to follow the instructions strictly. Any omitted steps may cause the corresponding language to fail to run successfully. I wish you a smooth use of the robot. 6.1 Python Our robot supports Python, and the development of the Python API library is also becoming more and more perfect. The robot's joint angles, coordinates, grippers and other aspects can be controlled by Python. 6.2 ROS1 ROS (Robot Operating System), as an open source robot operating system, provides unlimited possibilities for robot development and control. Our robot can be controlled in a modular way through ROS's rich control functions. Whether it is joint control, path planning or sensor feedback, ROS provides corresponding tools and libraries to make the control process more flexible and efficient. 6.3 ROS2 ROS 2 (Robot Operating System 2) is a flexible software framework designed for robot software development. Our robot can make application development more efficient and modular through a series of services and functions such as hardware abstraction, device drivers, library functions, visualization tools, messaging, and package management. 6.4 C++ C++ is the inheritance of C language. It can be used for both procedural programming in C language and object-based programming characterized by abstract data types. Using C++ language, you can freely develop (coordinate control, angle control, io control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. 6.5 Communication If you have a certain understanding of information theory, coding and robot communication functions, then you should understand that all communication originates from data transmission. In order to facilitate users to operate the robot, we have opened a communication protocol based on serial communication. You can use the serial assistant or encapsulate it into any programming language you are familiar with to control the robot. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/","title":"6.1 Python","keywords":"","body":"What is Python? Our products are very friendly to Python, and the development of Python API library is also improving day by day. Through Python, the robot's joint angles, coordinates, grippers and other aspects can be controlled. There are many options. If you want to control our robot arm through Python programming, you can learn this chapter. Python was designed by Guido van Rossum of the Netherlands Institute for Mathematical and Computer Science Research in the early 1990s as a replacement for a language called ABC. Python provides efficient high-level data structures and simple and effective object-oriented programming. Python syntax and dynamic typing, as well as the nature of interpreted languages, make it a programming language for writing scripts and rapidly developing applications on most platforms. With the continuous update of versions and the addition of new language functions, it is gradually used for the development of independent and large projects. Python interpreter is easy to extend, and can be extended with new functions and data types using C or C++ (or other languages ​​that can be called from C). Python can also be used as an extension language in customizable software. Python has a rich standard library that provides source code or machine code for all major system platforms. Python development and use guide You can use Python to develop our robot arm according to the following guidelines Environment construction API description Joint control Coordinate control IO control Gripper control Robot exception handling ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html","title":"6.1.1 EnvironmentConstruction","keywords":"","body":"Environment Setup pymycobot is a Python package for serial communication with myCobot, supporting Python3.5 and later versions. Before using pymycobot to control the robot arm, you need to build a Python environment. The following is a detailed description of Python download and installation. Linux System Install the pymycobot library in the console terminal: pip install pymycobot --upgrade --user Windows System Download And Install Python Applicable devices: myCobot Pro 450 Currently, there are two versions of Python, one is 2.x version and the other is 3.x version. These two versions are incompatible. As 3.x version is becoming more and more popular, our tutorial will take the latest 3.10.7 version as an example. Install Python Note: Before installing, please confirm whether your computer is 64-bit or 32-bit. Right-click My Computer and select Properties. As shown in the figure below, it is a 64-bit operating system, so select the 64-bit Python installation package. Python official download address: https://www.python.org/downloads/ Click the Downloads option to start downloading Python, click Add Python 3.10 to PATH, click Install Now to start installing Python The prompt \"Setup was successful\" appears, indicating that the installation is complete Run Python After successful installation, open the command prompt window (Win+R, enter cmd and press Enter), and type python. Two situations will occur. Situation 1: The prompt in the picture indicates that Python has been successfully installed. The prompt >>> indicates that we are already in the Python interactive environment. We can enter any Python code and get the execution result immediately after pressing Enter. Case 2: If the input is wrong (for example, enter pythonn), an error message will appear: Note: The error message is generally caused by not configuring the environment variables. You can refer to 1.3 Configure environment variables to modify the environment variables. Configure Environment Variables Since Windows will search for python.exe according to the path set by a Path environment variable, if it is not found, an error will be reported. Therefore, if you miss checking Add Python 3.10 to PATH during installation, you need to manually add the path where python.exe is located to Path, or reinstall Python and remember to check the Add Python 3.10 to PATH option. The following are the steps to manually add the path where python.exe is located. Right-click My Computer –> Select Properties –> Select Advanced System Settings –> Select Environment Variables in the lower right corner: Environment variables mainly include user variables and system variables. The environment variables that need to be set are in these two variables. As shown in the figure below: User variables are used to download programs that can be used in cmd commands. Write the absolute path of the program to the user variable and you can use it, as shown in the figure below: After completing the above steps, open the command prompt window (Win+R, then enter cmd, press Enter), type Python, and the prompt in the figure below indicates success: PyCharm Installation And Use PyCharm is a powerful Python editor with cross-platform capabilities. First, let's introduce the installation steps of PyCharm in Windows system. Download address: https://www.jetbrains.com/pycharm/download/#section=windows Download And Install After entering the website, we will see the following interface: Download the file according to the interface introduction. Professional means professional version, and Community means community version. It is recommended to install the community version because it is free to use. After downloading, start installing and click Next: Select the corresponding options according to your personal preferences, and then click Next: The following interface appears and continue to click Next: Click Finish to complete the installation: Create A Project After PyCharm is installed, enter the software and create the first program. Click the PyCharm icon on the desktop to enter PyCharm, as shown in the figure below, and click New Project: After clicking, find Interpreter, start setting the interpreter, and click Add Interpreter: Click New, find the python.exe storage location, and check the Inherit global site-package option: Set Location. Location is where the PyCharm project is stored. You can choose it according to your needs. Create a new PyCharm file. Right-click the document icon pointed by the arrow, click New, click Python File, and the new file is created successfully. Name Python File: After the file is successfully created, you will enter the following interface and you can write your own program Before Use Firmware burning. Firmware refers to the device \"driver\" stored inside the device. Only through firmware can the operating system implement the operation of a specific machine according to the standard device driver. Different versions of the robot arm need to burn different firmware (refer to the MyStudio chapter). pymycobot installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), and enter the following command: pip install pymycobot --upgrade --user The following words appear, indicating that the pymycobot package has been successfully installed Source code installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), enter the following command to install: git clone -b develop https://github.com/elephantrobotics/pymycobot.git #Where fills in your installation address, if not filled in, the current path is used by default cd /pymycobot #Enter the pymycobot folder of the download package #Run one of the following commands according to your python version # Install python2 setup.py install # or python3 setup.py install Simple Use Of Python After the above preparations are completed, start to control the robot arm through Python code. Here, the MyCobot Pro 450 version is used as an example for demonstration. First, open the PyCharm you installed, create a new Python file, enter the following code, and import our library: from pymycobot import Pro450Client Note: If you enter from pymycobot import Pro450Client, there is no red wavy line under the font, which proves that it has been successfully installed and can be used. If a red wavy line appears, you can refer to How ​​to install the API library , How ​​to call the API library. If you do not want to install the API library through the above command, you can download the project to your local computer through the following github. First, go to the project address: https://github.com/elephantrobotics/pymycobot. Then click the Code button on the right side of the webpage, and then click Download ZIP to download it locally. Put the pymycobot folder in the compressed package pymycobot file project into your python dependency library directory, and you can directly import and use it. Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Simple Demonstration import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_angles()) # Read all joint angles pro450.send_angle(1, 90, 50) # Control J1 joint movement to 90 degrees at a speed of 50 ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html","title":"6.1.2 APIDescription","keywords":"","body":"Pro 450 Python Socket API [toc] Preparing For Use Before using the Python API, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 API Usage Instructions API (Application Programming Interface), also known as Application Programming Interface functions, are predefined functions. When using the following function interfaces, please import our API library at the beginning by entering the following code, otherwise it will not run successfully: Note: Before use, please make sure that the MyCobot Pro 450 server is turned on and the PC and the robot are in the same network segment. # Example from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() !=1: mc.power_on() print(mc.get_angles()) 1. System Status get_system_version() function： get system version Return value： system version get_modified_version() function： Read the revision number, for internal use only Return value： Correction version number get_robot_type() function： Detection robot model Return value： Definition Rule: Actual machine model. For example, the MyCobot Pro 450 model is 4503 get_atom_version() function： Get the end version number Return value： End parameters(float) get_tool_modify_version() function： Read end correction version number Return value： end correction version 2. Overall Status power_on() Function: Starts the robot (power on) Return value: 1 - Power on successfully. 2 - Power on failed 0 - Power not on power_off() Function: Shuts down the robot (power off) Return value: 1 - Command received successfully. is_power_on() Function: Checks whether the robot is powered on Return value: 1: Power on successfully 0: Power not on 2: Power on failed is_init_calibration() function: Check if the robot is initialized for calibration Return value: bool: True if the robot is initialized for calibration, False otherwise get_fresh_mode() function: Query sports mode Return value: 0: Interpolation mode 1: Refresh mode set_fresh_mode() function: Set command refresh mode Parameters: 1: Always execute the latest command first. 0: Execute instructions sequentially in the form of a queue. get_debug_state() Function: Get the current robot's debug logging mode. Return value: int: Current debug logging state. 0: No debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: All logs set_debug_state(log_state) Function: Set the debug logging mode for the current robot. Parameters: log_state: int, debug log state (0 to 7) 0: Do not log any debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: Log all logs Return value: int 1 - Success 0 - Failure 1 - Error set_communication_mode(communication_mode, protocol_mode=None) Function: Sets the current robot communication mode. Parameters: communication_mode: int 0 - Socket communication mode 1 - 485 communication mode protocol_mode: int, protocol mode, optional, default: None 0: Custom protocol 1: Modbus protocol Return value: int 1 - Success 0 - Failure 1 - Error get_communication_mode() Function: Gets the current robot communication mode. Return value: communication_mode: int 0 - Socket communication mode 1 - 485 communication mode protocol_mode: int 0: Custom protocol 1: Modbus protocol 3.Robot Abnormal Control get_robot_status() function: Upper computer error security status Return value: 0 - Normal. other - Robot triggered collision detection servo_restore(joint_id) function：Clear joint abnormalities Parameters： joint_id: int. joint id 1 - 6, 254-All joints restored. get_comm_error_counts(joint_id) function：Read the number of communication exceptions Parameters： joint_id: int. joint id 1 - 6 get_error_information() Function: Read robot error information Return value: int 0: No error information 1-6: The corresponding joint exceeds the limit position. 32-36: Coordinate motion error. 32: No coordinate solution. Please check if the arm span is near the limit. 33: No adjacent solution for linear motion. 34: Velocity fusion error. 35: No adjacent solution for null space motion. 36: No solution for singular position. Please use joint control to leave the singular point. clear_error_information() Function: Clear robot error information over_limit_return_zero() Function: Return to zero for a joint exceeding the limit get_motors_run_err() Function: Read motor error information during robot motion Return value: list, a list of 6, all zeros, indicating normal operation 4.MDI Mode And Operation set_control_mode(mode) Function: Set the robot motion mode Parameter: mode: int, 0 to 1, default 0 0: Position mode 1: Torque mode get_control_mode() Function: Get the robot motion mode Return value: 0: Position mode 1: Torque mode get_angles() function: get the degree of all joints Return value: list a float list of all degree get_angle() function: Get single joint angle Parameters： joint_id (int): 1 ~ 6 Return value: float, single joint angle send_angle(id, degree, speed) function: send one degree of joint to robot arm Parameters: id: Joint id(genre.Angle), range int 1-6 degree: degree value(float) | Joint Id | range | | ---- | ---- | | 1 | -165 ~ 165 | | 2 | -120 ~ 120 | | 3 | -158 ~ 158 | | 4 | -165 ~ 165 | | 5 | -165 ~ 165 | | 6 | -175 ~ 175 | speed：the speed and range of the robotic arm's movement 1~100 send_angles(angles, speed) function： Send all angles to all joints of the robotic arm Parameters: angles: a list of degree value(List[float]), length 6 speed: (int) 1 ~ 100 get_coords() function: Obtain robot arm coordinates from a base based coordinate system Return value: a float list of coord:[x, y, z, rx, ry, rz] send_coord(id, coord, speed) function: send one coord to robot arm Parameters: id:send one coord to robot arm, 1-6 corresponds to [x, y, z, rx, ry, rz] coord: coord value(float) | Coord Id | range | | ---- | ---- | | x | -466 ~ 466 | | y | -466 ~ 466 | | z | -230 ~ 614 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | speed: (int) 1-100 send_coords(coords, speed, mode) function:: Send overall coordinates and posture to move the head of the robotic arm from its original point to your specified point Parameters: coords: ： a list of coords value [x,y,z,rx,ry,rz],length6 speed(int): 1 ~ 100 pause(deceleration=0) Function: Controls the core and stops all motion commands. Parameters: deceleration: Whether to decelerate and stop. The default value is 0. 1 indicates a deceleration. Return Value: 1 - stopped 0 - not stopped -1 - error is_paused() Function: Checks whether the program has paused a motion command. Return Value: 1 - paused 0 - not paused -1 - error resume() Function: Resume robot motion and complete the previous command. stop(deceleration=0) Function: Stops robot motion. Parameters: deceleration: Whether to decelerate and stop. Defaults to 0. 1 indicates a slow stop. Return Value: 1 - Stopped 0 - Not stopped -1 - Error is_in_position(data, flag) function : judge whether in the position. Parameters: data: Provide a set of data that can be angles or coordinate values. If the input angle length range is 7, and if the input coordinate value length range is 6 flag: data type (value range 0 or 1) 0: angle 1: coord Return value: 1 - true 0 - false -1 - error is_moving() function: judge whether the robot is moving Return value: 1 moving 0 not moving -1 error 5. JOG Mode And Operation jog_angle(joint_id, direction, speed) function: jog control angle Parameters: joint_id: Represents the joints of the robotic arm, represented by joint IDs ranging from 1 to 6 direction(int): To control the direction of movement of the robotic arm, input 0 as negative value movement and input 1 as positive value movement speed: 1 ~ 100 jog_coord(coord_id, direction, speed) function: jog control coord. Parameters: coord_id: (int) Coordinate range of the robotic arm: 1~6 direction:(int) To control the direction of machine arm movement, 0 - negative value movement, 1 - positive value movement speed: 1 ~ 100 jog_increment_angle(joint_id, increment, speed) function: Single joint angle increment control Parameters: joint_id: 1-6 increment: Incremental movement based on the current position angle speed: 1 ~ 100 jog_increment_coord(coord_id, increment, speed) function: Single joint angle increment control Parameters: joint_id: axis id 1 - 6. increment: Incremental movement based on the current position coord speed: 1 ~ 100 6. Speed/Acceleration Parameters get_max_speed(mode) Function: Get the maximum speed Parameters: mode : int 0: Angular speed 1: Coordinate speed Return value: Angular speed range: 1-150°/s, coordinate speed range: 1-200mm/s set_max_speed(mode, max_speed) Function: Set the maximum speed Parameters: mode : int 0: Angular speed 1: Coordinate speed max_speed: Angular speed range: 1-150°/s, coordinate speed range: 1-200mm/s get_max_acc(mode) Function: Get the maximum acceleration Parameters: mode : int 0: Angular acceleration 1: Coordinate acceleration Return value: Angular acceleration range 1 to 150°/s, coordinate acceleration range 1 to 400 mm/s set_max_acc(mode, max_acc) Function: Set maximum motion acceleration Parameters: mode : int 0: Angular acceleration 1: Coordinate acceleration max_acc: Angular acceleration range 1 to 150°/s, coordinate acceleration range 1 to 400 mm/s 7. Joint Software Limit Operation get_joint_min_angle(joint_id) function: Read the minimum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value：float Angle value get_joint_max_angle(joint_id) function: Read the maximum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value: float Angle value set_joint_min_angle(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be less than the minimum value set_joint_max_angle(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be greater than the maximum value 8. Joint Motor Auxiliary Control get_servo_encoders() function：Read the full joint encoder value Return value： A list of length 6 set_servo_calibration(servo_id) function: The current position of the calibration joint actuator is the angle zero point Parameters: servo_id: 1 - 6 set_break（joint_id, value） function: Set break point Parameters： joint_id: int. joint id 1 - 6 value: int. 0 - disable, 1 - enable Return value: 0 : faile; 1 : success set_motor_enabled(joint_id, state function: Set the robot torque state.(Release joint interface) Parameters： joint_id: int. joint id 1 - 6, 254-all joints state: int. 0 - disable, 1 - enable 9. Drag Teach drag_teach_save() Function: Start recording and dragging the teach point. Note: For optimal motion performance, the recording time should not exceed 90 seconds. drag_teach_execute() Function: Start dragging the teach point. Execute only once. drag_teach_clean() Function: Clear the sampling point. 10. Dynamics get_collision_mode() Function: Query the collision detection mode Return value: 0: Off 1: On set_collision_mode(mode) Function: Set the joint collision threshold Parameter: int mode: 0: Off 1: On get_collision_threshold() Function: Get the joint collision threshold Return value: A list of all joint collision thresholds set_torque_comp(joint_id, comp_value=100) Function: Set the torque compensation coefficient Parameter: joint_id int: Joint ID, range 1 to 6 comp_value: Compensation value, range 0-250, default 100. Smaller values ​​result in more difficult joint dragging. get_torque_comp() Function: Get torque compensation coefficients Return value: A list of torque compensation coefficients for all joints fourier_trajectories(trajectory) Function: Execute dynamic identification trajectory Parameter: trajectory: int, range 0-1 parameter_identify() Function: Kinetic parameter identification 11. Circular Motion write_move_c(transpoint, endpoint, speed) Function: Circular arc motion (specify transit points) Parameter: transpoint(list): Arc transit points endpoint(list): Arc endpoint speed(int): 1 to 100 12. Run Auxiliary Information get_zero_pos() function: Read the zero encoder value Return value: listThe value of the zero encoder for seven joints get_servo_speeds() function：Get the movement speed of all joints Return value： unit step/s get_servo_currents() function：Get the movement current of all joints Return value： 0 ~ 5000 mA get_servo_status() function：Get the movement status of all joints Return value： a value of 0 means no error 13. Robotic Arm End IO Control set_digital_output(pin_no, pin_signal) Function: Set terminal IO status Parameters pin_no (int): Pin number, range 1 to 2 pin_signal (int): 0 / 1, 0 - low level, 1 - high level Return Value: 1: Completed get_digital_input(pin_no) Function: Get terminal IO status Parameters: pin_no (int), range 1 to 2 Return Value: int 0 / 1, 0 - low level, 1 - high level 14. End Light Panel Function set_color(r, g, b) Function: Set the color of the end light of the robot arm Parameter: r (int): 0 to 255 g (int): 0 to 255 b (int): 0 to 255 15. Bottom IO Control set_base_io_output(pin_no, pin_signal) function：Set Base IO Output Parameters： pin_no (int) Pin port number, range 1 ~ 12 pin_signal (int): 0 - low. 1 - high get_base_io_output(pin_no) function: Read base IO input Parameters: pin_no (int) pin number, range 1 ~ 12 Return value: 0 - low. 1 - high set_base_external_config(communicate_mode, baud_rate, timeout) Function: Set the bottom external device configuration Parameter: communicate_mode (int) Range: 1 to 2 1: 485 2: can baud_rate (int): Baud rate timeout: (int) Timeout period, in milliseconds get_base_external_config() Function: Read the bottom external device configuration Return value: list returns a list: [communication mode, baud rate, timeout] base_external_can_control(can_id, can_data) Function: Controls CAN devices on the bottom Parameters: can_id (int) Range: 1 to 4 can_data (list) List contents are in hexadecimal format, with a maximum length of 64 characters. base_external_485_control(data) Function: Controls 485 devices on the bottom Parameters: data (list) List contents are in hexadecimal format, with a maximum length of 64 characters. 16. Set Up 485 Communication At The End Of The Robotic Arm tool_serial_read_data(data_len) function: Read fixed length data. Before reading, read the buffer length first. After reading, the data will be cleared Parameters： data_len (int): The number of bytes to be read, range 1 ~ 45 Return value: 0 : not set 1 : Setup completed tool_serial_write_data(command) function: End 485 sends data， Data length range is 1 ~ 45 bytes Parameters： command (list): Data instructions in modbus format Return value: Modbus data list set_over_time(timeout=1000) function: Set the timeout (unit: ms), default is 1000ms (1 second) Parameters： timeout (int): Timeout period, in ms, range 0~65535 flash_tool_firmware(main_version, modified_version=0) Function: Flash the terminal firmware Parameters: main_version (str): Major and minor version numbers, e.g. 1.1 modified_version (int): Modified version number, range 0 to 255, default is 0 17. Tool Coordinate System Operations set_tool_reference(coords) Function: Set the tool coordinate system Parameters: coords: (list) [x, y, z, rx, ry, rz]. | Coord Id | range | | ---- | ---- | | x | -1000 ~ 1000 | | y | -1000 ~ 1000 | | z | -1000 ~ 1000 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | get_tool_reference(coords) Function: Get the tool coordinate system Return value: (list) [x, y, z, rx, ry, rz] set_world_reference(coords) Function: Set the world coordinate system Parameters: coords: (list) [x, y, z, rx, ry, rz]. | Coord Id | range | | ---- | ---- | | x | -1000 ~ 1000 | | y | -1000 ~ 1000 | | z | -1000 ~ 1000 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | get_world_reference() Function: Get the world coordinate system. Return value: list [x, y, z, rx, ry, rz]. set_reference_frame(rftype) Function: Set the base coordinate system Parameters: rftype: 0 - Base coordinates (default), 1 - World coordinates. get_reference_frame() Function: Get the base coordinate system Return value: (list`) [x, y, z, rx, ry, rz]. set_movement_type(move_type) Function: Set the movement type Parameters: move_type: 1 - moveL, 0 - moveJ. get_movement_type() Function: Get the movement type Return value: 1 - moveL 0 - moveJ set_end_type(end) Function: Set the end coordinate system Parameters: end (int): 0 - Flange (default), 1 - Tool get_end_type() Function: Get the end coordinate system Return value: 0 - Flange (default) 1 - Tool 18. Algorithm Parameters get_vr_mode() Function: Get the VR mode Return value: 0: Off 1: On set_vr_mode(move) Function: Set the VR mode Parameters: move: 1 - On, 0 - Off. get_model_direction() Function: Get the joint model direction Return value: Model direction of joints 1-6 1 - Same direction as the motor 0 - Opposite direction from the motor set_model_direction(joint_id, direction) Function: Set the joint model direction Parameters: joint_id (int): 1 to 6 direction (int): 1 - Same direction as the motor. 0 - Opposite direction from the motor get_filter_len(rank) Function: Get filter parameters Parameters: rank: int 1: Drag teach sampling filter 2: Drag teach execution filter 3: Joint velocity fusion filter 4: Coordinate velocity fusion filter 5: Drag teach sampling period Return value: int 1 to 100 set_filter_len(rank, value) Function: Set filter parameters Parameters: rank (int): 1 to 5 value (int): 1 to 100 get_fusion_parameters(rank_mode) Function: Get velocity fusion planning parameters Parameters: rank_mode: 1 to 4 1: Fusion joint velocity 2: Fusion joint acceleration 3: Fusion coordinate velocity 4: Fusion coordinate acceleration Return value: (int): 0 to 1000 set_fusion_parameters(rank_mode, value) Function: Set velocity fusion planning parameters Parameters: rank_mode (int): 1 to 4 value (int): 0 to 1000 19. Kinematics Algorithm Interface solve_inv_kinematics(target_coords, current_angles) Function: Convert coordinates to angles. Parameters target_coords: list A list of floating-point values ​​for all coordinates. current_angles: list A list of floating-point values ​​for all angles, indicating the current angles of the robot arm. Return Value: list A list of floating-point values ​​for all angles. 20. Pro Force-controlled Gripper get_pro_gripper_firmware_version( gripper_id=14) Function: Read the major and minor versions of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (float) Version number, x.x get_pro_gripper_firmware_modified_version(gripper_id=14) Function: Read the modified version of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (int) Correction version number set_pro_gripper_id(target_id, gripper_id=14) Function: Set the force-controlled gripper ID. Parameter: target_id (int): Range: 1 to 254. gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_id(gripper_id=14) Function: Read the force-controlled gripper ID. Parameter: gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: int Range: 1 to 254. set_pro_gripper_angle(gripper_angle，gripper_id=14) Function: Set the force-controlled gripper angle. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_angle(gripper_id=14) Function: Read the angle of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: int 0 ~ 100 set_pro_gripper_open(gripper_id=14) Function: Open the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_close(gripper_id=14) Function: Close the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_calibration(gripper_id=14) Function: Set the zero position of the force-controlled gripper. (The zero position needs to be set first when using it for the first time) Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_status(gripper_id=14) Function: Read the gripping status of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Moving. 1 - Stopped moving, no object was detected. 2 - Stopped moving, object was detected. 3 - After the object was detected, it fell. set_pro_gripper_enabled(state, gripper_id=14) Function: Sets the force-controlled gripper enable state. Parameter: state (bool): 0 or 1, 0 - disable, 1 - enable gripper_id (int): Gripper ID, default 14, range 1 to 254. Return Value: 0 - Failure 1 - Success set_pro_gripper_torque(torque_value，gripper_id=14) Function: Set the torque of the force-controlled gripper. Parameter: torque_value (int): Torque value, value range 0 ~ 100. gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_torque(gripper_id=14) Function: Read the torque of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: (int) 0 ~ 100 set_pro_gripper_speed(speed，gripper_id=14) Function: Set the force-controlled gripper speed. Parameter: speed (int): Gripper movement speed, value range 1 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_speed(speed，gripper_id=14) Function: Read the speed of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: Gripper default movement speed, range 1 ~ 100. set_pro_gripper_abs_angle(gripper_angle，gripper_id=14) Function: Set the absolute angle of the force-controlled gripper. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_io_open_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper I/O opening angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return Value: 0 - Failure 1 - Success get_pro_gripper_io_open_angle(gripper_id=14) Function: Reads the force-controlled gripper I/O opening angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_io_close_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper IO closing angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_io_close_angle(gripper_id=14) Function: Read the force-controlled gripper IO closing angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_mini_pressure(pressure_value, gripper_id=14) Function: Set the minimum actuation force of the force-controlled gripper Parameter: pressure_value (int): Actuation force value, range 0 to 254. gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_mini_pressure(gripper_id=14) Function: Read the minimum actuation force of the force-controlled gripper Parameter: gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: (int) Starting force value, range 0 to 254. set_pro_gripper_protection_current(current_value, gripper_id=14) Function: Set the gripping current of the force-controlled gripper Parameter: current_value (int): Gripping current value, range 100 to 300. gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_protection_current(gripper_id=14) Function: Read the gripping current of the force-controlled gripper Parameter: gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: (int) Clamping current value, range 100 ~ 300. "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/3_angle.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/3_angle.html","title":"6.1.3 JointControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Joint Control For serial multi-joint robots, the control of joint space is to control the variables of each joint of the robot, and the goal is to make each joint of the robot reach the target position at a certain speed. Note: When setting the angle, the limit of different series of robot arms is different. For details, please refer to the parameter introduction of the corresponding model. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_angles()) # Read all joint angle information pro450.send_angles([0, 0, 0, 0, 0, 0], 50) # Send all joint angles, speed is 50, so that all joints of the robot arm move to zero position time.sleep(3) pro450.send_angle(1, 90, 50) # Send single joint angle, speed is 50, so that J1 joint moves to 90 degrees time.sleep(2) pro450.send_angles([0, -10, -123, 45, 0, 90], 50) # Send all joint angles, speed 50 time.sleep(3) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html","title":"6.1.4 CoordinateControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Coordinate Control It is mainly used to realize intelligent route planning to let the robot arm move from one position to another specified position. It is divided into [x, y, z, rx, ry, rz], where [x, y, z] represents the position of the robot head in space (the coordinate system is the rectangular coordinate system), and [rx, ry, rz] represents the posture of the robot head at this point (the coordinate system is the Euler coordinate system). The implementation of the algorithm and the representation of Euler coordinates require certain academic knowledge. We will not explain it too much here. As long as we understand the rectangular coordinate system, we can use this function well. Note: When setting coordinates, different series of robot arm joint structures are different. For the same set of coordinates, different series of robot arms will show different postures. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_coords()) # Read coordinate attitude information pro450.send_angles([0, -10, -123, 45, 0, 0], 50) # Send angular motion to a certain attitude for coordinate control, speed is 50 time.sleep(3) pro450.send_coord(1, 200, 50) # Send single coordinate control, speed is 50, so that the X axis moves to the position of 200mm time.sleep(2) pro450.send_coords([300, 86.8, 256.9, -178.0, 0.0, -90.0], 50) # Send multi-coordinate control, speed is 50 time.sleep(3) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html","title":"6.1.5 IOControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 IO Control IO stands for data input and output. Our robot arm's Basic and Atom pins have multiple pins. This section mainly explains how to use the end-point IO to control the gripper. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection and communication if pro450.is_power_on() !=1: pro450.power_on() # Power on # Open the gripper def open_gripper(): pro450.set_digital_output(1, 0) # Set pin 1 to a low level pro450.set_digital_output(2, 1) # Set pin 2 to a high level time.sleep(0.05) # Close the gripper def close_gripper(): pro450.set_digital_output(1, 1) # Set pin 1 to a high level pro450.set_digital_output(2, 0) # Set pin 2 to a low level time.sleep(0.05) # Repeat the gripper opening and closing twice for i in range(2): open_gripper() time.sleep(3) close_gripper() ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html","title":"6.1.6 GripperControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Gripper Control Before using Python to control the gripper, you must first install and connect the gripper to the robotic arm. Different grippers are compatible with different robotic arms. Here, we use the myGripper F100 Pro force-controlled gripper. Note: Before use, ensure that the communication mode on the gripper's small screen is set to Modbus mode; otherwise, the gripper will not function properly. Refer to Gripper Screen Control Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_pro_gripper_firmware_version()) # Read the major and minor version numbers of the gripper time.sleep(1) print(pro450.get_pro_gripper_angle()) # Read the gripper angle information time.sleep(1) pro450.set_pro_gripper_angle(50) # Set the gripper angle to 50 time.sleep(2) pro450.set_pro_gripper_speed(70) # Set the gripper speed to 70 time.sleep(1) pro450.set_pro_gripper_open() # Set the gripper to fully open time.sleep(2) pro450.set_pro_gripper_close() # Set the gripper to fully close time.sleep(2) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html","title":"6.1.7 RobotExceptionHandling","keywords":"","body":"Checking And Handling Robot Arm Exceptions When the robot arm fails to execute a motion command, you can query the corresponding exception information in the Python terminal, for example. Reading Robot Status Status Feedback Analysis Under normal circumstances, this interface returns all 0s. Reading the robot status is as follows: from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) if pro450.is_power_on() !=1: pro450.power_on() # Power on pro450.get_robot_status() # Reading Robot Status Return: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] Indicates the robot is not moving, no joints are exceeding limits, no joint hardware errors, and no joint software errors. A complete explanation of each value is as follows: [Reserved, Whether Moving, Whether J1 Exceeds Limits, Whether J2 Exceeds Limits, Whether J3 Exceeds Limits, Whether J4 Exceeds Limits, Whether J5 Exceeds Limits, Whether J6 Exceeds Limits, Whether J1 Motor Hardware Error, Whether J2 Motor Hardware Error, Whether J3 Motor Hardware Error, Whether J4 Motor Hardware Error, Whether J5 Motor Hardware Error, Whether J6 Motor Hardware Error, Whether J1 Software Communication Error, Whether J2 Software Communication Error, Whether J3 Software Communication Error, Whether J4 Software Communication Error, Whether J5 Software Communication Error, Whether J6 Software Communication Error] The following example is as follows: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that the robot reported an error during movement, with J4 reporting a control error. [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that robot J2 exceeded the limit. [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0] Indicates that the robot's J5 line is abnormal - receiving an error Exception Resolution Joint Out Of Limit When a joint exceeds the limit, use one of the following solutions: Execute the over-limit return to zero interface: pro450.over_limit_return_zero() #The robot will return to the origin at a slower speed Execute joint relaxation and manually move the joint to within the limit pro450.set_motor_enable(254, 0) Joint Hardware Error Most hardware errors can be recovered using exception recovery. pro450.servo_restore(joint_id) If this problem persists after using exception recovery or restarting the robot, please contact our engineers. Detailed information about the hardware errors for each joint is shown: Bit (2 bytes) Error Status 0 CAN bus error. Exception recovery possible. If recovery is not possible, check the communication line, repair it, and then power on again. 1 Short circuit. Exception recovery possible. 2 Invalid setting data 3 Control error. Exception recovery possible. 4 CAN communication error. Exception recovery possible. If recovery is not possible, check the communication line, repair it, and then power on again. 5 Feedback error. Exception recovery possible. 6 Positive limit switch active. 7 Negative limit switch active. 8 Negative limit switch active. 9 Overcurrent. Exception recovery possible. 10 12t protection. Exception recovery possible. Overtemperature. Exception recovery possible. 11 Driver board overtemperature. Exception recovery possible. 12 Overvoltage. Exception recovery possible. 13 Undervoltage, exception recovery possible 14 Command error 15 Enable inactive Joint Software Errors Software error feedback mainly includes: circuit abnormalities, CAN module abnormalities, encoder abnormalities, and enable failure. If the enable failure occurs, use pro450.set_motor_enable(254, 1) to enable motion again. For other abnormalities, please contact our engineers. Detailed joint software error information is shown: Bit (1 byte) Error Status 1 - Abnormal 0 - Normal 0 CAN initialization error. Check the main control board. After repairing the control board error, power cycle. Symptoms: The machine cannot be enabled or controlled. 1 Motor initialization error. Check the motor communication circuit. After repairing the error, power cycle. Symptoms: The machine cannot properly feedback joint information or control. 2 Motor transmission error. Check the motor communication circuit. Symptoms: Machine position feedback error. Can be cleared using error recovery. 3 Motor reception error. Check the motor communication circuit. Symptoms: Machine position feedback error. Can be cleared using error recovery. This feedback allows normal machine control and does not require user notification. It is mainly used for troubleshooting. 4 Position error. Check the motor encoder. Symptoms: The machine is disabled and motion control is impossible. Can be cleared using error recovery. 5 Terminal transmission error. Check the terminal communication line, etc. Symptom: Terminal interface feedback error. Can be cleared using error recovery. 6 Terminal reception error. Check the terminal communication line, etc. Symptom: Terminal interface feedback error. Can be cleared using error recovery. This feedback allows normal machine control without prompting the user and is primarily used for troubleshooting. 7 Motor encoder error. When the encoder reports an error, movement is disabled. Clear the encoder error. Older motor driver boards do not report errors—even if an encoder error is reported, the software does not report the error. How to distinguish newer boards: The board with the battery is a new driver board. 8 Feedback will be generated when the enable is turned off. The machine must be enabled before movement. The robot is in motion and cannot move. The robot is in motion and does not respond when you send a motion point. Please stop the robot by executing pro450.stop() and pro450.resume(). If the robot still cannot move, please contact our engineers. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/","title":"6.2 ROS1","keywords":"","body":"ROS ROS is an open-source, post-operating system (ROS), or secondary operating system, for robotic control. It provides operating system-like functionality, including hardware abstraction, low-level driver management, execution of shared functions, inter-program messaging, and package management. It also provides tools and libraries for acquiring, building, writing, and running multi-machine integrated programs. The ROS runtime \"graph\" is a network of loosely coupled peer-to-peer processes based on the ROS communication infrastructure. ROS implements several different communication methods, including a service mechanism for synchronous RPC-style communication, a topic mechanism for asynchronous streaming data, and a parameter server for data storage. ROS is not a real-time framework, but it can be embedded in real-time programs. Willow Garage's PR2 robot uses a system called pr2_etherCAT to send and receive ROS messages in real time. ROS also integrates seamlessly with the Orocos Real-Time Toolkit. ROS Logo: 1 Design Goals And Features Of ROS Many people ask, \"What's the difference between ROS and other robotics software platforms?\" This question is difficult to answer. ROS isn't a framework that integrates most functions or features. In fact, its primary goal is to support code reuse in robotics development. ROS is a framework for distributed processes (i.e., nodes), which are encapsulated in programs and function packages and can be easily shared and distributed. ROS also supports a federated system similar to a code repository, which facilitates collaboration and distribution of projects. This design allows for complete independence in project development and implementation, from file systems to user interfaces (ROS has no limitations). Furthermore, all projects can be integrated with ROS's basic tools. To support its primary goals of sharing and collaboration, the ROS framework also has several other features: Streamlined: ROS is designed to be as streamlined as possible, which makes it easier for ROS to The code written can be used with other robotics software frameworks. Consequently, ROS can be easily integrated into other robotics software platforms: ROS has already been integrated with OpenRAVE, Orocos, and Player. ROS-independent libraries: The preferred development model for ROS is to write concise library functions that do not depend on ROS. Language independence: The ROS framework can be easily implemented in any modern programming language. ROS has been implemented in Python, C++, and Lisp. Experimental libraries are also available in Java and Lua. Loose coupling: Functional modules in ROS are encapsulated in independent packages or metapackages, making them easy to share. Modules in a package run on a per-node basis. Using ROS standard IO as an interface, developers do not need to worry about the internal implementation of modules. As long as they understand the interface rules, they can reuse modules and achieve point-to-point loose coupling. Convenient testing: ROS has a built-in unit/integration testing framework called rostest, which makes it easy to install and uninstall test modules. Extensible: ROS Suitable for large-scale operating systems and development processes. Free and open source: It has many developers and feature packages. 2 Why use ROS? ROS allows us to simulate and control a robotic arm in a virtual environment. We will use rviz to visualize the robotic arm, manipulate it in various ways, and MoveIt to plan and execute its motion paths, achieving free control of the robotic arm. In the following chapters, we will learn how to control our product using the ROS platform. MoveIt MoveIt is currently the most advanced robotic arm motion manipulation software, used in over 100 robots. It integrates the latest advances in motion planning, control, 3D perception, motion control, control, and navigation, providing an easy-to-use platform for developing advanced robotic applications and an integrated software platform for the design, integration, and evaluation of new robotics products in industry, commerce, R&D, and other fields. MoveIt Logo : 1 Description MoveIt is a ROS integrated development platform consisting of various functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, collision detection, and more. The following figure shows the high-level structure of the main node move_group provided by MoveIt. It acts as a combiner: it brings together all the individual components to provide users with a range of operations and services. 2 User Interface Users can access the operations and services provided by move_group in three ways: In C++, using the move_group_interface package makes it easy to use move_group. In Python, using the moveit_commander package. Through a graphical user interface: using Rviz (a ROS visualization tool) with Motion-commander. move_group can be configured through the ROS parameter server and can also retrieve the robot's URDF and SRDF from the server. 3 Configuration move_group is a ROS node. It uses the ROS parameter server to obtain three types of information: URDF - move_group looks for the robot_description parameter in the ROS parameter server to obtain the robot's URDF. SRDF - move_group looks for the robot_description_semantic parameter in the ROS parameter server to obtain the robot's SRDF. The SRDF is typically created by the user using the MoveIt Setup Assistant. MoveIt configuration - move_group will look for additional MoveIt-specific configuration in the ROS parameter server, including information about joint constraints, kinematics, motion planning, perception, and more. Configuration files for these components are automatically generated by the MoveIt Setup Assistant and stored in the configuration directory of the robot's corresponding MoveIt configuration package. For more information on using the setup assistant, see: MoveIt Setup Assistant ← Previous Chapter | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html","title":"6.2.1 EnvironmentSetup","keywords":"","body":"ROS1 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest way to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing A Virtual Machine Image Recommended: This is the quickest method and suitable for beginners. Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 20.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default user is u202, and the default password is 123). Built-in Environment: ROS1 + Moveit + Git + pymycobot + mycobot_ros 1 Install Virtual Machine Go to official website to download virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux System Image Click to download: Linux ubuntu20.04 3 Import Linux System Image In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import it, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the user name is u202, the default password is 123 4 Update Pymycobot To use the latest robotics driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update Mycobot_ros To ensure users have the latest official packages, navigate to the /home/u202/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/catkin_ws/src # Delete the original mycobot_ros package sudo rm -rf mycobot_ros git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables Method 2: Customize The Installation Environment 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Create A Virtual Machine Select New in the control Enter the virtual machine name and the location where the virtual machine is stored, select the virtual machine type as Linux, select Ubuntu 64-bit version, and proceed to the next step. Configure the memory size according to your needs and proceed to the next step. Select Create a virtual hard disk now and create it. Select the VDI type for the virtual hard disk type and proceed to the next step. Allocate the size of the virtual hard disk. Since you need to install the Ubuntu system and will also operate in the system, it is recommended that the size should not be less than 20G. 3 Download Ubuntu System. Please choose the Ubuntu version to install according to your needs, the default version is Ubuntu 20.04. Note: ROS2 needs to download 20.04 version. 20.04 version The installation method and process of each version are the same. Here we use the 18.04 version as an example After downloading, there is a file as shown in the figure: 4 Import Ubuntu Into The Virtual Machine Find the previously installed virtual machine in Virtual Box, enter Settings, and assign the CD to the controller in Storage: Then open the virtual machine to install Ubuntu and click Start. 5 Ubuntu Installation Wait for the system to start, enter the Welcome interface, select \"English\", and click the \"Install Ubuntu\" button; Click the \"Continue\" button; Select the \"Erase the entire disk and install Ubuntu\" option, and click the \"Install Now\" button; Click the \"Continue\" button in the pop-up dialog box; Set the geographic location and click the \"Continue\" button; Set the user name and password and click the \"Continue\" button; Enter the system installation interface, please wait patiently; After the installation is complete, in the pop-up dialog box, click the \"Restart Now\" button to complete the installation. 6 ROS Installation The basic development environment setup requires the installation of the robot operating system ROS, MoveIt, and git version manager. The following describes their installation methods and processes. For myCobot Pro 450 devices, please refer to the installation methods and processes described below. Here we choose Ubuntu 20.04, and the corresponding ROS version is ROS Melodic NOTE: We currently do not provide any reference for installing ROS on Windows. If necessary, please refer to https://www.ros.org/install/ 6.1 Start Installation 1 Add Source There is no ROS software source in the software source list of Ubuntu itself, so you need to configure the ROS software source to the software list warehouse before you can download ROS. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Tsinghua University is: sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list' You will be asked to enter the user password here. Just enter the user password you set when installing Ubuntu. 2 Set Up The Secret Key Configure the public network secret key. This step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 The execution results are shown below:： 3 Installation After adding a new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute Install ROS, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command according to your Ubuntu version: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full It is recommended to install the complete ROS to prevent missing libraries and dependencies. The installation process takes a long time, please be patient If the following error message appears in the console terminal during the installation, you need to change the software source list in /etc/apt/sources.list. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo gedit /etc/apt/sources.list Replace all official software sources in sources.list with the following Alibaba Cloud software sources: Ubuntu 20.04： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse After the configuration is complete, the contents of the sources.list file are as follows. Click Save and Exit. Update the software source list and enter in the console terminal: sudo apt-get update Enter the command to install ROS in the console terminal: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full The installation process takes a long time, please wait patiently 4 Configure ROS Environment To The System rosdep allows you to easily install the source code you want to compile or the system dependencies required by some ROS core components. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T). If rosdep is not installed on your system, please use the command sudo apt install python-rosdep to install it. If your installed Ubuntu system is version 20.04, please use the command sudo apt install python3-rosdep to install it, and execute the rosdep initialization command after completion. --> Initialize rosdep: sudo rosdep init If the error message shown below appears: Solution: Modify the hosts file and enter the following command in the console terminal: sudo gedit /etc/hosts At the end of the file content, add the IP addresses of the following two websites to access: 199.232.28.133 raw.githubusercontent.com 151.101.228.133 raw.github.com After the modification is completed, execute in the console terminal: sudo rosdep init rosdep update After initialization is completed, in order to avoid the need to re-validate the ROS function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T): 6.2 Set Up The Ros Environment Execute the following command: # Ubuntu 20.04 echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc 6.3 Install ROS Additional Dependencies Enter the following command in the terminal to install ROS additional dependencies and open a console terminal (shortcut key Ctrl+Alt+T): sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential # Ubuntu 20.04 sudo apt install ros-noetic-joint-state-publisher-gui 6.4 Verify The Installation The startup of the ROS system requires a ROS Master, i.e., a node manager. We can start the ROS Master by entering the roscore command in the terminal. To verify whether ROS is successfully installed, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: roscore When the following interface is displayed, it means that ROS is installed successfully The roscore command starts a node manager, which is used for node management. In a ros system, there is only one node manager, which is the prerequisite for the operation of the ros node. Therefore, before starting the ros node, the first step is to execute roscore. For more detailed installation instructions, please refer to the official installation guide at: http://wiki.ros.org/ROS/Installation 7 MoveIt Installation MoveIt is a functional package of a series of mobile operations in ROS, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 7.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 7.2 Install MoveIt Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window to execute MoveIt installation: # Ubuntu20.04 sudo apt-get install ros-noetic-moveit 8 Git Installation 8.1 Add Software Source Add the software source installed by git to the software source list of Ubuntu, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: sudo add-apt-repository ppa:git-core/ppa 8.2 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 8.3 Install Git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 8.4 Verify Installation Read the git version, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, indicating a successful installation 8.5 Usage You will need to use git to download the ros package later. For details on how to use git, please refer to the following link: https://git-scm.com/book/zh/v2 https://www.runoob.com/git/git-tutorial.html 9 Mycobot_ros Installation mycobot_ros is a ROS package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. 项目地址：http://github.com/elephantrobotics/mycobot_ros 9.1 Prerequisites Before installing the package, please ensure that you have a ros workspace. Here we give a sample command for creating a workspace, the default is catkin_ws, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory as a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace. Add workspace environment The official default ROS1 workspace is catkin_ws. # Ubuntu 20.04 echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc 9.2 Installation NOTE: This package depends on ROS and MoveIT. Please make sure that ROS and MoveIT are installed successfully before use. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip3 install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. The official default ROS1 workspace is catkin_ws. cd ~/catkin_ws/src # Enter the src folder of the workspace git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git # Clone the code on github cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables This completes the ROS1 environment setup. For more information on using ROS1, please refer to ROS Basics or ROS Basic Function Examples. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html","title":"6.2.2 ROSBasics","keywords":"","body":"1 ROS Project Structure 1.1 Catkin Workspace Catkin workspace is the directory where catkin software packages are created, modified, and compiled. Catkin's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory into a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace The structure of catkin is very clear. It includes three paths: src, build, and devel. It may also include others under some compilation options. But these three folders are the default for the catkin compilation system. Their specific functions are as follows: src/: ROS catkin software package (source code package) build/: cache information and intermediate files of catkin (CMake) devel/: Generated target files (including header files, dynamic link libraries, static link libraries, executable files, etc.), environment variables A simple workspace looks like this: workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 1.2 ROS Software Package Package is not only a software package on Linux, but also the basic unit of catkin compilation. The object we use catkin_make to compile is each ROS package. +--PACKAGE +-- CMakeLists.txt +-- package.xml +-- src/ +-- include/ +-- scripts/ +-- msg/ +-- srv/ +-- urdf/ +-- launch/ CMakeLists.txt: Defines the package name, dependencies, source files, target files and other compilation rules of the package. It is an essential component of the package. package.xml: Describes the package name, version number, author, dependencies and other information of the package, which is an indispensable component of the package. src/: stores ROS source code, including C++ source code (.cpp) and Python module (.py) include/: stores the header files corresponding to the C++ source code scripts/: stores executable scripts, such as shell scripts (.sh), Python scripts (.py) msg/: stores messages in custom format (.msg) srv/: stores services in custom formats (.srv) urdf/: stores the robot’s model description (.urdf or .xacro) and 3D model files (.sda, .stl, .dae, etc.) launch/: stores launch files (.launch or .xml) Create your own package: Command format: The catkin_create_pkg command will ask you to enter package_name. If necessary, you can also add some other dependent software packages later: catkin_create_pkg [depend1] [depend2] [depend3] For example: catkin_create_pkg beginner_tutorials std_msgs rospy roscpp 2 ROS Communication Architecture 2.1 Master And Node 1 Master Node manager. Each node must register with the master before starting and manage the communication between nodes. 2 Roscore Starting the master will also start rosout (log management) and parameter server (parameter manager) 3 Nodes ROS processes and instances of running executable files in pkg. $rosrun [pkg_name] [node_name] #Start $rosnode list #List currently running node information $rosnode info [node_name] #Display detailed information of a node $rosnode kill [node_name] #End a node 4 Launch Start the master and multiple nodes. $roslaunch [pkg_name] [file_name.launch] 2.2 Service And Topic We provide some services and topics for interacting with mycobot. 1 Service Enter in the command line: source ~/catkin_ws/devel/setup.bash # Add environment variables roslaunch mycobot_pro450_communication communication_service.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rosservice list #/get_joint_angles #/get_joint_coords #/set_joint_angles #/set_joint_coords #/switch_gripper_status #/switch_pump_status Related commands and instructions: command Detailed description rosservice list Display active service information rosservice info [service name] Display information about the specified service rosservice type [service name] Show service type rosservice find [service name] Find a service for a specified service type rosservice uri [service name] show ROSRPC URI service rosservice args [service name] show service parameters rosservice call [service name] [parameters] Request service with input parameters 2 Topic Enter in the command line: source ~/catkin_ws/devel/setup.bash roslaunch mycobot_pro450_communication communication_topic.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rostopic list #/mycobot/angles_goal #/mycobot/coords_goal #/mycobot/angles_real #/mycobot/coords_real #/mycobot/pump_status #/mycobot/gripper_status Related commands and instructions: Command Detailed description rostopic list Display active topic list rostopic echo [topic name] Display the message content of the specified topic in real time rostopic find [type name] Display threads with messages of the specified type rostopic type [topic name] Displays the message type of the specified topic rostopic bw [topic name] Display the message bandwidth of the specified topic（bandwidth） rostopic hz [topic name] Display the message data publishing cycle of the specified topic rostopic info [topic name Display information about the specified topic rostopic pub [topic name] [message type] [parameters] Post a message with the specified topic name The difference between service and topic: service topic Synchronization Asynchronous Synchronous communication model pub/sub server/client underlying protocol ROSTCP/ROSUDP ROSTCP/ROSUDP Feedback Mechanism No Yes buffer Yes No Real-time Weak Strong Node Relationship Many-to-Many One-to-Many Applicable Scenarios Data Transmission Logical Processing you can go to service and topic learn more about the use of these two features 2.3 Introduction To Msg And Srv msg：The msg file is a simple text file describing the fields of a ROS message. They are used to generate source code for messages in different languages (c++ or python, etc.). srv：srv files are used to describe services. It consists of two parts: the request (request) and the response (response). msg files are stored in the msg directory of the package, and srv files are stored in the srv directory. 1 Rosmsg rosmsg is a command line tool for displaying information about ROS message types. rosmsg demo: rosmsg show # Show message description rosmsg info # Display message information rosmsg list # list all messages rosmsg md5 # Display md5 encrypted message rosmsg package # Display all messages under a feature pack rosmsg packages # List feature packs that contain messages rosmsg list will list all msgs in the current ROS rosmsg packages List all packages containing messages rosmsg package List all msgs under a package //rosmsg package # Package names rosmsg package turtlesim rosmsg show Show message description //rosmsg show # message name rosmsg show turtlesim/Pose # result: float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity rosmsg info Works the same as rosmsg show rosmsg md5 A check algorithm to ensure the consistency of data transmission 2 rossrv rossrv is a command-line tool for displaying information about ROS service types, and uses a syntax that is highly similar to rosmsg. rossrv show # Display service message details rossrv info # Display information about service messages rossrv list # List all service information rossrv md5 # Display md5 encrypted service messages rossrv package # Display all service messages under a package rossrv packages # Show all packages that contain service messages rossrv list Will list all srv messages in the current ROS rossrv packages List all packages that contain service messages rossrv package List all msgs under a package //rossrv package # Package names rossrv package turtlesim rossrv show Show message description //rossrv show # message name rossrv show turtlesim/Spawn # result: float32 x float32 y float32 theta string name --- string name rossrv info The effect is the same as rossrv show rossrv md5 Use md5 checksum (encryption) for service data 3 Introduction To URDF Unified Robot Description Format，Unified Robot Description Format, abbreviated as URDF. The urdf package in ROS contains a C++ parser for URDF, and URDF files describe robot models in XML format. *URDF cannot be used alone, it needs to be combined with Rviz or Gazebo. URDF is just a file that needs to be rendered into a graphical robot model in Rviz or Gazebo. 3.1 Urdf File Description Code example: Only part of the code is intercepted here for display: It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. 3.2 Link Section The link element describes a rigid body with inertial, visual features, and collision properties 3.2.1 Attributes name： The name used to describe the link itself 3.2.2 Element (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view 3.3 Joint Part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint. 3.3.1 Properties Of Joint: name： Specifies a unique name for the joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. 3.3.2 Elements Of Joint (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. 4 Commonly Used Command Tools In ROS, there are many commonly used command line tools, which can help you develop, debug, manage ROS nodes, etc. The following are some commonly used ROS command line tools: 4.1 Compile Workspace caktin_make 4.2 Roscore Start the ROS master node. Before running a ROS node, you usually need to start roscore first roscore 4.3 Rosrun Run the specified ROS node. rosrun package_name node_name 4.4 Roslaunch Use the Launch file to start one or more ROS nodes. roslaunch package_name launch_file.launch 4.5 Rosnode View running ROS node information. rosnode list rosnode info node_name 4.6 Rostopic View information about running ROS topics. rostopic list rostopic echo topic_name 4.7 Rosservice View and call ROS services. rosservice list rosservice call service_name 4.8 Rosparam Get and set ROS parameters. rosparam get parameter_name rosparam set parameter_name value 4.9 Rosmsg View ROS message types. rosmsg show message_type 4.10 Rosdep Install dependencies of ROS packages. rosdep install package_name 4.11 Environment Variables View the ROS_PACKAGE_PATH environment variable echo $ROS_PACKAGE_PATH ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html","title":"6.2.3 RivzUse","keywords":"","body":"Brief Introduction And Use Of Rviz rviz is a 3D visualization platform in ROS. On one hand, it can realize the graphical display of external information, and on the other hand, it can also release control information to an object through rviz, realizing the monitoring and control of a robot. 1 Installation Of Rviz And The Introduction To Its Interface When installing ros, if you perform a complete installation, rviz is already installed, and you may try to run it directly; if it is not fully installed, you may install rviz separately: # Ubuntu20.04 sudo apt-get install ros-noetic-rviz After the installation is complete, open a new terminal (shortcut key: Ctrl+Alt+T) and enter the following command: roscore Then open a new terminal (shortcut key: Ctrl+Alt+T) and input the following command to open rviz. rosrun rviz rviz # or rviz Open rviz, and the following interface will be displayed: Introduction of all areas There is a list of monitors on the left. The monitor is a device that draws something in a 3D world and may have some options available in the display list. On the top is a toolbar, which allows the user to use various function buttons to select tools with multiple functions. The middle part is the 3D view: It is a main screen where various data can be viewed in three dimensions. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area where different observation angles can be set. We only give a rough introduction in this part. If you want to know more details, go to User Guide. 2 Simple Use Start Using Launch File This example is built on what you have already done Environment building and you have successfully copied the company's code from GitHub to your virtual machine. Open a new terminal (shortcut key: Ctrl+Alt+T) Input the command to configure the ROS environment. cd ~/catkin_ws/ source devel/setup.bash Input again: roslaunch mycobot_pro_450 test.launch Open rviz, and then you will obtain the following result: If you want to know more information about rviz, go to Official documents. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html","title":"6.2.4 BasicFunctionCases","keywords":"","body":"Robot Arm Control Note: The pymycobot driver library version must be greater than 4.0.0 Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 1 Slider Control Open a command line and run: roslaunch mycobot_pro_450 slider_control.launch # If the end effector is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 slider_control_force_gripper.launch Open rviz and a slider component, and you will see the following interface: If the myGripper F100 force-controlled gripper is attached to the end, you will see the following interface: You can then control the model in rviz and move it by dragging the slider. If you want the actual mold robot to move along with the model, open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro_450 slider_control.py # If the end effector is equipped with a myGripper F100 force-controlled gripper, run the following command: rosrun mycobot_pro_450 slider_control_force_gripper.py Note: Since the robot arm will move to the model's current position when you enter the command, please ensure that the model in rviz does not clip before using the command. Avoid dragging the slider quickly after connecting the robot arm to prevent damage. 2 Model Following In addition to the above controls, we can also make the model follow the movement of the actual robot arm. Open a command line and start the ROS node: roscore Then open a new command line and run: rosrun mycobot_pro_450 follow_display.py After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: Trying to connect to real MyCobot Pro450... IP: 192.168.0.232, port: 4500 Please press the button at the end of the machine to drag the joint. 请按下机器末端按钮进行关节拖拽运动 Publishing... Finally, open another command line and run: roslaunch mycobot_pro_450 follow_display.launch This will open rviz and display the model following effect. At this point, dragging the real robot arm joints will cause the simulation model to follow the real robot arm's movements. 3 GUI Control Building on the above, this package also provides a simple graphical user interface (GUI). Connect to mycobot. Open the command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 simple_gui.launch # If the end device is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 simple_gui_force_gripper.launch If the myGripper F100 force-controlled gripper is installed at the end, the following interface will be displayed: After successful execution, the terminal output is as follows: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, allowing real-time synchronization within rviz. This functionality relies on the Python API, so ensure that the robot arm is connected. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 teleop_keyboard.launch # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 teleop_keyboard_force_gripper.launch The following is the output: If the myGripper F100 force-controlled gripper is installed on the end effector, the following interface will appear: The following information about mycobot will be output in the command line: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then open another command line and run: rosrun mycobot_pro_450 teleop_keyboard.py # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: rosrun mycobot_pro_450 teleop_keyboard_force_gripper.py You will see the following command line output: Mycobot Pro450 Teleop Keyboard Controller (ROS1 - Topic Version) --------------------------------------------------------- Movement (Cartesian): w (x+) a (y+) s (x-) d (y-) z (z-) x (z+) Rotation (Euler angles): u (rx+) i (ry+) o (rz+) j (rx-) k (ry-) l (rz-) Movement Step: + : Increase movement step size - : Decrease movement step size Gripper: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Save current pose as home q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. This script supports the following parameters: _speed: Robot's movement speed _change_percent: Movement distance percentage 5 Moveit Usage mycobot_ros integrates the MoveIt component. Open a command line and run: roslaunch mycobot_pro450_moveit demo.launch The result is as follows: The terminal will output the following information, indicating that moveit has been successfully started: [ INFO] [1757321505.678763337]: Loading robot model 'firefighter'... [ INFO] [1757321505.782983258]: Set joints of group 'arm_group' to pose 'init_pose'. [ INFO] [1757321505.783324504]: Fake controller 'fake_arm_group_controller' with joints [ joint1 joint2 joint3 joint4 joint5 joint6 ] [ INFO] [1757321505.783798265]: Returned 1 controllers in list [ INFO] [1757321505.792047465]: Trajectory execution is managing controllers [ INFO] [1757321505.792117958]: MoveGroup debug mode is ON Loading 'move_group/ApplyPlanningSceneService'... Loading 'move_group/ClearOctomapService'... Loading 'move_group/MoveGroupCartesianPathService'... Loading 'move_group/MoveGroupExecuteTrajectoryAction'... Loading 'move_group/MoveGroupGetPlanningSceneService'... Loading 'move_group/MoveGroupKinematicsService'... Loading 'move_group/MoveGroupMoveAction'... Loading 'move_group/MoveGroupPickPlaceAction'... Loading 'move_group/MoveGroupPlanService'... Loading 'move_group/MoveGroupQueryPlannersService'... Loading 'move_group/MoveGroupStateValidationService'... Loading 'pilz_industrial_motion_planner/MoveGroupSequenceAction'... [ INFO] [1757321505.848190702]: initialize move group sequence action [ INFO] [1757321505.853932419]: Reading limits from namespace /robot_description_planning Loading 'pilz_industrial_motion_planner/MoveGroupSequenceService'... [ INFO] [1757321505.867558584]: Reading limits from namespace /robot_description_planning [ INFO] [1757321505.884930897]: ******************************************************** * MoveGroup using: * - ApplyPlanningSceneService * - ClearOctomapService * - CartesianPathService * - ExecuteTrajectoryAction * - GetPlanningSceneService * - KinematicsService * - MoveAction * - PickPlaceAction * - MotionPlanService * - QueryPlannersService * - StateValidationService * - SequenceAction * - SequenceService ******************************************************** [ INFO] [1757321505.885485766]: MoveGroup context using planning plugin ompl_interface/OMPLPlanner [ INFO] [1757321505.885536833]: MoveGroup context initialization complete You can start planning now! [ INFO] [1757321508.935642298]: Loading robot model 'firefighter'... [ INFO] [1757321509.253483659]: Starting planning scene monitor [ INFO] [1757321509.257223628]: Listening to '/move_group/monitored_planning_scene' [ INFO] [1757321509.375270577]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [ INFO] [1757321510.628737935]: Ready to take commands for planning group arm_group. The basic path planning operation is as follows: If you want the actual robot arm to execute the plan synchronously, you need to open another command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro450_moveit sync_plan.py Modifying Movement Speed To prevent joint shaking during actual robot arm movement, reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robot arm's Python API. Here, change it to 25。 ... def callback(data: JointState): \"\"\"Callback function for ROS JointState subscription. This function converts incoming joint positions (radians) to angles in degrees and sends them to the Pro450 robotic arm. Args: data (JointState): Joint state message containing joint positions. \"\"\" data_list = [] for index, value in enumerate(data.position): radians_to_angles = round(math.degrees(value), 2) data_list.append(radians_to_angles) rospy.loginfo(data_list) mc.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. In this case, change it to 0.1 and save the current configuration. ← Previous Page | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.5-Troubleshooting.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.5-Troubleshooting.html","title":"6.2.5 CommonProblemsAndSolutions","keywords":"","body":"ROS1 Common Problems and Solutions When using ROS1 to control the MyCobot Pro 450, you may encounter some common problems. Below is a list of common errors and their corresponding solutions for quick troubleshooting. 1 Environment-Related Issues Issue 1: Running roslaunch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/catkin_ws catkin_make source devel/setup.bash 2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the roslaunch command is complete In the terminal, enter: rosparam list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz] rviz at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/","title":"6.3 ROS2","keywords":"","body":"ROS2 Introduction The predecessor of ROS2 is ROS, and ROS is the Robot Operating System (Robot Operating System). But ROS itself is not an operating system, but a software library and toolset. The emergence of Ros solved the communication problem of each component of the robot. Later, more and more robot algorithms were integrated into ROS. ROS2 inherited ROS, which is more powerful and better than ROS. 1 Design Goals And Features Of ROS2 ROS2 has the historical mission of changing the era of intelligent robots. At the beginning of the design, it was considered to meet the needs of various robot applications. Multi-Robot Systems: In the future, robots will not be independent individuals, and communication and collaboration between robots are also required. ROS2 provides standard methods and communication mechanisms for the application of multi-robot systems. Cross-platform: Robot application scenarios are different, and the control platforms used will also be very different. In order to allow all robots to run ROS2, ROS2 can run on Linux, Windows, MacOS, and RTOS across platforms. Real time: Robot motion control and many behavior strategies require the robot to be real-time. For example, the robot must reliably detect pedestrians in front of it within 100ms, or complete kinematics and dynamics calculations within 1ms. ROS2 is a real-time like this Basic requirements are provided. Productization: A large number of robots have entered our lives, and there will be more and more in the future，ROS2 can not only be used in the robot research and development stage, but also can be directly installed in the product and go to the consumer market. This also poses a huge challenge to the stability and robustness of ROS2. Project management: Robot development is a complex system engineering. The project management tools and mechanisms for the whole process of design, development, debugging, testing, and deployment will also be reflected in ROS2, making it easier for us to develop a robot. 2 Release Version The release version and maintenance cycle corresponding to ROS2 and Ubuntu. ROS2 version release date Maintenance deadline Ubuntu version Dashing 2019.5 2021.5 Ubuntu 18.04 (Bionic Beaver) Eloquent 2019.11 2020.11 Ubuntu 18.04 (Bionic Beaver) Foxy 2020.6 2023.5 Ubuntu 20.04(Focal Fossa) Galactic 2021.5 2022.11 Ubuntu 20.04(Focal Fossa) Humble 2022.5 2027.5 Ubuntu 22.04(Jammy Jellyfish) 3 Comparison Of ROS And ROS2 ROS2 redesigned the system architecture. The architecture changes between the two generations of ROS are as follows: OS Layer: In ROS2, it can be built on linux or other systems, even bare metal without an operating system. Middleware Layer: The communication system of ROS1 is based on TCPROS/UDPROS, while the communication system of ROS2 is based on DDS. DDS is a standard solution for data publishing/subscribing in distributed real-time systems. Application Layer: ROS1 relies on ROS Master, while in ROS2, a discovery mechanism called \"Discovery\" is used between nodes to help establish connections with each other. ROS has designed a complete set of communication mechanisms (topics, services, parameters, actions) to simplify robot development. Through this mechanism, the various components of the robot can be connected. This mechanism has designed a node called Ros Master, and the communication of all other components must go through the master node. Once the master node hangs up, it will cause the communication of the entire robot system to collapse! Therefore, the instability of Ros cannot be used to make some high-risk robots such as automatic driving. In addition, there are the following disadvantages: Communication based on TCP has poor real-time performance and high system overhead Unfriendly to python3 support Messaging mechanism is not compatible No encryption mechanism, low security ROS2 first removes the master node that exists in ROS. After removing the master node, each node can discover each other through the DDS node, each node is equal, and can realize one-to-one, one-to-many, and many-to-many communication. After using DDS for communication, reliability and stability have been enhanced. Compared with ROS that only supports Linux systems, ROS2 also supports windows, mac, and even RTOS platforms 4 Moveit2 MoveIt2 Introduction MoveIt2 is an integrated development platform within ROS2. It consists of multiple functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, and collision detection. Core Features Motion Planning MoveIt 2 provides motion planning capabilities based on the Open Motion Planning Library (OMPL) and other third-party libraries, supporting a variety of planning algorithms and constraints. Inverse Kinematics (IK) MoveIt 2 uses a plugin mechanism to support different IK solvers, enabling rapid calculation of the target pose of the robotic arm. Collision Detection & Avoidance MoveIt 2 includes powerful built-in collision detection capabilities to ensure that the robot avoids collisions with its surroundings when planning and executing motions. Dynamic Scene Awareness MoveIt 2 supports dynamic updates of its environment model, enabling real-time perception of obstacle changes. Control & Execution MoveIt 2 provides a motion control interface that tightly integrates with the robot hardware, ensuring accurate execution of planned paths. Visualization Tools Integrated with RViz 2, it supports intuitive interaction and debugging, displaying the motion planning and execution process in real time. Advantages Of MoveIt 2 Real-time Support Based on ROS 2 ROS 2's DDS communication architecture empowers MoveIt 2, significantly improving real-time performance and reliability. Modular Design MoveIt 2 utilizes a modular architecture, allowing users to load or replace modules as needed, providing tremendous flexibility. Cross-Platform Support MoveIt 2 supports running on a variety of operating systems (such as Ubuntu and Windows) and hardware platforms. Active Community Support MoveIt 2 has a global developer community that continuously provides updates, feature extensions, and technical support. Configuration URDF - Universal Robot Description Format. SRDF - Contains the robot's joint groups, virtual and passive joints, robot pose, and self-collision, typically created by the user using the MoveIt2 Setup Assistant. MoveIt2 Configuration - Contains joint limits, kinematics, motion planning, perception, and other information. Configuration files for these components are automatically generated by the MoveIt2 Setup Assistant (MoveIt2 Configuration Assistant) and stored in the configuration directory of the robot's corresponding MoveIt2 configuration package. ← Previous Chapter | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html","title":"6.3.1 EnvironmentSetup","keywords":"","body":"ROS2 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04/22.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing A Virtual Machine Image Applicable Use Case: Using ROS2 or MoveIt2 Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 22.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default password is 123). Built-in Environment: ROS2 humble + MoveIt2 + Git + pymycobot + mycobot_ros2 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox Extension Pack: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux System Image Click to download:Linux ubuntu22.04 3 Import Linux System Image Note: For the import method, please refer to the import method of Ubuntu 20.04 system In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the default password is 123 4 Update Pymycobot To use the latest robotic arm driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update Mycobot_ros2 To ensure users have the latest official packages, navigate to the /home/u22/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/colcon_ws/src # Delete the original mycobot_ros2 package sudo rm -rf mycobot_ros2 git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd # Return to the workspace colcon build # Build the code in the workspace source install/setup.bash # Add environment variables To reduce compilation time, you can compile individual packages. package_name is the specific package name; please modify it accordingly. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash Method 2: Customizing The Installation Environment 1 Virtual Machine Installation Note: When installing the virtual machine system, please install the Ubuntu 20.04 version of the system. The installation method is the same as Ubuntu 18.04. If you want to use the moveIt2 function, you need to install Ubuntu 22.04 version system. To install different versions of Ubuntu systems in Linux, please refer to 6.2 ROS1 Environment Setup section. 2 ROS2 Installation The basic development environment construction requires the installation of the robot operating system ROS2 and the git version manager. The following describes their installation methods and processes respectively. 2.1 Version Selection ROS2 has a one-to-one correspondence with Ubuntu. Different versions of Ubuntu correspond to different versions of ROS2. For reference, see the following website: http://docs.ros.org/en/foxy/Releases.html Here are the ROS2 versions supported by Ubuntu: ROS2 version Release date Maintenance deadline Ubuntu version Foxy June 5, 2020 May 2023 Ubuntu 20.04(Focal Fossa) Galactic May 23, 2021 November 2022 Ubuntu 20.04(Focal Fossa) Humble May 23, 2022 May 2027 Ubuntu 22.04(Jammy Jellyfish) Please install the corresponding ROS2 version according to the Ubuntu version you installed, moveIt2 only supports the humble version If the versions are different, the download will fail. Here we choose Ubuntu 20.04 (recommended), and the corresponding ROS2 version is ROS2 Foxy NOTE: Currently we do not provide any reference for installing ROS2 on Windows. If necessary, please refer to http://docs.ros.org/en/foxy/Installation/Alternatives/Windows-Development-Setup.html 2.2 Start Installation 1 Add Source There is no ROS2 in the software source list of Ubuntu itself Software source, so you need to first configure the ROS2 software source to the software list warehouse before you can download ROS2. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Huawei Cloud is: echo \"deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 2 Set The key Configure the public network key, this step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt install curl gnupg2 -y curl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add - 3 Installation After adding the new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute install ROS2, open a console terminal (shortcut key Ctrl+Alt+T), please enter the following command according to your Ubuntu version: # Ubuntu 20.04 foxy version sudo apt install ros-foxy-desktop # Ubuntu 20.04 galactic version sudo apt install ros-galactic-desktop # Ubuntu 22.04 humble version sudo apt install ros-humble-desktop The installation process takes a long time, please wait patiently After the installation is complete, refresh the environment variables: source /opt/ros/foxy/setup.bash 2.3 Set Up The Ros2 Environment In order to avoid the need to re-validate the ROS2 function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS2 function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence, open a console terminal (shortcut key Ctrl+Alt+T) and execute the following commands: # Ubuntu 20.04 foxy version # Add the ros environment to the environment variables of the current console echo \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc # Ubuntu 20.04 galactic version echo \"source /opt/ros/galactic/setup.bash\" >> ~/.bashrc # Ubuntu 22.04 humble version echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc source ~/.bashrc 2.4 Install ROS2 Additional Dependencies Enter the following command in the terminal Install ROS2 additional dependencies, open a console terminal (shortcut Ctrl+Alt+T): sudo apt install python3-argcomplete -y sudo apt install ros-foxy-xacro sudo apt-get install python3-colcon-common-extensions # Ubuntu 20.04 foxy version sudo apt install ros-foxy-joint-state-publisher-gui # Ubuntu 20.04 galactic version sudo apt install ros-galactic-joint-state-publisher-gui # Ubuntu 22.04 humble version sudo apt install ros-humble-joint-state-publisher-gui sudo apt install ros-humble-xacro 2.5 Verify Installation To verify ROS2 To check whether the installation is successful, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: ros2 When the following interface is displayed, it means that ROS2 is installed successfully 3 MoveIt2 Installation Note: Only the installation method for Ubuntu 22.04 is provided here MoveIt2 is a functional package of a series of mobile operations in ros2, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 3.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt update 3.2 Install MoveIt2 sudo apt-get install ros-humble-moveit sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-joint-trajectory-controller ros-humble-joint-state-broadcaster 4 Git Installation 4.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 4.2 Installation Git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 4.3 Verify Installation Read git version, open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, which means the installation is successful. 5 Mycobot_ros2 Installation mycobot_ros2 is a ROS2 package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. Project address: http://github.com/elephantrobotics/mycobot_ros2 5.1 Prerequisites Before installing the package, please ensure that you have a ros2 workspace. Here we give sample commands for creating a workspace. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/colcon_ws/src # Create a folder Add workspace environment The official default ROS2 workspace is colcon_ws. echo \"source ~/colcon_ws/install/setup.bash\" >> ~/.bashrc source ~/.bashrc 5.2 Installation NOTE: This package depends on ROS2 and MoveIT2. Make sure to install ROS2 and MoveIT2 successfully before using it. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. Please download the code from different branches depending on your ROS2 version: Ubuntu 20.04 / ROS2 Foxy - branch foxy Ubuntu 20.04 / ROS2 Galactic - branch galactic Ubuntu 22.04 / ROS2 Humble - branch humble The official default ROS2 workspace is colcon_ws. cd colcon_ws/src # Enter the src folder in the workspace # For the humble branch git clone -b humble --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the foxy branch git clone -b foxy --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the galactic branch git clone -b galactic --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd .. # Return to the workspace colcon build --symlink-install # Build the code in the workspace. --symlink-install: Avoids recompiling every time you modify the Python script. source install/setup.bash # Add environment variables To reduce compilation time, you can compile a certain package separately, where package_name is the name of the specific package. Please modify it according to your actual situation. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash This completes the ROS2 environment setup. For more information on using ROS2, please refer to ROS2 Basics or ROS2 Basic Functions. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html","title":"6.3.2 ROS2Basics","keywords":"","body":"1 ROS2 Project Structure 1.1 Colcon Workspace The colocn workspace is the directory where software packages are created, modified, and compiled. Colcon's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/colcon_ws/src # Create folder cd ~/colcon_ws/ # Enter the folder colcon build # Build the code in the workspace. Note: colcon supports option --symlink-install. This allows for faster iteration by changing installed files by changing files in the source space (such as Python files or other uncompiled resources). Avoid the need to recompile every time you modify your python script. colcon build --symlink-install A ROS workspace is a directory with a particular structure. Commonly there is a src subdirectory. Inside that subdirectory is where the source code of ROS packages will be located. Typically the directory starts otherwise empty. colcon does out of source builds. By default it will create the following directories as peers of the src directory: src/: colcon package for ROS2 (source code package) build/: The location where intermediate files are stored. For each package, a subfolder is created in which CMake is called, for example. install/: The installation location of each package. By default, each package will be installed into a separate subdirectory. log/: Contains various logging information about each colcon call. The directory structure of a ROS2 workspace is as follows: WorkSpace --- Customized workspace. |--- build: The directory where intermediate files are stored. A separate subdirectory will be created for each function package in this directory. |--- install: Installation directory, a separate subdirectory will be created for each function package in this directory. |--- log: Log directory, used to store log files. |--- src: Directory used to store function package source code. |-- C++ function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- CMakeLists.txt: Configure compilation rules, such as source files, dependencies, and target files. |-- src: C++ source file directory. |-- include: header file directory. |-- msg: message interface file directory. |-- srv: Service interface file directory. |-- action: action interface file directory. |-- Python function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- setup.py: similar to CMakeLists.txt of C++ function package. |-- setup.cfg: Function package basic configuration file. |-- resource: resource directory. |-- test: stores test-related files. |-- Directory with the same name of the function package: Python source file directory. 1.2 ROS2 Package Package is not only a software package on Linux, but also the basic unit of colcon compilation. The object we use colcon build to compile is each ROS2 package. Create your own package: The command syntax for creating a software package using Python is: ros2 pkg create --build-type ament_python For example: ros2 pkg create --build-type ament_python --node-name my_node my_package 2 Basic Tool Commands In this chapter, you will learn about the common command tools of ROS2. 2.1 Topics ROS 2 breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system. Specific reference: Official Tutorials topics help ros2 topics -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Node Relationship Diagram rqt_graph Learn about topic-related commands ros2 topics -h topics list ros2 topic list ros2 topic list -t # Display the corresponding message type View topic content ros2 topic echo ros2 topic echo /turtle1/cmd_vel Display topic-related information, type ros2 topic info # Output /turtle1/cmd_vel topic related information ros2 topic info /turtle1/cmd_vel Display interface related information ros2 interface show # Output geometry_msgs/msg/Twist interface related information ros2 interface show geometry_msgs/msg/Twist Issue an order ros2 topic pub '' # Issue speed command ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" # Issue speed commands at a certain frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" See how often topics are posted ros2 topic hz # Output /turtle1/cmd_vel publish frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 2.2 Nodes Each node in ROS should be responsible for a single, module purpose (e.g. one node for controlling wheel motors, one node for controlling a laser range-finder, etc). Each node can send and receive data to other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes. Specific reference: Official Tutorials nodes help ros2 nodes -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the node list ros2 node list View Node Relationship Diagram rqt_graph Remapping ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle ros2 node list View node information ros2 node info ros2 node info /my_turtle 2.3 Services Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model, versus topics’ publisher-subscriber model. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Specific reference: Official Tutorials services help ros2 service -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the service list ros2 service list # Display service list and message type ros2 service list -t View the message types received by the service ros2 service type ros2 service type /clear Find services that use a certain message type ros2 service find ros2 service find std_srvs/srv/Empty View Service Message Type Definitions ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv Call the service command to clear the walking track ros2 service call ros2 service call /clear std_srvs/srv/Empty Spawn a new turtle ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: 'turtle2'}\" 2.4 Parameters A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS 2, each node maintains its own parameters. For more background on parameters, please see the concept document. Specific reference: Official Tutorials parameters help ros2 param -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View service list ros2 param list Get the parameter value ros2 param get ros2 param get /turtlesim background_g Set parameter values ros2 param set ros2 param set /turtlesim background_r 150 Export parameter values ros2 param dump ros2 param dump /turtlesim Import parameters independently ros2 param load ros2 param load /turtlesim ./turtlesim.yaml Start the node and import parameters at the same time ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 2.5 Actions Actions are one of the communication types in ROS 2 and are intended for long running tasks. They consist of three parts: a goal, feedback, and a result. Actions are built on topics and services. Their functionality is similar to services, except actions are preemptable (you can cancel them while executing). They also provide steady feedback, as opposed to services which return a single response. Actions use a client-server model, similar to the publisher-subscriber model (described in the topics tutorial). An “action client” node sends a goal to an “action server” node that acknowledges the goal and returns a stream of feedback and a result. Specific reference: Official Tutorials action help ros2 action -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Press G|B|V|C|D|E|R|T to achieve rotation, press F to cancel View the server and client of the node action ros2 node info /turtlesim View action list ros2 action list ros2 action list -t # show action type view action info ros2 action info ros2 action info /turtle1/rotate_absolute View action message content ros2 interface show turtlesim/action/RotateAbsolute Send action target information ros2 action send_goal ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" # With feedback information ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" --feedback 2.6 RQt RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout. Specific reference: Official Tutorials You can run any RQt tools/plugins easily by: rqt rqt help rqt -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Action Type Browser: / Plugins -> Actions ->Action Type Browser parameter reconfiguration: / Plugins -> configuration ->Parameter Reconfigure Node grap: /Node Graph control steering: /Plugins -> Robot Tools -> Robot Steering service invocation: /Plugins -> Services -> Service Caller Service Type Browser: Plugins -> Services -> Service Type Browser message release: Plugins -> Topics -> Message Publisher Message Type Browser: Plugins -> Topics -> Message Type Browser topic list: Plugins -> Topics -> Topic Monitor draw a graph: Plugins -> Visualization -> Plot View logs: rqt_console ros2 run rqt_console rqt_console ros2 run turtlesim turtlesim_node ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}\" 2.7 TF2 tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time. Specific reference: Official Tutorials Let’s start by installing the demo package and its dependencies. sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations follow launch starts 2 little turtles, the first little turtle automatically follows the second one ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py Control the movement of the first little turtle through the keyboard ros2 run turtlesim turtle_teleop_key View TF tree ros2 run tf2_tools view_frames.py evince frames.pdf View the relationship between two coordinate systems ros2 run tf2_ros tf2_echo [reference_frame] [target_frame] ros2 run tf2_ros tf2_echo turtle2 turtle1 View TF relationships on rviz ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz 2.8 URDF URDF is the Unified Robot Description Format for specifying robot geometry and organization in ROS. Specific reference: Official Tutorials 部分代码示例 It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. link section The link element describes a rigid body with inertial, visual features, and collision properties, the name is used to describe the name of the link itself, as follows: (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view joint part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint.Name is a unique name for the specified joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. elements of joint: (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. Install dependent libraries sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher sudo apt install ros-foxy-xacro Download the source code cd ~/dev_ws git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial Compiling the source code colcon build --packages-select urdf_tutorial Running the example ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf 2.9 Launch The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described. The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration. It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes. Launch files written in Python, XML, or YAML can start and stop different nodes as well as trigger and act on various events. Specific reference: Official Tutorials Setup Create a new directory to store your launch files: mkdir launch Writer the launch file Let’s put together a ROS 2 launch file using the turtlesim package and its executables. As mentioned above. Copy and paste the complete code into the launch/turtlesim_mimic_launch.py file: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package='turtlesim', namespace='turtlesim1', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', namespace='turtlesim2', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', executable='mimic', name='mimic', remappings=[ ('/input/pose', '/turtlesim1/turtle1/pose'), ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) Run the ros2 launch file To run the launch file created above, enter into the directory you created earlier and run the following command: The syntax format is: ros2 launch cd launch ros2 launch turtlesim_mimic_launch.py launch help ros2 launch -h running node ros2 launch turtlesim multisim.launch.py Check the parameters of the launc file ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments ros2 launch turtlebot3_bringup robot.launch.launch.py -s Run the launch file with parameters ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr Run the node and debug ros2 launch turtlesim turtlesim_node.launch.py -d Only output node description ros2 launch turtlesim turtlesim_node.launch.py -p running components ros2 launch composition composition_demo.launch.py 2.10 Run run is used to run a single node, component program run help ros2 run -h running node ros2 run turtlesim turtlesim_node Run node with parameters ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2 Run component container ros2 run rclcpp_components component_container running components ros2 run composition manual_composition 2.11 Package A package can be considered a container for your ROS 2 code. If you want to be able to install your code or share it with others, then you’ll need it organized in a package. With packages, you can release your ROS 2 work and allow others to build and use it easily. Package creation in ROS 2 uses ament as its build system and colcon as its build tool. You can create a package using either CMake or Python, which are officially supported, though other build types do exist. Specific reference: Official Tutorials Creating a workspace Create a new directory for every new workspace. The name doesn’t matter, but it is helpful to have it indicate the purpose of the workspace. Let’s choose the directory name ros2_ws, for “development workspace”: mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src pkg help ros2 pkg -h List Feature Packs ros2 pkg executable turtlesim Output a function package executable program ros2 pkg executable turtlesim Create a Python package Make sure you are in the src folder before running the package creation command. cd ~/ros2_ws/src The command syntax for creating a new package in ROS 2 is: ros2 pkg create --build-type ament_python # you will use the optional argument --node-name which creates a simple Hello World type executable in the package. ros2 pkg create --build-type ament_python --node-name my_node my_package Build a package Putting packages in a workspace is especially valuable because you can build many packages at once by running colcon build in the workspace root. Otherwise, you would have to build each package individually. # Return to the root of your workspace: cd ~/ros2_ws # Now you can build your packages: colcon build Source the setup file To use your new package and executable, first open a new terminal and source your main ROS 2 installation. Then, from inside the ros2_ws directory, run the following command to source your workspace: source install/setup.bash Now that your workspace has been added to your path, you will be able to use your new package’s executables. Use the package To run the executable you created using the --node-name argument during package creation, enter the command: ros2 run my_package my_node ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html","title":"6.3.3 Rivz2Use","keywords":"","body":"Brief Introduction And Use Of Rviz2 Rviz2 is a visualization tool for displaying messages in the robot environment, providing a 3D perspective to view the robot's status and activities. It can help developers better understand the current status and activities of the robot, as well as other visual messages. Rviz2 provides a series of visualization tools that can help developers better understand the status and activities of robots, such as visual coordinate systems, laser scanning messages, point cloud messages, robot models, etc. Using Rviz2, robotic systems can be easily viewed and debugged to better achieve robotic goals. 1 Introduction To Rviz2 The successful installation of ros2 indicates that rviz2 is also successfully installed together, because the installation of ros2 includes rviz2. Open a new terminal (shortcutCtrl+Alt+T)enter the command to open rviz2 ros2 run rviz2 rviz2 # 或 rviz2 Open rviz2 and display the following interface: Introduction of each area On the left is the list of monitors, a monitor is something that draws something in the 3D world and may have some options available in the display list. Including functions such as adding, deleting, copying, renaming plug-ins, displaying plug-ins, and setting plug-in properties. Above is the toolbar, which allows users to use various function buttons to select tools with multiple functions The middle part is the 3D view: it is the main screen where various data can be viewed in 3D. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area, and different observation angles can be set. We only give a rough introduction in this part. If you want to know more detailed content, you can go to the user guide to view it. 2 Simple Use Launch through launch file This example is based on the fact that you have completed Environment Setup and successfully copied the company's code from GitHub. Open a console terminal (shortcut key Ctrl+Alt+T) Enter the following command to configure ROS2 environment. cd ~/colcon_ws/ colcon build --symlink-install source install/setup.bash Enter again: ros2 launch mycobot_pro_450 test.launch.py Open rviz2 and get the following result: If you want to know more information about rviz, you can go to the official documentation to view it. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html","title":"6.3.4 BasicFunctionCases","keywords":"","body":"Controlling The Robotic Arm Note: The pymycobot driver library version must be greater than 4.0.0. Moveit2 only supports the ROS2 Humble version. Please use the code from the corresponding branch. Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 1 Slider Control Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 slider_control.launch.py # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 slider_control_force_gripper.launch.py This will open rviz2 and a slider component, and you will see something like the following: If the end-user is equipped with a myGripper F100 force-controlled gripper, you will see the following interface: You can then control the model's movement in rviz2 by dragging the slider. The real mycobot will also move accordingly. Note: Since the robot arm will move to the model's current position as you enter commands, please ensure that the model in rviz does not clip before using these commands. Avoid dragging the slider quickly after connecting the robot arm to prevent damage to the arm. 2 Model Following In addition to the above controls, we can also make the model follow the movements of the real robot arm. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 mycobot_follow.launch.py After running successfully, all joints of the robot arm are released. It will also open rviz to display the model following effect. Now, drag the real robot arm joints, and the simulation model will follow the real robot arm's movements. After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [12048] [INFO] [follow_display-2]: process started with pid [12050] [INFO] [rviz2-3]: process started with pid [12052] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757408024.256520696] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757408024.256679159] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757408024.256692374] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757408024.256697373] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757408024.256701681] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757408024.256705999] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757408024.256710327] [robot_state_publisher]: got segment link6 [rviz2-3] [INFO] [1757408024.565241287] [rviz2]: Stereo is NOT SUPPORTED [rviz2-3] [INFO] [1757408024.565493504] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-3] [INFO] [1757408024.647227371] [rviz2]: Stereo is NOT SUPPORTED [follow_display-2] [INFO] [1757408024.783281010] [follow_display]: ip:192.168.0.232, port:4500 [rviz2-3] Parsing robot urdf xml string. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]: Please press the button at the end of the machine to drag the joint. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]:请按下机器末端按钮进行关节拖拽运动 [follow_display-2] [INFO] [1757408024.937815658] [follow_display]: Publishing ... 3 GUI Control Building on the previous functionality, this package also provides a simple graphical user interface. This approach requires that the actual robotic arm be connected to each other; please connect to mycobot. Open a command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 simple_gui.launch.py # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 simple_gui_force_gripper.launch.py If the end-device is equipped with a myGripper F100 force-controlled gripper, you will see the following interface: After successful execution, the terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [17196] [INFO] [rviz2-2]: process started with pid [17198] [INFO] [listen_real_service-3]: process started with pid [17200] [INFO] [simple_gui-4]: process started with pid [17202] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757414162.529535554] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757414162.530006477] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757414162.530445098] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757414162.530788098] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757414162.531159021] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757414162.531476222] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757414162.531788353] [robot_state_publisher]: got segment link6 [listen_real_service-3] [INFO] [1757414163.139592125] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] [INFO] [1757414163.306409248] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757414163.306709577] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757414163.372621603] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] Parsing robot urdf xml string. Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, and is synchronized in real time within rviz2. This functionality relies on the Python API, so ensure that it is connected to the real robot arm. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 teleop_keyboard.launch.py # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 teleop_keyboard_force_gripper.launch.py The following display appears: If the end-device is equipped with a myGripper F100 force-controlled gripper, the following interface appears: The command line will output the following information about mycobot: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [13684] [INFO] [rviz2-2]: process started with pid [13686] [INFO] [listen_real_service-3]: process started with pid [13688] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757409378.488848950] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757409378.489029099] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757409378.489038676] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757409378.489043355] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757409378.489047552] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757409378.489051760] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757409378.489055988] [robot_state_publisher]: got segment link6 [rviz2-2] [INFO] [1757409378.801155196] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757409378.801390966] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757409378.860460962] [rviz2]: Stereo is NOT SUPPORTED [listen_real_service-3] [INFO] [1757409379.155013599] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] Parsing robot urdf xml string. Next, open another command line: ros2 run mycobot_pro_450 teleop_keyboard # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 run mycobot_pro_450 teleop_keyboard_force_gripper You will see the following output in the terminal: Mycobot Teleop Keyboard Controller --------------------------- Movimg options(control coordinations [x,y,z,rx,ry,rz]): w(x+) a(y-) s(x-) d(y+) z(z-) x(z+) u(rx+) i(ry+) o(rz+) j(rx-) k(ry-) l(rz-) +/- : Increase/decrease movement step size Force Gripper control: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Resave home pose q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot arm's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. 5 Moveit2 Use Note: Moveit2 only supports the ROS2 Humble version. Please use the corresponding branch to run the code. mycobot_ros2 integrates the MoveIt component. Open a command line and run: ros2 launch pro450_moveit2 demo.launch.py The result is as follows: The terminal will output the following message, indicating that Moveit has been successfully launched: [move_group-3] You can start planning now! [move_group-3] [ros2_control_node-5] [INFO] [1757486383.454753341] [controller_manager]: Loading controller 'joint_state_broadcaster' [rviz2-4] [INFO] [1757486383.456108372] [rviz2]: Stereo is NOT SUPPORTED [spawner-7] [INFO] [1757486383.502228729] [spawner_joint_state_broadcaster]: Loaded joint_state_broadcaster [spawner-6] [INFO] [1757486383.564310311] [spawner_arm_group_controller]: Configured and activated arm_group_controller [rviz2-4] Warning: class_loader.impl: SEVERE WARNING!!! A namespace collision has occurred with plugin factory for class rviz_default_plugins::displays::InteractiveMarkerDisplay. New factory will OVERWRITE existing one. This situation occurs when libraries containing plugins are directly linked against an executable (the one running right now generating this message). Please separate plugins out into their own library or just don't link against the library and use either class_loader::ClassLoader/MultiLibraryClassLoader to open. [rviz2-4] at line 253 in /opt/ros/humble/include/class_loader/class_loader/class_loader_core.hpp [ros2_control_node-5] [INFO] [1757486383.610227041] [controller_manager]: Configuring controller 'joint_state_broadcaster' [ros2_control_node-5] [INFO] [1757486383.610628892] [joint_state_broadcaster]: 'joints' or 'interfaces' parameter is empty. All available state interfaces will be published [spawner-7] [INFO] [1757486383.736878229] [spawner_joint_state_broadcaster]: Configured and activated joint_state_broadcaster [INFO] [spawner-6]: process has finished cleanly [pid 100700] [INFO] [spawner-7]: process has finished cleanly [pid 100703] [rviz2-4] [ERROR] [1757486386.668318057] [moveit_ros_visualization.motion_planning_frame]: Action server: /recognize_objects not available [rviz2-4] [INFO] [1757486386.684028956] [moveit_ros_visualization.motion_planning_frame]: MoveGroup namespace changed: / -> . Reloading params. [rviz2-4] [INFO] [1757486386.975209646] [moveit_rdf_loader.rdf_loader]: Loaded robot model in 0.105952 seconds [rviz2-4] [INFO] [1757486386.975348906] [moveit_robot_model.robot_model]: Loading robot model 'firefighter'... [rviz2-4] [INFO] [1757486387.253639370] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Starting planning scene monitor [rviz2-4] [INFO] [1757486387.255326862] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Listening to '/monitored_planning_scene' [rviz2-4] [INFO] [1757486387.353487213] [interactive_marker_display_104041531794736]: Connected on namespace: /rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic [rviz2-4] [INFO] [1757486387.358813947] [moveit_ros_visualization.motion_planning_frame]: group arm_group [rviz2-4] [INFO] [1757486387.358844123] [moveit_ros_visualization.motion_planning_frame]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [rviz2-4] [INFO] [1757486387.372219842] [move_group_interface]: Ready to take commands for planning group arm_group. [rviz2-4] [INFO] [1757486387.404744042] [interactive_marker_display_104041531794736]: Sending request for interactive markers [rviz2-4] [INFO] [1757486387.463143847] [interactive_marker_display_104041531794736]: Service response received for initialization Basic path planning operations are as follows: If you want to synchronize the plan with the actual robot arm, you need to open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 run pro450_moveit2_control sync_plan Modifying the Movement Speed To prevent joints from shaking during actual robot arm movement, you need to reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robotic arm Python API to 25. Note: After changing the speed, you need to recompile for it to take effect: cd ~/colcon_ws source install/setup.bash ... def listener_callback(self, msg): \"\"\"Callback to process received joint states. Converts joint positions from radians to degrees, rearranges them according to the RViz order, and sends them to the robot. Args: msg (JointState): The message containing joint names and positions. \"\"\" # Create a mapping of joint names to their position values joint_state_dict = {name: msg.position[i] for i, name in enumerate(msg.name)} # Rearrange joint angles according to RViz order data_list = [] for joint in self.rviz_order: if joint in joint_state_dict: radians_to_angles = round( math.degrees(joint_state_dict[joint]), 2) data_list.append(radians_to_angles) self.get_logger().info(f'joint_angles: {data_list}') self.mycobot_450.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. Here, change it to 0.1 and save the current configuration. ← Previous Page | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.5-Troubleshooting.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.5-Troubleshooting.html","title":"6.3.5 CommonProblemsAndSolutions","keywords":"","body":"ROS1 Common Problems and Solutions When using ROS1 to control the MyCobot Pro 450, you may encounter some common problems. Below is a list of common errors and their corresponding solutions for quick troubleshooting. 1 Environment-Related Issues Issue 1: Running ros2 launch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/colcon_ws colcon build source install/setup.bash 2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the ros2 launch command is complete In the terminal, enter: ros2 param list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz2-2] rviz2-2 at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control "},"3-FunctionsAndApplications/6.developmentGuide/6.4-Cplus/README1.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.4-Cplus/README1.html","title":"6.4 C++","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.5-CommunicationProtocolPackage/6.5-communication1.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.5-CommunicationProtocolPackage/6.5-communication1.html","title":"6.5 SerialCommunicationProtocol","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/7.SuccessfulCase/":{"url":"3-FunctionsAndApplications/7.SuccessfulCase/","title":"7. SuccessfulCases","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/":{"url":"3-FunctionsAndApplications/8.SupportingResources/","title":" 8. SupportingResources","keywords":"","body":"Chapter 8 Supporting Resources This chapter will introduce various supporting resources of the product in detail, aiming to help users fully understand and use our products efficiently. Whether it is product information, drawings, software information and source code, or system information and promotional materials, we provide detailed information and download links to ensure that users can make full use of these resources for product development, operation and promotion Download Product Information The product information includes detailed specifications, technical parameters and instructions for use of the mycobot pro 450 robot arm. This section aims to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Product Drawings The product drawings section provides detailed 3D and 2D drawings of the mycobot pro 450 robot arm. These drawings are particularly important for engineers who need to perform customized designs or maintenance, and can help them better understand the structure of the robot arm. System Information The system information provides the system architecture and working principle of the mycobot pro 450 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system Promotional Materials The promotional materials section contains the product brochure, demonstration video and customer cases of the mycobot pro 450 robot. These materials not only show the core advantages and application scenarios of the robot, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/","title":"8.1 ProductInformation","keywords":"","body":"Product Information Download The product information includes detailed specifications, technical parameters and instructions for use of the mycobot pro 450 robot arm. This section is designed to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Download Link You can download all relevant product information through the following link: Product Information Download ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/","title":"8.2 ProductDrawings","keywords":"","body":"Product Drawings The product drawings section provides detailed 3D and 2D drawings of the mycobot pro 450 robot. These drawings are particularly important for engineers who need to make customized designs or perform maintenance, and can help them better understand the structure of the robot. Machine 3D Model Machine 3D Model File mycobot pro 450 Download Machine 2D Drawings Machine Machine 2D Drawings myCobot Pro 450 DH Download myCobot Pro 450 Atom Download myCobot Pro 450 Base Download Accessories 3D Models myCobot Series Accessories 3D Model Files myGripperF100 Download PneumaticGripper Download AdaptiveGripper Download PhoneHolderPro Download ModuleSuctionCup Download CameraModulePro Download PenHolderPro Download ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.3-SystemInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.3-SystemInformation/","title":"8.3 SystemInformation","keywords":"","body":"System Information The system information provides the system architecture and working principle of the mycobot pro 450 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system (Information to be updated) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.4-PromotionalMaterials/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.4-PromotionalMaterials/","title":"8.4 PromotionalMaterials","keywords":"","body":"Promotional Materials The promotional materials section includes the product brochure, demonstration video and customer cases of the mycobot pro 450 robot arm. These materials not only show the core advantages and application scenarios of the robot arm, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. Machine Product Brochure mycobot pro 450 Download Product unboxing video !Video in progress Product promotion video !Video in progress User Case !Video in progress ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/9.AboutUs/9.AboutUs.html":{"url":"4-SupportAndService/9.AboutUs/9.AboutUs.html","title":"9 ContactUs","keywords":"","body":"Elephant Robotics 1. Company Introduction Based in Shenzhen, China, Elephant Robotics is a high-tech enterprise focusing on robot R&D, design and automation solutions. We are committed to providing highly flexible collaborative robots, easy-to-learn operating systems and intelligent automation solutions for robot education and scientific research institutions, commercial scenarios and industrial production. Its product quality and smart solutions have been unanimously recognized and praised by several factories from the world's top 500 companies in South Korea, Japan, the United States, Germany, Italy, Greece and other countries. Elephant Robotics adheres to the vision of \"Enjoy Robots World\" and advocates the collaborative work of people and robots, making robots a good helper for human work and life, helping people to be liberated from simple, repetitive and boring work, giving full play to the advantages of human-machine collaboration, thereby improving work efficiency and helping humans create a better new life. In the future, Elephant Robotics hopes to promote the development of the robot industry through a new generation of cutting-edge technology, and work with customers and partners to open a new era of automation and intelligence. 2. Development History 2016.08 -----Elephant Robotics Co., Ltd. was officially established 2016.08 -----Entered HAX incubator and received seed round investment from SOSV 2016.08 -----Started research and development of Elephant S industrial collaborative robot 2017.01 -----Rated as \"Top 10 Most Innovative Companies in China at CES\" 2017.04 -----Attended Hannover Industrial Fair and Korea Automation Exhibition 2017.07 -----Two founders were selected as \"30 Business Elites Under 30\" by Forbes Asia 2017.10 -----The fifth-generation single-arm industrial collaborative robot Elephant S was launched 2018.04 -----Received angel round investment from \"Yun Angel Fund\" 2018.06 -----First public appearance 2018 Hannover World Industrial Fair 2018.06 -----Won the \"Smart Manufacturing Entrepreneurship MBA Award\" from Cheung Kong Graduate School of Business 2018.06 -----Won the \"Entrepreneurship Accelerator X-elerator Award\" from Tsinghua School of Economics and Management 2018.11 -----Won the second place in the Shenzhen Division of the Asian Smart Hardware Competition 2018.11 -----Won the \"Most Investment Enterprise Award\" of the Gaogong Golden Globe Award 2019.03 -----Won the \"Leadership Award\" of the Gaogong Golden Globe Award 2019.04 -----In March 2019, Catbot won the \"Industrial Robot Innovation Award\" 2019.09 -----Attended the Huawei European Ecosystem Conference (HCE) and officially became a member of Huawei's ecological partner 2019.11 -----Elephant Robotics and Harbin Institute of Technology attended the IROS International Intelligent Robots and Systems Conference 2019.12 -----Elephant Robotics-South China University of Technology \"Intelligent Robot Joint Development Laboratory\" was officially unveiled 2019.12 -----Won the \"Innovation Technology Award\" of Gaogong in 2019 2019.12 -----Won the \"Top Ten Fast-Growing Enterprises\" of Gaogong in 2019 2019.12 -----Won the \"New Enterprise Award\" in the Industrial Robot Segment of Shenzhen Equipment Industry 2019.12 -----The world's first bionic robot cat MarsCat was launched 2020.05 -----The founder won the 2019 Shenzhen Robotics Newcomer Award 2020.10 -----The world's lightest and smallest six-axis collaborative robot myCobot was launched 2021.03 -----The smallest collaborative robot for scientific research myCobotPro 320 was launched 2021.05 -----Mars bionic cat MarsCat Received coverage from Xinhua Finance, China Daily, Nanjing Daily, Harbin Daily and other media 2021.07 -----Released the smallest composite robot chassis - Elephant Mobile Robot myAGV 2021.09 -----The world's first fully enclosed four-axis robotic arm - Elephant palletizing robotic arm myPalletizer was launched 3. Related links Purchase link Taobao: https://shop504055678.taobao.com Shopify: https://shop.elephantrobotics.com/ AliExpress: https://elephantrobotics.aliexpress.com/store/1101941423Other information Official website: https://www.elephantrobotics.com Video Bilibili: https://space.bilibili.com/2126215657 Youtube: https://www.youtube.com/c/Elephantrobotics Facebook: https://www.facebook.com/mycobotcreator/ Linkedin: https://www.linkedin.com/company/18319865 X (Twitter): https://twitter.com/CobotMy Discord: https://discord.gg/2MAherp7nt Hackster: https://www.hackster.io/elephant-robotics 4. Contact Us Our working hours are China working days, 10 am to 6 pm Beijing time. If you have any other questions, please contact us via the following methods. E-mail : support@elephantrobotics.com - If you have any purchase intention or any parameter questions, please send an email to this mailbox. [E-mail](sales@elephantrobotics.com) : sales@elephantrobotics.com If you encounter any problems in the use of this product, please read Chapter 9 of the manual first. If the problems listed cannot help you solve them, and you have more after-sales problems, please send an email to this mailbox. E-mail : support@elephantrobotics.com We will respond within 1-2 working days; WeChat: We only provide one-to-one service for users who purchase mycobot products through WeChat. ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/accessories.html":{"url":"4-SupportAndService/Accessories/accessories.html","title":"10 Accessories","keywords":"","body":"Product Accessories In the real world, different accessories can enhance the capabilities of robots in various ways. For example, accessories such as grippers, sensors, and tools can help robots perform various tasks, thereby increasing their versatility and flexibility. Elephant Robotics is committed to making robots and these accessories easy for everyone to use, freeing users from the complexity of choosing the right accessories and enabling them to quickly start using robots. Accessory Types In order to meet the needs of customers in different scenarios, we have designed various types of accessories, including grippers, suction cups, camera modules, and other gripping devices, so that users can directly choose the right end effector Gripper myGripper F100 Pneumatic Gripper Adaptive Gripper Suction Pumps Single Suction Pump Vacuum Suction Cups Holder Pen Holder Phone Holder Other functional accessories Camera Module Pro 3D Camera ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.1-myGripperF100.html":{"url":"4-SupportAndService/Accessories/10.1-myGripperF100.html","title":"10.1 MyGripperF100","keywords":"","body":"myGripper F100 Force-controlled Gripper 1 Product Image 2 Specifications Name myGripper F100 force-controlled gripper Material PC, PBT Dimensions 156X106X61mm Process technology Injection molding Gripping range 0-100 mm (default fingertip) Repeatability 0.5 mm Service life 300,000 openings and closings Drive mode Electric drive Transmission mode Gear + connecting rod Dimensions 158x105x55mm Weight 340 g Rated load 500g Working voltage 24V Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface RS485/IO control/button control Applicable equipment ER myCobot 320 series, ER Mercury series, ER myCobot Pro 600, ERmyCobot Pro 630, other general robots, ER myCobot Pro 450 3 Working Principle Driven by the motor, the finger surface of the manipulator makes linear reciprocating motion to achieve opening or closing. By setting the clamping torque, the impact of the workpiece is minimized, the positioning point is controllable, and the clamping is controllable. 4 Usage Scenario Experimental operation: In scientific research experiments, complete the grasping and moving of test tubes, utensils, etc. to ensure the safety and accuracy of the experiment. Educational demonstration: As a teaching tool, it helps students understand the principle of robot grasping and cultivate practical ability. Material handling: In simulated production lines or warehouses, materials of various specifications are handled to improve work efficiency. 5 Installation Method Use screws and washers to install the gripper connector to the end flange of the robot arm Then use screws to install the gripper on the connector Finally, use M8 aviation wire to connect the gripper and the robot arm 6 Python Control Method Based On 450 Terminal IO Control The IO control method can only control the gripper to fully open and close from pymycobot import ElephantRobot import time mc=ElephantRobot(\"192.168.1.159\",5001) mc.start_client() def gripper_open(): mc.set_digital_out(16,0) mc.set_digital_out(17,1) def gripper_close(): mc.set_digital_out(16,1) mc.set_digital_out(17,0) if __name__==\"__main__\": gripper_open() time.sleep(2) gripper_close() time.sleep(2) Control Based On USB tTo 485 Module Note: To control the gripper in this way, you need to connect one end of the M8 aviation cable connected to the gripper to the USB to 485 module. That is, one end of the M8 aviation cable with a plug is connected to the gripper, and the other end is connected to the USB to 485 module and the 24V power supply. Wiring instructions: Connect the 24V, GND, 485_A (T/R+, 485+), 485_B (T/R-, 485-) wires at the end of the gripper, a total of 4 wires, the power supply is a 24V DC regulated power supply or the 24V of the IO at the bottom of the 450, insert the USB port of the module into the USB port of the computer 485A connects to the 485 to USB module A+; 485B connects to the 485 to USB module B-; 24V connects to 24V DC regulated power supply positive pole/24V of IO at the bottom of 450; GND connected to 24V DC regulated power supply negative pole/GND of IO at the bottom of 450 Driver library installation Click to download the driver library Serial Port Dependency Library Installation Execute the following command in the computer terminal to install the dependency library pip install pyserial API Description get_firmware_version() Function: Get the main version number of the gripper firmware Parameter: None Return: (int) Firmware main version number get_modified_version() Function: Get the sub-version number of the gripper firmware Parameter: None Return: (int) Firmware sub-version number get_gripper_Id() Function: Get the gripper ID Parameter: None Return: (int) Gripper ID get_gripper_baud() Function: Get the baud rate of the gripper Parameter: None Return:(int) 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 get_gripper_value() Function: Get the current position data of the gripper Parameter: None Return: (int) The current position data of the gripper get_gripper_status() Function: Get the current status of the gripper Parameter: None Return:(int) 0-3 0: Moving 1: Stopped moving, no object was detected 2: Stopped moving, object was detected 3: After detecting that the object is clamped, the object falls get_gripper_speed() Function: Get the current speed of the gripper Parameter: None Return: (int) The current speed of the gripper get_gripper_P() Function: Get the P value of the gripper PID Parameter: None Return: (int) The P value of the gripper PID get_gripper_I() Function: Get the I value of the gripper PID Parameter: None Return: (int) The I value of the gripper PID get_gripper_D() Function: Get the D value of the gripper PID Parameter: None Return: (int) The D value of the gripper PID get_gripper_cw() Function: Get the clockwise runnable error of the gripper Parameter: None Return: (int) Clockwise runnable error of the gripper get_gripper_cww() Function: Get the counterclockwise runnable error of the gripper Parameter: None Return: (int) Counterclockwise runnable error of the gripper get_gripper_mini_pressure() Function: Get the minimum starting force of the gripper Parameter: None Return: (int) Minimum starting force of the gripper get_gripper_io_open_value() Function: Get the opening angle of the gripper Io Parameter: None Return: (int) Opening angle of the gripper Io get_gripper_io_close_value() Function: Get the closing angle of the gripper Io Parameter: None Return: (int) Get the closing angle of the gripper Io get_gripper_queue_count() Function: Get the amount of data in the current queue of the gripper Parameter: None Return: (int) The amount of data in the current queue of the gripper get_gripper_vir_pos() Function: Get the virtual position value of the gripper servo Parameter: None Return: (int) The virtual position value of the gripper servo get_gripper_protection_current() Function: Get the gripper clamping current Parameter: None Return: (int) The gripper clamping current set_gripper_Id(value) Function: Set the gripper ID Parameters: value: (int) Gripper ID, value range 1-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_baud(value) Function: Set the gripper baud rate Parameter: value: (int) Gripper baud rate, value range 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 Return: (int) 0-1 0: Failed 1: Successful set_gripper_enable(value) Function: Set the gripper enable state Parameter: value: (int) Enable state, value range 0-1 0: Disabled 1: Enabled Return:(int) 0-1 0: Failed 1: Success set_gripper_value(value,speed) Function: Set the gripper to rotate to the specified position at the specified speed Parameter: value: (int) Position, value range 0-100 speed: (int) Speed, value range 1-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_calibration() Function: Set the gripper Zero Calibration Parameter: None Return:(int) 0-1 0: Failed 1: Success set_gripper_P(value) Function: Set the P value of the gripper PID Parameters: value: (int) P value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_I(value) Function: Set the I value of the gripper PID Parameters: value: (int) I value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_D(value) Function: Set the D value of the gripper PID Parameters: value: (int) D value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_cw(value) Function: Set the clockwise running error of the gripper Parameter: value: (int) Error, value range 0-16 Return: (int) 0-1 0: Failure 1: Success set_gripper_cww(value) Function: Set the counterclockwise running error of the gripper Parameter: value: (int) Error, value range 0-16 Return: (int) 0-1 0: Failure 1: Success set_gripper_mini_pressure(value) Function: Set the minimum starting force of the gripper Parameter: value: (int) Minimum starting force, value range 0-254 Return:(int) 0-1 0: Failed 1: Success set_gripper_torque(value) Function: Set gripper torque Parameter: value: (int) Torque, value range 0-300 Return:(int) 0-1 0: Failed 1: Success set_gripper_output(value) Function: Set gripper IO Parameter: value: (int) Gripper IO, value range 0-3 0: out1 off,out2 off 1: out1 on,out2 off 2: out1 off,out2 on 3: out1 on,out2 on Return:(int) 0-1 0: Failed 1: Success set_gripper_io_open_value(value) Function: Set the gripper Io open position Parameter: value: (int) position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_io_close_value(value) Function: Set the gripper Io closed position Parameter: value: (int) position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_speed(speed) Function: Set the gripper speed Parameters: speed: (int) speed, value range 1-100 Return: (int) 0-1 0: failed 1: successful set_abs_gripper_value(value,speed) Function: Set the gripper to rotate to the specified absolute position at the specified speed Parameters: value: (int) position, value range 1-100 speed: (int) speed, value range 1-100 Return: (int) 0-1 0: failed 1: successful set_gripper_vir_pos(value) Function: Set the virtual position value of the gripper servo Parameters: value: (int) virtual position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_protection_current(value) Function: Set the gripper gripping current Parameter: value: (int) Virtual position, value range 1-254 Return:(int) 0-1 0: Failed 1: Success set_gripper_pause() Function: Set the gripper to pause motion Remarks: Only valid for set_abs_gripper_value() Parameter: None Return:(int) 0-1 0: Failed 1: Success set_gripper_resume() Function: Set the gripper to resume motion Remarks: Only valid for set_abs_gripper_value() Parameters: None Return: (int) 0-1 0: Failure 1: Success set_gripper_stop() Function: Set the gripper to stop moving and clear the message queue Remarks: Only valid for set_abs_gripper_value() Parameters: None Return: (int) 0-1 0: Failure 1: Success Case Procedure from elegripper import Gripper import time if __name__==\"__main__\": g=Gripper(\"COM27\",baudrate=115200,id=14)##Fill in the actual serial port number, baud rate and gripper ID print(\"The actual ID of the gripper is:\",g.get_gripper_Id()) print(g.set_gripper_value(100,100)) time.sleep(2) print(g.set_gripper_value(0,100)) time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.2-PneumaticGripper.html":{"url":"4-SupportAndService/Accessories/10.2-PneumaticGripper.html","title":"10.2 PneumaticGripper","keywords":"","body":"Pneumatic Gripper Compatible models: myCobot 320, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Product Images Specifications Name mycobot Pneumatic Gripper Model myCobotPro_Gripper_Air_10 Material Metal + 7500 Nylon Gripping range 0-8mm Clamping force Outer diameter 34N Inner diameter 45N Drive mode Pneumatic Transmission method Piston cylinder Dimensions 67.3×38×23.6mm Weight 180g Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface Input/output control Applicable equipment myCobot 320 series, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Used For Grasping Objects Introduction Pneumatic grippers, also known as pneumatic fingers or pneumatic clamps, are actuators that use compressed air as power to grasp or grip workpieces. They are small in size, light in weight, compact in appearance, and can achieve unidirectional and bidirectional grasping, automatic centering, high repeatability, and automatic control of magnetic switches. The pneumatic gripper kit includes gripper flange, air pump, φ8 air pipe, φ6 air pipe, φ8-6 quick connector, solenoid valve and cable. Its main function is to replace manual grasping work, which can effectively improve production efficiency and work safety. An external suction pump is required. Working principle Single piston: The shaft drives the crank, and the air gripper is driven to open and close by the piston. The two claws are respectively arranged with corresponding crank grooves. In order to reduce friction resistance, the claws and the fuselage are connected by a steel ball slide structure. Double piston: controlled by two pistons, each piston is connected to a pneumatic finger through a roller and a double crank to form a special drive unit. It should be noted that the pneumatic finger always moves toward the center axis, and each pneumatic finger cannot move independently. Parallel clamp cylinder: If the pneumatic finger moves in the opposite direction, the previously compressed piston is in the exhaust state, and the other piston is in the compression state. Applicable objects Volume is smaller than the clamping stroke Weight is smaller than the maximum clamping weight Customized fingertips can expand more uses Installation and use Need to be used with an air compressor: Insert the black plug into the power strip; Insert the matching red hose into the interface on the machine: The red button is a switch. Pull it out to turn it on, and press it back to turn it off: Gripper installation: Connect the other end of the red hose of the air compressor to the interface of the solenoid valve: Unscrew another interface on the other end of the solenoid valve to start the gripper to control the opening and closing: Use two matching transparent hoses, one end of which is connected to the two interfaces of the solenoid valve: The other end of the transparent hose is connected to the two interfaces of the gripper: Use the matching screws to fix the gripper to the end of the robot arm: Electrical connection: Connect the black cable to the GND of the robot base, and the red cable to any one of OUT1~OUT6. Change the pin number of the subsequent program according to the selected interface. Here, use OUT1: 3 Through Python Control The robot system needs to be started before use Confirm the IP address of the robot arm: Enter ifconfig in the terminal to obtain from pymycobot import ElephantRobot import time # Change the ip to the real ip of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1) time.sleep(2) elephant_client.set_digital_out(0,0) time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.3-AdaptiveGripper.html":{"url":"4-SupportAndService/Accessories/10.3-AdaptiveGripper.html","title":"10.3 AdaptiveGripper","keywords":"","body":"myCobotPro Adaptive Gripper Compatible models: myCobot 320, myCobot Pro 630,myCobot Pro 600,myCobot Pro 450 Product Image Specifications Name myCobotPro Adaptive Gripper Black and White Material Photosensitive resin + nylon Process technology 3D printing Gripping range 0-90 mm Clamping force 1000 grams Drive mode Electric drive Gearbox mode Gear + connecting rod Dimensions 158x105x55mm Weight 350 grams Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface Serial port/IO control Applicable devices myCobot 320 series, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Used For Grabbing Objects Introduction A manipulator is a robot component that works like a human hand. It has the advantages of complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper connection wires and flanges. The end effector of the manipulator is controlled by a programmable system to realize functions such as grabbing objects and multi-point positioning. The gripper can be used in all development environments, such as ROS, Arduino, Roboflow, etc. Working Principle Driven by the motor, the finger surface of the manipulator makes linear reciprocating motion to achieve opening or closing actions. The acceleration and deceleration of the electric manipulator are controllable, the impact on the workpiece is minimal, the positioning point is controllable, and the clamping is controllable. Applicable Objects Small cubes Small balls Long objects Installation And Use Gripper installation: Structural installation: Align the gasket with the hole at the end of the robot arm and tighten it with screws: Align the screw holes of the gripper with the holes around the gasket and tighten them with thin screws: Electrical connection: Note that the robot arm should be powered off, that is, the green light at the end should not be on when plugging and unplugging. If hot-plugging is performed with power on, there is a risk of damaging the gripper. Align the m8 cable with the interface of the robot arm. Note that there is a notch at the interface and a corresponding protrusion on the connecting cable. After confirming the direction, insert it and tighten it: Insert the gripper control interface, and also pay attention to the direction of the notch: Python Programming Control You need to use roboflow to enable the robot first, then run the following python script to test whether the gripper is normal Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain Python Programming Control You need to use roboflow to enable the robot first, then run the following python script to test whether the gripper is normal Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain IO Control Mode from pymycobot import ElephantRobot import time # Change the ip to the real-time ip of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(1) time.sleep(1) #elephant_client.power_off()#When changing the IO mode from gripper to gripper, you need to shut down the machine and restart the robot. If you only use gripper to gripper mode, you do not need to shut down the robot elephant_client.power_off() time.sleep(3) elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) elephant_client.set_digital_out(16, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 0) # IO restores low level time.sleep(1) # IO mode # Gripper full open and full closed control code. Note that when the gripper is transparently switched to IO mode, you need to shut down the machine and restart the robot once before switching back to the gripper IO mode for i in range(3): elephant_client.set_digital_out(16, 1) # Close the gripper time.sleep(1) elephant_client.set_digital_out(17, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(16, 0) #IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 1) # Open the gripper time.sleep(1) elephant_client.set_digital_out(16, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 0) # IO returns to low level time.sleep(1) Transparent Transmission Mode from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) # elephant_client.power_off()#When changing the IO mode of the gripper through transmission, you need to shut down the machine and restart the robot once. If you only use the gripper through transmission mode, you do not need to shut down the robot elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) #Transparent transmission mode for i in range(3): elephant_client.set_gripper_value(26,20) time.sleep(1) elephant_client.set_gripper_value(86,20) time.sleep(1) Gripper Zero Position Calibration The gripper has been zero-calibrated before leaving the factory. If the gripper's stroke is incorrect, you can calibrate it according to the following steps First turn off the robot in roboflow, and manually open the gripper to the maximum Then start the robot Then execute the following script from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) elephant_client.set_gripper_calibrate() time.sleep(1) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.4-phoneHolder.html":{"url":"4-SupportAndService/Accessories/10.4-phoneHolder.html","title":"10.4 PhoneHolder","keywords":"","body":"myCobot Phone Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myCobot Pro 450 Product image Specifications: Name myCobot Phone Holder Model myCobot_PhoneHolder_J6 Material ABS injection molding Size Diameter 34*10 Color White+Black Clamping weight 50g Service life Two years Fixing method LEGO connector Environmental requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series ER mechArm 270 series ER myPalletizer 260 series ER myCobot Pro 450 myCobot mobile phone holder: Used to hold mobile phones or objects Introduction Suitable for devices that require physical clamping, such as photography, and can hold a variety of mobile phones. It has a simple structure and is easy to install and disassemble. Applicable objects Camera equipment Installation Insert the LEGO connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Pull the holder open, put the camera in, and let go. After confirming that the device is fixed, it can be used. ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.5-3DCamera.html":{"url":"4-SupportAndService/Accessories/10.5-3DCamera.html","title":"10.5 3DCamera","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.6-SingleSuctionPump.html":{"url":"4-SupportAndService/Accessories/10.6-SingleSuctionPump.html","title":"10.6 SingleSuctionPump","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.7-ModuleSuctionCup.html":{"url":"4-SupportAndService/Accessories/10.7-ModuleSuctionCup.html","title":"10.7 ModuleSuctionCup","keywords":"","body":"Suction Cup Module Compatible Models: myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Product Image Specifications Name Module Suction Cup Model myCobotPro_suctionPump Material Nylon 7100 Number of Suction Cups 1/2/4 Suction Cup Size Diameter 33mm Suction Weight Maximum 1000g Power Source Equipment Suction and Blowing Air Compressor Fixing Method Screw Fixing Control interface IO control Environment requirements Normal temperature and pressure Applicable equipment myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Suction cup suction pump: Used to adsorb objects Introduction The suction cup suction pump is connected to the object to be adsorbed through the suction cup, pipe and other components, and the suction cup is vacuumed, causing the internal air pressure to change from normal pressure to negative pressure, and the pressure difference between the external atmospheric pressure and this negative pressure is used to achieve the purpose of adsorbing the object. The overall structure is a multifunctional expandable suction cup, which can be installed up to 4; high-pressure resistant hose, which can be reused many times; suction and blowing integrated air compressor, which can expand other functions. Working principle Start the vacuum equipment to suck, so that negative air pressure is generated in the suction cup, so that the object to be lifted is firmly sucked, and the object to be lifted can be transported. When the object to be lifted is transported to the destination, air is steadily inflated into the vacuum cup, so that the negative pressure in the vacuum cup changes to zero pressure or slightly positive pressure, and the vacuum cup is separated from the object to be lifted, thus completing the task of lifting and transporting heavy objects. Applicable objects Applicable to flat objects Installation and use Need to be used with air compressor: Insert the black plug into the power strip; Insert the matching red hose into the interface on the machine: The red button is a switch. Pull it out to turn it on, and press it back to turn it off: Suction cup installation: Connect the other end of the red hose of the air compressor to the interface of the solenoid valve: Use the transparent hose that comes with the module suction cup to connect the interfaces above the solenoid valve and the module suction cup hose branch: Fix the module suction cup to the end of the robot arm with the matching screws: Install the hose branch on the module suction cup: Electrical connection: Connect the black cable to the base of the robot arm GND, red connects to any one of OUT1~OUT6, change the pin number of the subsequent program according to the selected interface, here use OUT1: 3 Control By Python You need to start the robot system before use Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1)#Absorb time.sleep(2) elephant_client.set_digital_out(0,0)#Release time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.8-CameraModulePro.html":{"url":"4-SupportAndService/Accessories/10.8-CameraModulePro.html","title":"10.8 CameraModulePro","keywords":"","body":"myCobotPro Camera Module Compatible models: myCobot 320, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Product Images Specifications: Name myCobotPro camera module Model myCobot_Pro_cameraHolder_J6 Material Photosensitive resin USB protocol USB2.0 HS/FS Lens focal length Standard 1.7mm Field of view About 60° Supported systems Win7/8/10, Linux, MAC Fixing method Screw fixing Operating environment requirements Normal temperature and pressure Applicable equipment myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Camera flange: Machine vision Introduction USB high-definition camera can be used with suction pump, adaptive gripper, artificial intelligence kit, etc., to achieve precise positioning and calibration with eye in hand. Installation and Use Check if the accessories package is complete: screws and hex wrench, camera module with USB cable Camera installation: Structural installation: Align the camera module with the end of the robot arm according to the required direction, and tighten the screws with the hex wrench Electrical connection: Plug the USB cable into the USB port of the base: Python Programming Control Enter the robot system, open the terminal and enter the following command to install opencv sudo apt-get install -y libopencv-dev python3-opencv Create a new python file and fill in the following code #encoding=utf-8 import cv2 import numpy as np cap = cv2.VideoCapture(0) while(True): ret, frame = cap.read() cv2.imshow('frame', frame) # Press 'q' to exit if cv2.waitKey(1) & 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() Then use python3 in the terminal Run the newly created python file ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.9-penHolder.html":{"url":"4-SupportAndService/Accessories/10.9-penHolder.html","title":"10.9 PenHolder","keywords":"","body":"myCobot Pen Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series, ER myCobot Pro 450 Product image Specifications: Name myCobotPro Pen Holder Model myCobot_penHolder_J6 Material Photosensitive resin (painted white) Dimensions 47.5 x 25.0 x 45.5 mm Weight Approx. 35g (excluding pen weight) Pen tip clearance ±1 mm Service life One year Fixing method Lego connector Environment requirements Normal temperature and pressure Applicable equipment Support ER myCobot 280 series ER myPalletizer 260 series ER mechArm 270 series ER myBuddy 280 series ER myCobot Pro 450 myCobot pen holder: Used when writing and drawing with a robotic arm Introduction Overall solid color design, supports 15mm large stroke extension and retraction, effectively reduces errors, and can be used for writing, drawing and other applications. Applicable objects Whiteboard pen Installation and use Installation Insert the Lego connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Insert the pen into the round hole and tighten the four screws to fix it. ← Previous Chapter | Next Chapter→ "},"5-Acknowledgments/5-Acknowledgments.html":{"url":"5-Acknowledgments/5-Acknowledgments.html","title":"11 Acknowledgments","keywords":"","body":"Acknowledgements We would like to express our deep gratitude to all the people who have participated in the development, testing and improvement of the myCobot series of products (including myCobot 280 pi, myCobot 280 M5, myCobot 280 JN, myCobot 280 For Arduino, myCobot Pro 450 and kits). Every detail polished and every feature innovative is inseparable from the hard work and dedication of the team behind it. Special Thanks: R&D Team: Thank you for your innovative thinking and countless days and nights of hard work to transform complex technology into user-friendly products. QA & Testing Team: Your strict control of every detail ensures the reliability of our products and the ultimate experience of users. Customer Support Team: Thank you for providing professional support to our users to help them solve every problem during use. Partners & Suppliers: Your support and service are crucial to the success of the product. Thank you for your high-quality raw materials and components, and your attitude of being ready to support. Investors and Advisors: Without your trust and financial support, we would not be able to bring these innovations to the market. Your insights and guidance have always been our driving force. User Thanks: We are especially grateful to every user who has chosen and trusted the myCobot series of products. Your feedback and suggestions are the driving force for our continuous progress and improvement. We promise to continue to listen to your voice and continuously optimize our products and services. Future Outlook: We look forward to continuing to explore and progress on the road of robotics with all stakeholders. Let us work together to create more possibilities and bring greater convenience and innovation to the world. ← Previous Chapter "}}